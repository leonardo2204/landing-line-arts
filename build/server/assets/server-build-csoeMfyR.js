import { r as requireReact, S as ServerRouter, a as reactExports, u as useLocation, R as React3, b as useNavigate, L as Link, g as getDefaultExportFromCjs, w as withComponentProps, c as withErrorBoundaryProps, M as Meta, d as Links, e as ScrollRestoration, f as Scripts, O as Outlet, i as isRouteErrorResponse, h as useLoaderData, A as Await, n as notImplemented, j as getAugmentedNamespace, k as commonjsGlobal, l as useParams } from "./app-CcAZ_y2y.js";
import "node:events";
import "node:stream";
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var f2 = requireReact(), k2 = Symbol.for("react.element"), l2 = Symbol.for("react.fragment"), m2 = Object.prototype.hasOwnProperty, n2 = f2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p2 = { key: true, ref: true, __self: true, __source: true };
  function q2(c2, a2, g2) {
    var b2, d2 = {}, e2 = null, h2 = null;
    void 0 !== g2 && (e2 = "" + g2);
    void 0 !== a2.key && (e2 = "" + a2.key);
    void 0 !== a2.ref && (h2 = a2.ref);
    for (b2 in a2) m2.call(a2, b2) && !p2.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
    if (c2 && c2.defaultProps) for (b2 in a2 = c2.defaultProps, a2) void 0 === d2[b2] && (d2[b2] = a2[b2]);
    return { $$typeof: k2, type: c2, key: e2, ref: h2, props: d2, _owner: n2.current };
  }
  reactJsxRuntime_production_min.Fragment = l2;
  reactJsxRuntime_production_min.jsx = q2;
  reactJsxRuntime_production_min.jsxs = q2;
  return reactJsxRuntime_production_min;
}
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
  if (hasRequiredJsxRuntime) return jsxRuntime.exports;
  hasRequiredJsxRuntime = 1;
  {
    jsxRuntime.exports = requireReactJsxRuntime_production_min();
  }
  return jsxRuntime.exports;
}
var jsxRuntimeExports = requireJsxRuntime();
var fullPattern = " daum[ /]| deusu/| yadirectfetcher|(?:^|[^g])news(?!sapphire)|(?<! (?:channel/|google/))google(?!(app|/google| pixel))|(?<! cu)bots?(?:\\b|_)|(?<!(?:lib))http|(?<![hg]m)score|(?<!cam)scan|@[a-z][\\w-]+\\.|\\(\\)|\\.com\\b|\\btime/|\\||^<|^[\\w \\.\\-\\(?:\\):%]+(?:/v?\\d+(?:\\.\\d+)?(?:\\.\\d{1,10})*?)?(?:,|$)|^[^ ]{50,}$|^\\d+\\b|^\\w*search\\b|^\\w+/[\\w\\(\\)]*$|^active|^ad muncher|^amaya|^avsdevicesdk/|^biglotron|^bot|^bw/|^clamav[ /]|^client/|^cobweb/|^custom|^ddg[_-]android|^discourse|^dispatch/\\d|^downcast/|^duckduckgo|^email|^facebook|^getright/|^gozilla/|^hobbit|^hotzonu|^hwcdn/|^igetter/|^jeode/|^jetty/|^jigsaw|^microsoft bits|^movabletype|^mozilla/\\d\\.\\d\\s[\\w\\.-]+$|^mozilla/\\d\\.\\d\\s\\(compatible;?(?:\\s\\w+\\/\\d+\\.\\d+)?\\)$|^navermailapp|^netsurf|^offline|^openai/|^owler|^php|^postman|^python|^rank|^read|^reed|^rest|^rss|^snapchat|^space bison|^svn|^swcd |^taringa|^thumbor/|^track|^w3c|^webbandit/|^webcopier|^wget|^whatsapp|^wordpress|^xenu link sleuth|^yahoo|^yandex|^zdm/\\d|^zoom marketplace/|^{{.*}}$|analyzer|archive|ask jeeves/teoma|audit|bit\\.ly/|bluecoat drtr|browsex|burpcollaborator|capture|catch|check\\b|checker|chrome-lighthouse|chromeframe|classifier|cloudflare|convertify|crawl|cypress/|dareboost|datanyze|dejaclick|detect|dmbrowser|download|evc-batch/|exaleadcloudview|feed|firephp|functionize|gomezagent|grab|headless|httrack|hubspot marketing grader|hydra|ibisbrowser|infrawatch|insight|inspect|iplabel|ips-agent|java(?!;)|library|linkcheck|mail\\.ru/|manager|measure|neustar wpm|node|nutch|offbyone|onetrust|optimize|pageburst|pagespeed|parser|perl|phantomjs|pingdom|powermarks|preview|proxy|ptst[ /]\\d|retriever|rexx;|rigor|rss\\b|scrape|server|sogou|sparkler/|speedcurve|spider|splash|statuscake|supercleaner|synapse|synthetic|tools|torrent|transcoder|url|validator|virtuoso|wappalyzer|webglance|webkit2png|whatcms/|xtate/";
var naivePattern = /bot|crawl|http|lighthouse|scan|search|spider/i;
var pattern;
function getPattern() {
  if (pattern instanceof RegExp) {
    return pattern;
  }
  try {
    pattern = new RegExp(fullPattern, "i");
  } catch (error) {
    pattern = naivePattern;
  }
  return pattern;
}
function isbot(userAgent) {
  return Boolean(userAgent) && getPattern().test(userAgent);
}
var server_browser = {};
var reactDomServerLegacy_browser_production_min = {};
/**
 * @license React
 * react-dom-server-legacy.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDomServerLegacy_browser_production_min;
function requireReactDomServerLegacy_browser_production_min() {
  if (hasRequiredReactDomServerLegacy_browser_production_min) return reactDomServerLegacy_browser_production_min;
  hasRequiredReactDomServerLegacy_browser_production_min = 1;
  var aa2 = requireReact();
  function l2(a2) {
    for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++) b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
    return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var p2 = Object.prototype.hasOwnProperty, fa = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, ha2 = {}, ia2 = {};
  function ja(a2) {
    if (p2.call(ia2, a2)) return true;
    if (p2.call(ha2, a2)) return false;
    if (fa.test(a2)) return ia2[a2] = true;
    ha2[a2] = true;
    return false;
  }
  function r2(a2, b2, c2, d2, f2, e2, g2) {
    this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
    this.attributeName = d2;
    this.attributeNamespace = f2;
    this.mustUseProperty = c2;
    this.propertyName = a2;
    this.type = b2;
    this.sanitizeURL = e2;
    this.removeEmptyString = g2;
  }
  var t2 = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
    t2[a2] = new r2(a2, 0, false, a2, null, false, false);
  });
  [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
    var b2 = a2[0];
    t2[b2] = new r2(b2, 1, false, a2[1], null, false, false);
  });
  ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
    t2[a2] = new r2(a2, 2, false, a2.toLowerCase(), null, false, false);
  });
  ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
    t2[a2] = new r2(a2, 2, false, a2, null, false, false);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
    t2[a2] = new r2(a2, 3, false, a2.toLowerCase(), null, false, false);
  });
  ["checked", "multiple", "muted", "selected"].forEach(function(a2) {
    t2[a2] = new r2(a2, 3, true, a2, null, false, false);
  });
  ["capture", "download"].forEach(function(a2) {
    t2[a2] = new r2(a2, 4, false, a2, null, false, false);
  });
  ["cols", "rows", "size", "span"].forEach(function(a2) {
    t2[a2] = new r2(a2, 6, false, a2, null, false, false);
  });
  ["rowSpan", "start"].forEach(function(a2) {
    t2[a2] = new r2(a2, 5, false, a2.toLowerCase(), null, false, false);
  });
  var ka = /[\-:]([a-z])/g;
  function la2(a2) {
    return a2[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
    var b2 = a2.replace(
      ka,
      la2
    );
    t2[b2] = new r2(b2, 1, false, a2, null, false, false);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
    var b2 = a2.replace(ka, la2);
    t2[b2] = new r2(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
  });
  ["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
    var b2 = a2.replace(ka, la2);
    t2[b2] = new r2(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
  });
  ["tabIndex", "crossOrigin"].forEach(function(a2) {
    t2[a2] = new r2(a2, 1, false, a2.toLowerCase(), null, false, false);
  });
  t2.xlinkHref = new r2("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
  ["src", "href", "action", "formAction"].forEach(function(a2) {
    t2[a2] = new r2(a2, 1, false, a2.toLowerCase(), null, true, true);
  });
  var u2 = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridArea: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  }, ma = ["Webkit", "ms", "Moz", "O"];
  Object.keys(u2).forEach(function(a2) {
    ma.forEach(function(b2) {
      b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
      u2[b2] = u2[a2];
    });
  });
  var na2 = /["'&<>]/;
  function v2(a2) {
    if ("boolean" === typeof a2 || "number" === typeof a2) return "" + a2;
    a2 = "" + a2;
    var b2 = na2.exec(a2);
    if (b2) {
      var c2 = "", d2, f2 = 0;
      for (d2 = b2.index; d2 < a2.length; d2++) {
        switch (a2.charCodeAt(d2)) {
          case 34:
            b2 = "&quot;";
            break;
          case 38:
            b2 = "&amp;";
            break;
          case 39:
            b2 = "&#x27;";
            break;
          case 60:
            b2 = "&lt;";
            break;
          case 62:
            b2 = "&gt;";
            break;
          default:
            continue;
        }
        f2 !== d2 && (c2 += a2.substring(f2, d2));
        f2 = d2 + 1;
        c2 += b2;
      }
      a2 = f2 !== d2 ? c2 + a2.substring(f2, d2) : c2;
    }
    return a2;
  }
  var oa2 = /([A-Z])/g, pa = /^ms-/, qa = Array.isArray;
  function w2(a2, b2) {
    return { insertionMode: a2, selectedValue: b2 };
  }
  function ra2(a2, b2, c2) {
    switch (b2) {
      case "select":
        return w2(1, null != c2.value ? c2.value : c2.defaultValue);
      case "svg":
        return w2(2, null);
      case "math":
        return w2(3, null);
      case "foreignObject":
        return w2(1, null);
      case "table":
        return w2(4, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return w2(5, null);
      case "colgroup":
        return w2(7, null);
      case "tr":
        return w2(6, null);
    }
    return 4 <= a2.insertionMode || 0 === a2.insertionMode ? w2(1, null) : a2;
  }
  var sa2 = /* @__PURE__ */ new Map();
  function ta2(a2, b2, c2) {
    if ("object" !== typeof c2) throw Error(l2(62));
    b2 = true;
    for (var d2 in c2) if (p2.call(c2, d2)) {
      var f2 = c2[d2];
      if (null != f2 && "boolean" !== typeof f2 && "" !== f2) {
        if (0 === d2.indexOf("--")) {
          var e2 = v2(d2);
          f2 = v2(("" + f2).trim());
        } else {
          e2 = d2;
          var g2 = sa2.get(e2);
          void 0 !== g2 ? e2 = g2 : (g2 = v2(e2.replace(oa2, "-$1").toLowerCase().replace(pa, "-ms-")), sa2.set(e2, g2), e2 = g2);
          f2 = "number" === typeof f2 ? 0 === f2 || p2.call(u2, d2) ? "" + f2 : f2 + "px" : v2(("" + f2).trim());
        }
        b2 ? (b2 = false, a2.push(' style="', e2, ":", f2)) : a2.push(";", e2, ":", f2);
      }
    }
    b2 || a2.push('"');
  }
  function x2(a2, b2, c2, d2) {
    switch (c2) {
      case "style":
        ta2(a2, b2, d2);
        return;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
        return;
    }
    if (!(2 < c2.length) || "o" !== c2[0] && "O" !== c2[0] || "n" !== c2[1] && "N" !== c2[1]) {
      if (b2 = t2.hasOwnProperty(c2) ? t2[c2] : null, null !== b2) {
        switch (typeof d2) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (!b2.acceptsBooleans) return;
        }
        c2 = b2.attributeName;
        switch (b2.type) {
          case 3:
            d2 && a2.push(" ", c2, '=""');
            break;
          case 4:
            true === d2 ? a2.push(" ", c2, '=""') : false !== d2 && a2.push(" ", c2, '="', v2(d2), '"');
            break;
          case 5:
            isNaN(d2) || a2.push(" ", c2, '="', v2(d2), '"');
            break;
          case 6:
            !isNaN(d2) && 1 <= d2 && a2.push(" ", c2, '="', v2(d2), '"');
            break;
          default:
            b2.sanitizeURL && (d2 = "" + d2), a2.push(" ", c2, '="', v2(d2), '"');
        }
      } else if (ja(c2)) {
        switch (typeof d2) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (b2 = c2.toLowerCase().slice(0, 5), "data-" !== b2 && "aria-" !== b2) return;
        }
        a2.push(" ", c2, '="', v2(d2), '"');
      }
    }
  }
  function y2(a2, b2, c2) {
    if (null != b2) {
      if (null != c2) throw Error(l2(60));
      if ("object" !== typeof b2 || !("__html" in b2)) throw Error(l2(61));
      b2 = b2.__html;
      null !== b2 && void 0 !== b2 && a2.push("" + b2);
    }
  }
  function ua2(a2) {
    var b2 = "";
    aa2.Children.forEach(a2, function(a3) {
      null != a3 && (b2 += a3);
    });
    return b2;
  }
  function va(a2, b2, c2, d2) {
    a2.push(A2(c2));
    var f2 = c2 = null, e2;
    for (e2 in b2) if (p2.call(b2, e2)) {
      var g2 = b2[e2];
      if (null != g2) switch (e2) {
        case "children":
          c2 = g2;
          break;
        case "dangerouslySetInnerHTML":
          f2 = g2;
          break;
        default:
          x2(a2, d2, e2, g2);
      }
    }
    a2.push(">");
    y2(a2, f2, c2);
    return "string" === typeof c2 ? (a2.push(v2(c2)), null) : c2;
  }
  var wa = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, xa = /* @__PURE__ */ new Map();
  function A2(a2) {
    var b2 = xa.get(a2);
    if (void 0 === b2) {
      if (!wa.test(a2)) throw Error(l2(65, a2));
      b2 = "<" + a2;
      xa.set(a2, b2);
    }
    return b2;
  }
  function ya(a2, b2, c2, d2, f2) {
    switch (b2) {
      case "select":
        a2.push(A2("select"));
        var e2 = null, g2 = null;
        for (n2 in c2) if (p2.call(c2, n2)) {
          var h2 = c2[n2];
          if (null != h2) switch (n2) {
            case "children":
              e2 = h2;
              break;
            case "dangerouslySetInnerHTML":
              g2 = h2;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              x2(a2, d2, n2, h2);
          }
        }
        a2.push(">");
        y2(a2, g2, e2);
        return e2;
      case "option":
        g2 = f2.selectedValue;
        a2.push(A2("option"));
        var k2 = h2 = null, m2 = null;
        var n2 = null;
        for (e2 in c2) if (p2.call(c2, e2)) {
          var q2 = c2[e2];
          if (null != q2) switch (e2) {
            case "children":
              h2 = q2;
              break;
            case "selected":
              m2 = q2;
              break;
            case "dangerouslySetInnerHTML":
              n2 = q2;
              break;
            case "value":
              k2 = q2;
            default:
              x2(a2, d2, e2, q2);
          }
        }
        if (null != g2) if (c2 = null !== k2 ? "" + k2 : ua2(h2), qa(g2)) for (d2 = 0; d2 < g2.length; d2++) {
          if ("" + g2[d2] === c2) {
            a2.push(' selected=""');
            break;
          }
        }
        else "" + g2 === c2 && a2.push(' selected=""');
        else m2 && a2.push(' selected=""');
        a2.push(">");
        y2(a2, n2, h2);
        return h2;
      case "textarea":
        a2.push(A2("textarea"));
        n2 = g2 = e2 = null;
        for (h2 in c2) if (p2.call(c2, h2) && (k2 = c2[h2], null != k2)) switch (h2) {
          case "children":
            n2 = k2;
            break;
          case "value":
            e2 = k2;
            break;
          case "defaultValue":
            g2 = k2;
            break;
          case "dangerouslySetInnerHTML":
            throw Error(l2(91));
          default:
            x2(
              a2,
              d2,
              h2,
              k2
            );
        }
        null === e2 && null !== g2 && (e2 = g2);
        a2.push(">");
        if (null != n2) {
          if (null != e2) throw Error(l2(92));
          if (qa(n2) && 1 < n2.length) throw Error(l2(93));
          e2 = "" + n2;
        }
        "string" === typeof e2 && "\n" === e2[0] && a2.push("\n");
        null !== e2 && a2.push(v2("" + e2));
        return null;
      case "input":
        a2.push(A2("input"));
        k2 = n2 = h2 = e2 = null;
        for (g2 in c2) if (p2.call(c2, g2) && (m2 = c2[g2], null != m2)) switch (g2) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error(l2(399, "input"));
          case "defaultChecked":
            k2 = m2;
            break;
          case "defaultValue":
            h2 = m2;
            break;
          case "checked":
            n2 = m2;
            break;
          case "value":
            e2 = m2;
            break;
          default:
            x2(a2, d2, g2, m2);
        }
        null !== n2 ? x2(a2, d2, "checked", n2) : null !== k2 && x2(a2, d2, "checked", k2);
        null !== e2 ? x2(a2, d2, "value", e2) : null !== h2 && x2(a2, d2, "value", h2);
        a2.push("/>");
        return null;
      case "menuitem":
        a2.push(A2("menuitem"));
        for (var C2 in c2) if (p2.call(c2, C2) && (e2 = c2[C2], null != e2)) switch (C2) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error(l2(400));
          default:
            x2(a2, d2, C2, e2);
        }
        a2.push(">");
        return null;
      case "title":
        a2.push(A2("title"));
        e2 = null;
        for (q2 in c2) if (p2.call(c2, q2) && (g2 = c2[q2], null != g2)) switch (q2) {
          case "children":
            e2 = g2;
            break;
          case "dangerouslySetInnerHTML":
            throw Error(l2(434));
          default:
            x2(a2, d2, q2, g2);
        }
        a2.push(">");
        return e2;
      case "listing":
      case "pre":
        a2.push(A2(b2));
        g2 = e2 = null;
        for (k2 in c2) if (p2.call(c2, k2) && (h2 = c2[k2], null != h2)) switch (k2) {
          case "children":
            e2 = h2;
            break;
          case "dangerouslySetInnerHTML":
            g2 = h2;
            break;
          default:
            x2(a2, d2, k2, h2);
        }
        a2.push(">");
        if (null != g2) {
          if (null != e2) throw Error(l2(60));
          if ("object" !== typeof g2 || !("__html" in g2)) throw Error(l2(61));
          c2 = g2.__html;
          null !== c2 && void 0 !== c2 && ("string" === typeof c2 && 0 < c2.length && "\n" === c2[0] ? a2.push("\n", c2) : a2.push("" + c2));
        }
        "string" === typeof e2 && "\n" === e2[0] && a2.push("\n");
        return e2;
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        a2.push(A2(b2));
        for (var D2 in c2) if (p2.call(c2, D2) && (e2 = c2[D2], null != e2)) switch (D2) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error(l2(399, b2));
          default:
            x2(a2, d2, D2, e2);
        }
        a2.push("/>");
        return null;
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return va(
          a2,
          c2,
          b2,
          d2
        );
      case "html":
        return 0 === f2.insertionMode && a2.push("<!DOCTYPE html>"), va(a2, c2, b2, d2);
      default:
        if (-1 === b2.indexOf("-") && "string" !== typeof c2.is) return va(a2, c2, b2, d2);
        a2.push(A2(b2));
        g2 = e2 = null;
        for (m2 in c2) if (p2.call(c2, m2) && (h2 = c2[m2], null != h2)) switch (m2) {
          case "children":
            e2 = h2;
            break;
          case "dangerouslySetInnerHTML":
            g2 = h2;
            break;
          case "style":
            ta2(a2, d2, h2);
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
            break;
          default:
            ja(m2) && "function" !== typeof h2 && "symbol" !== typeof h2 && a2.push(" ", m2, '="', v2(h2), '"');
        }
        a2.push(">");
        y2(a2, g2, e2);
        return e2;
    }
  }
  function za(a2, b2, c2) {
    a2.push('<!--$?--><template id="');
    if (null === c2) throw Error(l2(395));
    a2.push(c2);
    return a2.push('"></template>');
  }
  function Aa(a2, b2, c2, d2) {
    switch (c2.insertionMode) {
      case 0:
      case 1:
        return a2.push('<div hidden id="'), a2.push(b2.segmentPrefix), b2 = d2.toString(16), a2.push(b2), a2.push('">');
      case 2:
        return a2.push('<svg aria-hidden="true" style="display:none" id="'), a2.push(b2.segmentPrefix), b2 = d2.toString(16), a2.push(b2), a2.push('">');
      case 3:
        return a2.push('<math aria-hidden="true" style="display:none" id="'), a2.push(b2.segmentPrefix), b2 = d2.toString(16), a2.push(b2), a2.push('">');
      case 4:
        return a2.push('<table hidden id="'), a2.push(b2.segmentPrefix), b2 = d2.toString(16), a2.push(b2), a2.push('">');
      case 5:
        return a2.push('<table hidden><tbody id="'), a2.push(b2.segmentPrefix), b2 = d2.toString(16), a2.push(b2), a2.push('">');
      case 6:
        return a2.push('<table hidden><tr id="'), a2.push(b2.segmentPrefix), b2 = d2.toString(16), a2.push(b2), a2.push('">');
      case 7:
        return a2.push('<table hidden><colgroup id="'), a2.push(b2.segmentPrefix), b2 = d2.toString(16), a2.push(b2), a2.push('">');
      default:
        throw Error(l2(397));
    }
  }
  function Ba(a2, b2) {
    switch (b2.insertionMode) {
      case 0:
      case 1:
        return a2.push("</div>");
      case 2:
        return a2.push("</svg>");
      case 3:
        return a2.push("</math>");
      case 4:
        return a2.push("</table>");
      case 5:
        return a2.push("</tbody></table>");
      case 6:
        return a2.push("</tr></table>");
      case 7:
        return a2.push("</colgroup></table>");
      default:
        throw Error(l2(397));
    }
  }
  var Ca = /[<\u2028\u2029]/g;
  function Da(a2) {
    return JSON.stringify(a2).replace(Ca, function(a3) {
      switch (a3) {
        case "<":
          return "\\u003c";
        case "\u2028":
          return "\\u2028";
        case "\u2029":
          return "\\u2029";
        default:
          throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    });
  }
  function Ea(a2, b2) {
    b2 = void 0 === b2 ? "" : b2;
    return { bootstrapChunks: [], startInlineScript: "<script>", placeholderPrefix: b2 + "P:", segmentPrefix: b2 + "S:", boundaryPrefix: b2 + "B:", idPrefix: b2, nextSuspenseID: 0, sentCompleteSegmentFunction: false, sentCompleteBoundaryFunction: false, sentClientRenderFunction: false, generateStaticMarkup: a2 };
  }
  function Fa(a2, b2, c2, d2) {
    if (c2.generateStaticMarkup) return a2.push(v2(b2)), false;
    "" === b2 ? a2 = d2 : (d2 && a2.push("<!-- -->"), a2.push(v2(b2)), a2 = true);
    return a2;
  }
  var B2 = Object.assign, Ga = Symbol.for("react.element"), Ha = Symbol.for("react.portal"), Ia = Symbol.for("react.fragment"), Ja = Symbol.for("react.strict_mode"), Ka = Symbol.for("react.profiler"), La = Symbol.for("react.provider"), Ma = Symbol.for("react.context"), Na = Symbol.for("react.forward_ref"), Oa = Symbol.for("react.suspense"), Pa = Symbol.for("react.suspense_list"), Qa = Symbol.for("react.memo"), Ra = Symbol.for("react.lazy"), Sa = Symbol.for("react.scope"), Ta = Symbol.for("react.debug_trace_mode"), Ua = Symbol.for("react.legacy_hidden"), Va = Symbol.for("react.default_value"), Wa = Symbol.iterator;
  function Xa(a2) {
    if (null == a2) return null;
    if ("function" === typeof a2) return a2.displayName || a2.name || null;
    if ("string" === typeof a2) return a2;
    switch (a2) {
      case Ia:
        return "Fragment";
      case Ha:
        return "Portal";
      case Ka:
        return "Profiler";
      case Ja:
        return "StrictMode";
      case Oa:
        return "Suspense";
      case Pa:
        return "SuspenseList";
    }
    if ("object" === typeof a2) switch (a2.$$typeof) {
      case Ma:
        return (a2.displayName || "Context") + ".Consumer";
      case La:
        return (a2._context.displayName || "Context") + ".Provider";
      case Na:
        var b2 = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case Qa:
        return b2 = a2.displayName || null, null !== b2 ? b2 : Xa(a2.type) || "Memo";
      case Ra:
        b2 = a2._payload;
        a2 = a2._init;
        try {
          return Xa(a2(b2));
        } catch (c2) {
        }
    }
    return null;
  }
  var Ya = {};
  function Za(a2, b2) {
    a2 = a2.contextTypes;
    if (!a2) return Ya;
    var c2 = {}, d2;
    for (d2 in a2) c2[d2] = b2[d2];
    return c2;
  }
  var E2 = null;
  function F2(a2, b2) {
    if (a2 !== b2) {
      a2.context._currentValue2 = a2.parentValue;
      a2 = a2.parent;
      var c2 = b2.parent;
      if (null === a2) {
        if (null !== c2) throw Error(l2(401));
      } else {
        if (null === c2) throw Error(l2(401));
        F2(a2, c2);
      }
      b2.context._currentValue2 = b2.value;
    }
  }
  function $a(a2) {
    a2.context._currentValue2 = a2.parentValue;
    a2 = a2.parent;
    null !== a2 && $a(a2);
  }
  function ab(a2) {
    var b2 = a2.parent;
    null !== b2 && ab(b2);
    a2.context._currentValue2 = a2.value;
  }
  function bb(a2, b2) {
    a2.context._currentValue2 = a2.parentValue;
    a2 = a2.parent;
    if (null === a2) throw Error(l2(402));
    a2.depth === b2.depth ? F2(a2, b2) : bb(a2, b2);
  }
  function cb(a2, b2) {
    var c2 = b2.parent;
    if (null === c2) throw Error(l2(402));
    a2.depth === c2.depth ? F2(a2, c2) : cb(a2, c2);
    b2.context._currentValue2 = b2.value;
  }
  function G2(a2) {
    var b2 = E2;
    b2 !== a2 && (null === b2 ? ab(a2) : null === a2 ? $a(b2) : b2.depth === a2.depth ? F2(b2, a2) : b2.depth > a2.depth ? bb(b2, a2) : cb(b2, a2), E2 = a2);
  }
  var db = { isMounted: function() {
    return false;
  }, enqueueSetState: function(a2, b2) {
    a2 = a2._reactInternals;
    null !== a2.queue && a2.queue.push(b2);
  }, enqueueReplaceState: function(a2, b2) {
    a2 = a2._reactInternals;
    a2.replace = true;
    a2.queue = [b2];
  }, enqueueForceUpdate: function() {
  } };
  function eb(a2, b2, c2, d2) {
    var f2 = void 0 !== a2.state ? a2.state : null;
    a2.updater = db;
    a2.props = c2;
    a2.state = f2;
    var e2 = { queue: [], replace: false };
    a2._reactInternals = e2;
    var g2 = b2.contextType;
    a2.context = "object" === typeof g2 && null !== g2 ? g2._currentValue2 : d2;
    g2 = b2.getDerivedStateFromProps;
    "function" === typeof g2 && (g2 = g2(c2, f2), f2 = null === g2 || void 0 === g2 ? f2 : B2({}, f2, g2), a2.state = f2);
    if ("function" !== typeof b2.getDerivedStateFromProps && "function" !== typeof a2.getSnapshotBeforeUpdate && ("function" === typeof a2.UNSAFE_componentWillMount || "function" === typeof a2.componentWillMount)) if (b2 = a2.state, "function" === typeof a2.componentWillMount && a2.componentWillMount(), "function" === typeof a2.UNSAFE_componentWillMount && a2.UNSAFE_componentWillMount(), b2 !== a2.state && db.enqueueReplaceState(a2, a2.state, null), null !== e2.queue && 0 < e2.queue.length) if (b2 = e2.queue, g2 = e2.replace, e2.queue = null, e2.replace = false, g2 && 1 === b2.length) a2.state = b2[0];
    else {
      e2 = g2 ? b2[0] : a2.state;
      f2 = true;
      for (g2 = g2 ? 1 : 0; g2 < b2.length; g2++) {
        var h2 = b2[g2];
        h2 = "function" === typeof h2 ? h2.call(a2, e2, c2, d2) : h2;
        null != h2 && (f2 ? (f2 = false, e2 = B2({}, e2, h2)) : B2(e2, h2));
      }
      a2.state = e2;
    }
    else e2.queue = null;
  }
  var fb = { id: 1, overflow: "" };
  function gb(a2, b2, c2) {
    var d2 = a2.id;
    a2 = a2.overflow;
    var f2 = 32 - H2(d2) - 1;
    d2 &= ~(1 << f2);
    c2 += 1;
    var e2 = 32 - H2(b2) + f2;
    if (30 < e2) {
      var g2 = f2 - f2 % 5;
      e2 = (d2 & (1 << g2) - 1).toString(32);
      d2 >>= g2;
      f2 -= g2;
      return { id: 1 << 32 - H2(b2) + f2 | c2 << f2 | d2, overflow: e2 + a2 };
    }
    return { id: 1 << e2 | c2 << f2 | d2, overflow: a2 };
  }
  var H2 = Math.clz32 ? Math.clz32 : hb, ib = Math.log, jb = Math.LN2;
  function hb(a2) {
    a2 >>>= 0;
    return 0 === a2 ? 32 : 31 - (ib(a2) / jb | 0) | 0;
  }
  function kb(a2, b2) {
    return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
  }
  var lb = "function" === typeof Object.is ? Object.is : kb, I2 = null, ob = null, J2 = null, K2 = null, L2 = false, M2 = false, N2 = 0, O2 = null, P2 = 0;
  function Q2() {
    if (null === I2) throw Error(l2(321));
    return I2;
  }
  function pb() {
    if (0 < P2) throw Error(l2(312));
    return { memoizedState: null, queue: null, next: null };
  }
  function qb() {
    null === K2 ? null === J2 ? (L2 = false, J2 = K2 = pb()) : (L2 = true, K2 = J2) : null === K2.next ? (L2 = false, K2 = K2.next = pb()) : (L2 = true, K2 = K2.next);
    return K2;
  }
  function rb() {
    ob = I2 = null;
    M2 = false;
    J2 = null;
    P2 = 0;
    K2 = O2 = null;
  }
  function sb(a2, b2) {
    return "function" === typeof b2 ? b2(a2) : b2;
  }
  function tb(a2, b2, c2) {
    I2 = Q2();
    K2 = qb();
    if (L2) {
      var d2 = K2.queue;
      b2 = d2.dispatch;
      if (null !== O2 && (c2 = O2.get(d2), void 0 !== c2)) {
        O2.delete(d2);
        d2 = K2.memoizedState;
        do
          d2 = a2(d2, c2.action), c2 = c2.next;
        while (null !== c2);
        K2.memoizedState = d2;
        return [d2, b2];
      }
      return [K2.memoizedState, b2];
    }
    a2 = a2 === sb ? "function" === typeof b2 ? b2() : b2 : void 0 !== c2 ? c2(b2) : b2;
    K2.memoizedState = a2;
    a2 = K2.queue = { last: null, dispatch: null };
    a2 = a2.dispatch = ub.bind(null, I2, a2);
    return [K2.memoizedState, a2];
  }
  function vb(a2, b2) {
    I2 = Q2();
    K2 = qb();
    b2 = void 0 === b2 ? null : b2;
    if (null !== K2) {
      var c2 = K2.memoizedState;
      if (null !== c2 && null !== b2) {
        var d2 = c2[1];
        a: if (null === d2) d2 = false;
        else {
          for (var f2 = 0; f2 < d2.length && f2 < b2.length; f2++) if (!lb(b2[f2], d2[f2])) {
            d2 = false;
            break a;
          }
          d2 = true;
        }
        if (d2) return c2[0];
      }
    }
    a2 = a2();
    K2.memoizedState = [a2, b2];
    return a2;
  }
  function ub(a2, b2, c2) {
    if (25 <= P2) throw Error(l2(301));
    if (a2 === I2) if (M2 = true, a2 = { action: c2, next: null }, null === O2 && (O2 = /* @__PURE__ */ new Map()), c2 = O2.get(b2), void 0 === c2) O2.set(b2, a2);
    else {
      for (b2 = c2; null !== b2.next; ) b2 = b2.next;
      b2.next = a2;
    }
  }
  function wb() {
    throw Error(l2(394));
  }
  function R2() {
  }
  var xb = { readContext: function(a2) {
    return a2._currentValue2;
  }, useContext: function(a2) {
    Q2();
    return a2._currentValue2;
  }, useMemo: vb, useReducer: tb, useRef: function(a2) {
    I2 = Q2();
    K2 = qb();
    var b2 = K2.memoizedState;
    return null === b2 ? (a2 = { current: a2 }, K2.memoizedState = a2) : b2;
  }, useState: function(a2) {
    return tb(sb, a2);
  }, useInsertionEffect: R2, useLayoutEffect: function() {
  }, useCallback: function(a2, b2) {
    return vb(function() {
      return a2;
    }, b2);
  }, useImperativeHandle: R2, useEffect: R2, useDebugValue: R2, useDeferredValue: function(a2) {
    Q2();
    return a2;
  }, useTransition: function() {
    Q2();
    return [
      false,
      wb
    ];
  }, useId: function() {
    var a2 = ob.treeContext;
    var b2 = a2.overflow;
    a2 = a2.id;
    a2 = (a2 & ~(1 << 32 - H2(a2) - 1)).toString(32) + b2;
    var c2 = S2;
    if (null === c2) throw Error(l2(404));
    b2 = N2++;
    a2 = ":" + c2.idPrefix + "R" + a2;
    0 < b2 && (a2 += "H" + b2.toString(32));
    return a2 + ":";
  }, useMutableSource: function(a2, b2) {
    Q2();
    return b2(a2._source);
  }, useSyncExternalStore: function(a2, b2, c2) {
    if (void 0 === c2) throw Error(l2(407));
    return c2();
  } }, S2 = null, yb = aa2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
  function zb(a2) {
    console.error(a2);
    return null;
  }
  function T2() {
  }
  function Ab(a2, b2, c2, d2, f2, e2, g2, h2, k2) {
    var m2 = [], n2 = /* @__PURE__ */ new Set();
    b2 = { destination: null, responseState: b2, progressiveChunkSize: void 0 === d2 ? 12800 : d2, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: n2, pingedTasks: m2, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: void 0 === f2 ? zb : f2, onAllReady: T2, onShellReady: void 0 === g2 ? T2 : g2, onShellError: T2, onFatalError: T2 };
    c2 = U2(b2, 0, null, c2, false, false);
    c2.parentFlushed = true;
    a2 = Bb(b2, a2, null, c2, n2, Ya, null, fb);
    m2.push(a2);
    return b2;
  }
  function Bb(a2, b2, c2, d2, f2, e2, g2, h2) {
    a2.allPendingTasks++;
    null === c2 ? a2.pendingRootTasks++ : c2.pendingTasks++;
    var k2 = { node: b2, ping: function() {
      var b3 = a2.pingedTasks;
      b3.push(k2);
      1 === b3.length && Cb(a2);
    }, blockedBoundary: c2, blockedSegment: d2, abortSet: f2, legacyContext: e2, context: g2, treeContext: h2 };
    f2.add(k2);
    return k2;
  }
  function U2(a2, b2, c2, d2, f2, e2) {
    return { status: 0, id: -1, index: b2, parentFlushed: false, chunks: [], children: [], formatContext: d2, boundary: c2, lastPushedText: f2, textEmbedded: e2 };
  }
  function V3(a2, b2) {
    a2 = a2.onError(b2);
    if (null != a2 && "string" !== typeof a2) throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof a2 + '" instead');
    return a2;
  }
  function W2(a2, b2) {
    var c2 = a2.onShellError;
    c2(b2);
    c2 = a2.onFatalError;
    c2(b2);
    null !== a2.destination ? (a2.status = 2, a2.destination.destroy(b2)) : (a2.status = 1, a2.fatalError = b2);
  }
  function Db(a2, b2, c2, d2, f2) {
    I2 = {};
    ob = b2;
    N2 = 0;
    for (a2 = c2(d2, f2); M2; ) M2 = false, N2 = 0, P2 += 1, K2 = null, a2 = c2(d2, f2);
    rb();
    return a2;
  }
  function Eb(a2, b2, c2, d2) {
    var f2 = c2.render(), e2 = d2.childContextTypes;
    if (null !== e2 && void 0 !== e2) {
      var g2 = b2.legacyContext;
      if ("function" !== typeof c2.getChildContext) d2 = g2;
      else {
        c2 = c2.getChildContext();
        for (var h2 in c2) if (!(h2 in e2)) throw Error(l2(108, Xa(d2) || "Unknown", h2));
        d2 = B2({}, g2, c2);
      }
      b2.legacyContext = d2;
      X2(a2, b2, f2);
      b2.legacyContext = g2;
    } else X2(a2, b2, f2);
  }
  function Fb(a2, b2) {
    if (a2 && a2.defaultProps) {
      b2 = B2({}, b2);
      a2 = a2.defaultProps;
      for (var c2 in a2) void 0 === b2[c2] && (b2[c2] = a2[c2]);
      return b2;
    }
    return b2;
  }
  function Gb(a2, b2, c2, d2, f2) {
    if ("function" === typeof c2) if (c2.prototype && c2.prototype.isReactComponent) {
      f2 = Za(c2, b2.legacyContext);
      var e2 = c2.contextType;
      e2 = new c2(d2, "object" === typeof e2 && null !== e2 ? e2._currentValue2 : f2);
      eb(e2, c2, d2, f2);
      Eb(a2, b2, e2, c2);
    } else {
      e2 = Za(c2, b2.legacyContext);
      f2 = Db(a2, b2, c2, d2, e2);
      var g2 = 0 !== N2;
      if ("object" === typeof f2 && null !== f2 && "function" === typeof f2.render && void 0 === f2.$$typeof) eb(f2, c2, d2, e2), Eb(a2, b2, f2, c2);
      else if (g2) {
        d2 = b2.treeContext;
        b2.treeContext = gb(d2, 1, 0);
        try {
          X2(a2, b2, f2);
        } finally {
          b2.treeContext = d2;
        }
      } else X2(a2, b2, f2);
    }
    else if ("string" === typeof c2) {
      f2 = b2.blockedSegment;
      e2 = ya(f2.chunks, c2, d2, a2.responseState, f2.formatContext);
      f2.lastPushedText = false;
      g2 = f2.formatContext;
      f2.formatContext = ra2(g2, c2, d2);
      Hb(a2, b2, e2);
      f2.formatContext = g2;
      switch (c2) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          f2.chunks.push("</", c2, ">");
      }
      f2.lastPushedText = false;
    } else {
      switch (c2) {
        case Ua:
        case Ta:
        case Ja:
        case Ka:
        case Ia:
          X2(a2, b2, d2.children);
          return;
        case Pa:
          X2(a2, b2, d2.children);
          return;
        case Sa:
          throw Error(l2(343));
        case Oa:
          a: {
            c2 = b2.blockedBoundary;
            f2 = b2.blockedSegment;
            e2 = d2.fallback;
            d2 = d2.children;
            g2 = /* @__PURE__ */ new Set();
            var h2 = { id: null, rootSegmentID: -1, parentFlushed: false, pendingTasks: 0, forceClientRender: false, completedSegments: [], byteSize: 0, fallbackAbortableTasks: g2, errorDigest: null }, k2 = U2(a2, f2.chunks.length, h2, f2.formatContext, false, false);
            f2.children.push(k2);
            f2.lastPushedText = false;
            var m2 = U2(a2, 0, null, f2.formatContext, false, false);
            m2.parentFlushed = true;
            b2.blockedBoundary = h2;
            b2.blockedSegment = m2;
            try {
              if (Hb(
                a2,
                b2,
                d2
              ), a2.responseState.generateStaticMarkup || m2.lastPushedText && m2.textEmbedded && m2.chunks.push("<!-- -->"), m2.status = 1, Y2(h2, m2), 0 === h2.pendingTasks) break a;
            } catch (n2) {
              m2.status = 4, h2.forceClientRender = true, h2.errorDigest = V3(a2, n2);
            } finally {
              b2.blockedBoundary = c2, b2.blockedSegment = f2;
            }
            b2 = Bb(a2, e2, c2, k2, g2, b2.legacyContext, b2.context, b2.treeContext);
            a2.pingedTasks.push(b2);
          }
          return;
      }
      if ("object" === typeof c2 && null !== c2) switch (c2.$$typeof) {
        case Na:
          d2 = Db(a2, b2, c2.render, d2, f2);
          if (0 !== N2) {
            c2 = b2.treeContext;
            b2.treeContext = gb(c2, 1, 0);
            try {
              X2(a2, b2, d2);
            } finally {
              b2.treeContext = c2;
            }
          } else X2(a2, b2, d2);
          return;
        case Qa:
          c2 = c2.type;
          d2 = Fb(c2, d2);
          Gb(a2, b2, c2, d2, f2);
          return;
        case La:
          f2 = d2.children;
          c2 = c2._context;
          d2 = d2.value;
          e2 = c2._currentValue2;
          c2._currentValue2 = d2;
          g2 = E2;
          E2 = d2 = { parent: g2, depth: null === g2 ? 0 : g2.depth + 1, context: c2, parentValue: e2, value: d2 };
          b2.context = d2;
          X2(a2, b2, f2);
          a2 = E2;
          if (null === a2) throw Error(l2(403));
          d2 = a2.parentValue;
          a2.context._currentValue2 = d2 === Va ? a2.context._defaultValue : d2;
          a2 = E2 = a2.parent;
          b2.context = a2;
          return;
        case Ma:
          d2 = d2.children;
          d2 = d2(c2._currentValue2);
          X2(a2, b2, d2);
          return;
        case Ra:
          f2 = c2._init;
          c2 = f2(c2._payload);
          d2 = Fb(c2, d2);
          Gb(
            a2,
            b2,
            c2,
            d2,
            void 0
          );
          return;
      }
      throw Error(l2(130, null == c2 ? c2 : typeof c2, ""));
    }
  }
  function X2(a2, b2, c2) {
    b2.node = c2;
    if ("object" === typeof c2 && null !== c2) {
      switch (c2.$$typeof) {
        case Ga:
          Gb(a2, b2, c2.type, c2.props, c2.ref);
          return;
        case Ha:
          throw Error(l2(257));
        case Ra:
          var d2 = c2._init;
          c2 = d2(c2._payload);
          X2(a2, b2, c2);
          return;
      }
      if (qa(c2)) {
        Ib(a2, b2, c2);
        return;
      }
      null === c2 || "object" !== typeof c2 ? d2 = null : (d2 = Wa && c2[Wa] || c2["@@iterator"], d2 = "function" === typeof d2 ? d2 : null);
      if (d2 && (d2 = d2.call(c2))) {
        c2 = d2.next();
        if (!c2.done) {
          var f2 = [];
          do
            f2.push(c2.value), c2 = d2.next();
          while (!c2.done);
          Ib(a2, b2, f2);
        }
        return;
      }
      a2 = Object.prototype.toString.call(c2);
      throw Error(l2(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(c2).join(", ") + "}" : a2));
    }
    "string" === typeof c2 ? (d2 = b2.blockedSegment, d2.lastPushedText = Fa(b2.blockedSegment.chunks, c2, a2.responseState, d2.lastPushedText)) : "number" === typeof c2 && (d2 = b2.blockedSegment, d2.lastPushedText = Fa(b2.blockedSegment.chunks, "" + c2, a2.responseState, d2.lastPushedText));
  }
  function Ib(a2, b2, c2) {
    for (var d2 = c2.length, f2 = 0; f2 < d2; f2++) {
      var e2 = b2.treeContext;
      b2.treeContext = gb(e2, d2, f2);
      try {
        Hb(a2, b2, c2[f2]);
      } finally {
        b2.treeContext = e2;
      }
    }
  }
  function Hb(a2, b2, c2) {
    var d2 = b2.blockedSegment.formatContext, f2 = b2.legacyContext, e2 = b2.context;
    try {
      return X2(a2, b2, c2);
    } catch (k2) {
      if (rb(), "object" === typeof k2 && null !== k2 && "function" === typeof k2.then) {
        c2 = k2;
        var g2 = b2.blockedSegment, h2 = U2(a2, g2.chunks.length, null, g2.formatContext, g2.lastPushedText, true);
        g2.children.push(h2);
        g2.lastPushedText = false;
        a2 = Bb(a2, b2.node, b2.blockedBoundary, h2, b2.abortSet, b2.legacyContext, b2.context, b2.treeContext).ping;
        c2.then(a2, a2);
        b2.blockedSegment.formatContext = d2;
        b2.legacyContext = f2;
        b2.context = e2;
        G2(e2);
      } else throw b2.blockedSegment.formatContext = d2, b2.legacyContext = f2, b2.context = e2, G2(e2), k2;
    }
  }
  function Jb(a2) {
    var b2 = a2.blockedBoundary;
    a2 = a2.blockedSegment;
    a2.status = 3;
    Kb(this, b2, a2);
  }
  function Lb(a2, b2, c2) {
    var d2 = a2.blockedBoundary;
    a2.blockedSegment.status = 3;
    null === d2 ? (b2.allPendingTasks--, 2 !== b2.status && (b2.status = 2, null !== b2.destination && b2.destination.push(null))) : (d2.pendingTasks--, d2.forceClientRender || (d2.forceClientRender = true, a2 = void 0 === c2 ? Error(l2(432)) : c2, d2.errorDigest = b2.onError(a2), d2.parentFlushed && b2.clientRenderedBoundaries.push(d2)), d2.fallbackAbortableTasks.forEach(function(a3) {
      return Lb(a3, b2, c2);
    }), d2.fallbackAbortableTasks.clear(), b2.allPendingTasks--, 0 === b2.allPendingTasks && (d2 = b2.onAllReady, d2()));
  }
  function Y2(a2, b2) {
    if (0 === b2.chunks.length && 1 === b2.children.length && null === b2.children[0].boundary) {
      var c2 = b2.children[0];
      c2.id = b2.id;
      c2.parentFlushed = true;
      1 === c2.status && Y2(a2, c2);
    } else a2.completedSegments.push(b2);
  }
  function Kb(a2, b2, c2) {
    if (null === b2) {
      if (c2.parentFlushed) {
        if (null !== a2.completedRootSegment) throw Error(l2(389));
        a2.completedRootSegment = c2;
      }
      a2.pendingRootTasks--;
      0 === a2.pendingRootTasks && (a2.onShellError = T2, b2 = a2.onShellReady, b2());
    } else b2.pendingTasks--, b2.forceClientRender || (0 === b2.pendingTasks ? (c2.parentFlushed && 1 === c2.status && Y2(b2, c2), b2.parentFlushed && a2.completedBoundaries.push(b2), b2.fallbackAbortableTasks.forEach(Jb, a2), b2.fallbackAbortableTasks.clear()) : c2.parentFlushed && 1 === c2.status && (Y2(b2, c2), 1 === b2.completedSegments.length && b2.parentFlushed && a2.partialBoundaries.push(b2)));
    a2.allPendingTasks--;
    0 === a2.allPendingTasks && (a2 = a2.onAllReady, a2());
  }
  function Cb(a2) {
    if (2 !== a2.status) {
      var b2 = E2, c2 = yb.current;
      yb.current = xb;
      var d2 = S2;
      S2 = a2.responseState;
      try {
        var f2 = a2.pingedTasks, e2;
        for (e2 = 0; e2 < f2.length; e2++) {
          var g2 = f2[e2];
          var h2 = a2, k2 = g2.blockedSegment;
          if (0 === k2.status) {
            G2(g2.context);
            try {
              X2(h2, g2, g2.node), h2.responseState.generateStaticMarkup || k2.lastPushedText && k2.textEmbedded && k2.chunks.push("<!-- -->"), g2.abortSet.delete(g2), k2.status = 1, Kb(h2, g2.blockedBoundary, k2);
            } catch (z2) {
              if (rb(), "object" === typeof z2 && null !== z2 && "function" === typeof z2.then) {
                var m2 = g2.ping;
                z2.then(m2, m2);
              } else {
                g2.abortSet.delete(g2);
                k2.status = 4;
                var n2 = g2.blockedBoundary, q2 = z2, C2 = V3(h2, q2);
                null === n2 ? W2(h2, q2) : (n2.pendingTasks--, n2.forceClientRender || (n2.forceClientRender = true, n2.errorDigest = C2, n2.parentFlushed && h2.clientRenderedBoundaries.push(n2)));
                h2.allPendingTasks--;
                if (0 === h2.allPendingTasks) {
                  var D2 = h2.onAllReady;
                  D2();
                }
              }
            } finally {
            }
          }
        }
        f2.splice(0, e2);
        null !== a2.destination && Mb(a2, a2.destination);
      } catch (z2) {
        V3(a2, z2), W2(a2, z2);
      } finally {
        S2 = d2, yb.current = c2, c2 === xb && G2(b2);
      }
    }
  }
  function Z2(a2, b2, c2) {
    c2.parentFlushed = true;
    switch (c2.status) {
      case 0:
        var d2 = c2.id = a2.nextSegmentId++;
        c2.lastPushedText = false;
        c2.textEmbedded = false;
        a2 = a2.responseState;
        b2.push('<template id="');
        b2.push(a2.placeholderPrefix);
        a2 = d2.toString(16);
        b2.push(a2);
        return b2.push('"></template>');
      case 1:
        c2.status = 2;
        var f2 = true;
        d2 = c2.chunks;
        var e2 = 0;
        c2 = c2.children;
        for (var g2 = 0; g2 < c2.length; g2++) {
          for (f2 = c2[g2]; e2 < f2.index; e2++) b2.push(d2[e2]);
          f2 = Nb(a2, b2, f2);
        }
        for (; e2 < d2.length - 1; e2++) b2.push(d2[e2]);
        e2 < d2.length && (f2 = b2.push(d2[e2]));
        return f2;
      default:
        throw Error(l2(390));
    }
  }
  function Nb(a2, b2, c2) {
    var d2 = c2.boundary;
    if (null === d2) return Z2(a2, b2, c2);
    d2.parentFlushed = true;
    if (d2.forceClientRender) return a2.responseState.generateStaticMarkup || (d2 = d2.errorDigest, b2.push("<!--$!-->"), b2.push("<template"), d2 && (b2.push(' data-dgst="'), d2 = v2(d2), b2.push(d2), b2.push('"')), b2.push("></template>")), Z2(a2, b2, c2), a2 = a2.responseState.generateStaticMarkup ? true : b2.push("<!--/$-->"), a2;
    if (0 < d2.pendingTasks) {
      d2.rootSegmentID = a2.nextSegmentId++;
      0 < d2.completedSegments.length && a2.partialBoundaries.push(d2);
      var f2 = a2.responseState;
      var e2 = f2.nextSuspenseID++;
      f2 = f2.boundaryPrefix + e2.toString(16);
      d2 = d2.id = f2;
      za(b2, a2.responseState, d2);
      Z2(a2, b2, c2);
      return b2.push("<!--/$-->");
    }
    if (d2.byteSize > a2.progressiveChunkSize) return d2.rootSegmentID = a2.nextSegmentId++, a2.completedBoundaries.push(d2), za(b2, a2.responseState, d2.id), Z2(a2, b2, c2), b2.push("<!--/$-->");
    a2.responseState.generateStaticMarkup || b2.push("<!--$-->");
    c2 = d2.completedSegments;
    if (1 !== c2.length) throw Error(l2(391));
    Nb(a2, b2, c2[0]);
    a2 = a2.responseState.generateStaticMarkup ? true : b2.push("<!--/$-->");
    return a2;
  }
  function Ob(a2, b2, c2) {
    Aa(b2, a2.responseState, c2.formatContext, c2.id);
    Nb(a2, b2, c2);
    return Ba(b2, c2.formatContext);
  }
  function Pb(a2, b2, c2) {
    for (var d2 = c2.completedSegments, f2 = 0; f2 < d2.length; f2++) Qb(a2, b2, c2, d2[f2]);
    d2.length = 0;
    a2 = a2.responseState;
    d2 = c2.id;
    c2 = c2.rootSegmentID;
    b2.push(a2.startInlineScript);
    a2.sentCompleteBoundaryFunction ? b2.push('$RC("') : (a2.sentCompleteBoundaryFunction = true, b2.push('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("'));
    if (null === d2) throw Error(l2(395));
    c2 = c2.toString(16);
    b2.push(d2);
    b2.push('","');
    b2.push(a2.segmentPrefix);
    b2.push(c2);
    return b2.push('")<\/script>');
  }
  function Qb(a2, b2, c2, d2) {
    if (2 === d2.status) return true;
    var f2 = d2.id;
    if (-1 === f2) {
      if (-1 === (d2.id = c2.rootSegmentID)) throw Error(l2(392));
      return Ob(a2, b2, d2);
    }
    Ob(a2, b2, d2);
    a2 = a2.responseState;
    b2.push(a2.startInlineScript);
    a2.sentCompleteSegmentFunction ? b2.push('$RS("') : (a2.sentCompleteSegmentFunction = true, b2.push('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'));
    b2.push(a2.segmentPrefix);
    f2 = f2.toString(16);
    b2.push(f2);
    b2.push('","');
    b2.push(a2.placeholderPrefix);
    b2.push(f2);
    return b2.push('")<\/script>');
  }
  function Mb(a2, b2) {
    try {
      var c2 = a2.completedRootSegment;
      if (null !== c2 && 0 === a2.pendingRootTasks) {
        Nb(a2, b2, c2);
        a2.completedRootSegment = null;
        var d2 = a2.responseState.bootstrapChunks;
        for (c2 = 0; c2 < d2.length - 1; c2++) b2.push(d2[c2]);
        c2 < d2.length && b2.push(d2[c2]);
      }
      var f2 = a2.clientRenderedBoundaries, e2;
      for (e2 = 0; e2 < f2.length; e2++) {
        var g2 = f2[e2];
        d2 = b2;
        var h2 = a2.responseState, k2 = g2.id, m2 = g2.errorDigest, n2 = g2.errorMessage, q2 = g2.errorComponentStack;
        d2.push(h2.startInlineScript);
        h2.sentClientRenderFunction ? d2.push('$RX("') : (h2.sentClientRenderFunction = true, d2.push('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("'));
        if (null === k2) throw Error(l2(395));
        d2.push(k2);
        d2.push('"');
        if (m2 || n2 || q2) {
          d2.push(",");
          var C2 = Da(m2 || "");
          d2.push(C2);
        }
        if (n2 || q2) {
          d2.push(",");
          var D2 = Da(n2 || "");
          d2.push(D2);
        }
        if (q2) {
          d2.push(",");
          var z2 = Da(q2);
          d2.push(z2);
        }
        if (!d2.push(")<\/script>")) {
          a2.destination = null;
          e2++;
          f2.splice(0, e2);
          return;
        }
      }
      f2.splice(0, e2);
      var ba = a2.completedBoundaries;
      for (e2 = 0; e2 < ba.length; e2++) if (!Pb(a2, b2, ba[e2])) {
        a2.destination = null;
        e2++;
        ba.splice(0, e2);
        return;
      }
      ba.splice(0, e2);
      var ca = a2.partialBoundaries;
      for (e2 = 0; e2 < ca.length; e2++) {
        var mb = ca[e2];
        a: {
          f2 = a2;
          g2 = b2;
          var da = mb.completedSegments;
          for (h2 = 0; h2 < da.length; h2++) if (!Qb(f2, g2, mb, da[h2])) {
            h2++;
            da.splice(0, h2);
            var nb = false;
            break a;
          }
          da.splice(0, h2);
          nb = true;
        }
        if (!nb) {
          a2.destination = null;
          e2++;
          ca.splice(0, e2);
          return;
        }
      }
      ca.splice(0, e2);
      var ea2 = a2.completedBoundaries;
      for (e2 = 0; e2 < ea2.length; e2++) if (!Pb(a2, b2, ea2[e2])) {
        a2.destination = null;
        e2++;
        ea2.splice(0, e2);
        return;
      }
      ea2.splice(0, e2);
    } finally {
      0 === a2.allPendingTasks && 0 === a2.pingedTasks.length && 0 === a2.clientRenderedBoundaries.length && 0 === a2.completedBoundaries.length && b2.push(null);
    }
  }
  function Rb(a2, b2) {
    try {
      var c2 = a2.abortableTasks;
      c2.forEach(function(c3) {
        return Lb(c3, a2, b2);
      });
      c2.clear();
      null !== a2.destination && Mb(a2, a2.destination);
    } catch (d2) {
      V3(a2, d2), W2(a2, d2);
    }
  }
  function Sb() {
  }
  function Tb(a2, b2, c2, d2) {
    var f2 = false, e2 = null, g2 = "", h2 = { push: function(a3) {
      null !== a3 && (g2 += a3);
      return true;
    }, destroy: function(a3) {
      f2 = true;
      e2 = a3;
    } }, k2 = false;
    a2 = Ab(a2, Ea(c2, b2 ? b2.identifierPrefix : void 0), { insertionMode: 1, selectedValue: null }, Infinity, Sb, void 0, function() {
      k2 = true;
    });
    Cb(a2);
    Rb(a2, d2);
    if (1 === a2.status) a2.status = 2, h2.destroy(a2.fatalError);
    else if (2 !== a2.status && null === a2.destination) {
      a2.destination = h2;
      try {
        Mb(a2, h2);
      } catch (m2) {
        V3(a2, m2), W2(a2, m2);
      }
    }
    if (f2) throw e2;
    if (!k2) throw Error(l2(426));
    return g2;
  }
  reactDomServerLegacy_browser_production_min.renderToNodeStream = function() {
    throw Error(l2(207));
  };
  reactDomServerLegacy_browser_production_min.renderToStaticMarkup = function(a2, b2) {
    return Tb(a2, b2, true, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
  };
  reactDomServerLegacy_browser_production_min.renderToStaticNodeStream = function() {
    throw Error(l2(208));
  };
  reactDomServerLegacy_browser_production_min.renderToString = function(a2, b2) {
    return Tb(a2, b2, false, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
  };
  reactDomServerLegacy_browser_production_min.version = "18.3.1";
  return reactDomServerLegacy_browser_production_min;
}
var reactDomServer_browser_production_min = {};
/**
 * @license React
 * react-dom-server.browser.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDomServer_browser_production_min;
function requireReactDomServer_browser_production_min() {
  if (hasRequiredReactDomServer_browser_production_min) return reactDomServer_browser_production_min;
  hasRequiredReactDomServer_browser_production_min = 1;
  var aa2 = requireReact();
  function k2(a2) {
    for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++) b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
    return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var l2 = null, n2 = 0;
  function p2(a2, b2) {
    if (0 !== b2.length) if (512 < b2.length) 0 < n2 && (a2.enqueue(new Uint8Array(l2.buffer, 0, n2)), l2 = new Uint8Array(512), n2 = 0), a2.enqueue(b2);
    else {
      var c2 = l2.length - n2;
      c2 < b2.length && (0 === c2 ? a2.enqueue(l2) : (l2.set(b2.subarray(0, c2), n2), a2.enqueue(l2), b2 = b2.subarray(c2)), l2 = new Uint8Array(512), n2 = 0);
      l2.set(b2, n2);
      n2 += b2.length;
    }
  }
  function t2(a2, b2) {
    p2(a2, b2);
    return true;
  }
  function ba(a2) {
    l2 && 0 < n2 && (a2.enqueue(new Uint8Array(l2.buffer, 0, n2)), l2 = null, n2 = 0);
  }
  var ca = new TextEncoder();
  function u2(a2) {
    return ca.encode(a2);
  }
  function w2(a2) {
    return ca.encode(a2);
  }
  function da(a2, b2) {
    "function" === typeof a2.error ? a2.error(b2) : a2.close();
  }
  var x2 = Object.prototype.hasOwnProperty, ea2 = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, fa = {}, ha2 = {};
  function ia2(a2) {
    if (x2.call(ha2, a2)) return true;
    if (x2.call(fa, a2)) return false;
    if (ea2.test(a2)) return ha2[a2] = true;
    fa[a2] = true;
    return false;
  }
  function y2(a2, b2, c2, d2, f2, e2, g2) {
    this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
    this.attributeName = d2;
    this.attributeNamespace = f2;
    this.mustUseProperty = c2;
    this.propertyName = a2;
    this.type = b2;
    this.sanitizeURL = e2;
    this.removeEmptyString = g2;
  }
  var z2 = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
    z2[a2] = new y2(a2, 0, false, a2, null, false, false);
  });
  [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
    var b2 = a2[0];
    z2[b2] = new y2(b2, 1, false, a2[1], null, false, false);
  });
  ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
    z2[a2] = new y2(a2, 2, false, a2.toLowerCase(), null, false, false);
  });
  ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
    z2[a2] = new y2(a2, 2, false, a2, null, false, false);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
    z2[a2] = new y2(a2, 3, false, a2.toLowerCase(), null, false, false);
  });
  ["checked", "multiple", "muted", "selected"].forEach(function(a2) {
    z2[a2] = new y2(a2, 3, true, a2, null, false, false);
  });
  ["capture", "download"].forEach(function(a2) {
    z2[a2] = new y2(a2, 4, false, a2, null, false, false);
  });
  ["cols", "rows", "size", "span"].forEach(function(a2) {
    z2[a2] = new y2(a2, 6, false, a2, null, false, false);
  });
  ["rowSpan", "start"].forEach(function(a2) {
    z2[a2] = new y2(a2, 5, false, a2.toLowerCase(), null, false, false);
  });
  var ja = /[\-:]([a-z])/g;
  function ka(a2) {
    return a2[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
    var b2 = a2.replace(
      ja,
      ka
    );
    z2[b2] = new y2(b2, 1, false, a2, null, false, false);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
    var b2 = a2.replace(ja, ka);
    z2[b2] = new y2(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
  });
  ["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
    var b2 = a2.replace(ja, ka);
    z2[b2] = new y2(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
  });
  ["tabIndex", "crossOrigin"].forEach(function(a2) {
    z2[a2] = new y2(a2, 1, false, a2.toLowerCase(), null, false, false);
  });
  z2.xlinkHref = new y2("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
  ["src", "href", "action", "formAction"].forEach(function(a2) {
    z2[a2] = new y2(a2, 1, false, a2.toLowerCase(), null, true, true);
  });
  var B2 = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridArea: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  }, la2 = ["Webkit", "ms", "Moz", "O"];
  Object.keys(B2).forEach(function(a2) {
    la2.forEach(function(b2) {
      b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
      B2[b2] = B2[a2];
    });
  });
  var oa2 = /["'&<>]/;
  function C2(a2) {
    if ("boolean" === typeof a2 || "number" === typeof a2) return "" + a2;
    a2 = "" + a2;
    var b2 = oa2.exec(a2);
    if (b2) {
      var c2 = "", d2, f2 = 0;
      for (d2 = b2.index; d2 < a2.length; d2++) {
        switch (a2.charCodeAt(d2)) {
          case 34:
            b2 = "&quot;";
            break;
          case 38:
            b2 = "&amp;";
            break;
          case 39:
            b2 = "&#x27;";
            break;
          case 60:
            b2 = "&lt;";
            break;
          case 62:
            b2 = "&gt;";
            break;
          default:
            continue;
        }
        f2 !== d2 && (c2 += a2.substring(f2, d2));
        f2 = d2 + 1;
        c2 += b2;
      }
      a2 = f2 !== d2 ? c2 + a2.substring(f2, d2) : c2;
    }
    return a2;
  }
  var pa = /([A-Z])/g, qa = /^ms-/, ra2 = Array.isArray, sa2 = w2("<script>"), ta2 = w2("<\/script>"), ua2 = w2('<script src="'), va = w2('<script type="module" src="'), wa = w2('" async=""><\/script>'), xa = /(<\/|<)(s)(cript)/gi;
  function ya(a2, b2, c2, d2) {
    return "" + b2 + ("s" === c2 ? "\\u0073" : "\\u0053") + d2;
  }
  function za(a2, b2, c2, d2, f2) {
    a2 = void 0 === a2 ? "" : a2;
    b2 = void 0 === b2 ? sa2 : w2('<script nonce="' + C2(b2) + '">');
    var e2 = [];
    void 0 !== c2 && e2.push(b2, u2(("" + c2).replace(xa, ya)), ta2);
    if (void 0 !== d2) for (c2 = 0; c2 < d2.length; c2++) e2.push(ua2, u2(C2(d2[c2])), wa);
    if (void 0 !== f2) for (d2 = 0; d2 < f2.length; d2++) e2.push(va, u2(C2(f2[d2])), wa);
    return { bootstrapChunks: e2, startInlineScript: b2, placeholderPrefix: w2(a2 + "P:"), segmentPrefix: w2(a2 + "S:"), boundaryPrefix: a2 + "B:", idPrefix: a2, nextSuspenseID: 0, sentCompleteSegmentFunction: false, sentCompleteBoundaryFunction: false, sentClientRenderFunction: false };
  }
  function D2(a2, b2) {
    return { insertionMode: a2, selectedValue: b2 };
  }
  function Aa(a2) {
    return D2("http://www.w3.org/2000/svg" === a2 ? 2 : "http://www.w3.org/1998/Math/MathML" === a2 ? 3 : 0, null);
  }
  function Ba(a2, b2, c2) {
    switch (b2) {
      case "select":
        return D2(1, null != c2.value ? c2.value : c2.defaultValue);
      case "svg":
        return D2(2, null);
      case "math":
        return D2(3, null);
      case "foreignObject":
        return D2(1, null);
      case "table":
        return D2(4, null);
      case "thead":
      case "tbody":
      case "tfoot":
        return D2(5, null);
      case "colgroup":
        return D2(7, null);
      case "tr":
        return D2(6, null);
    }
    return 4 <= a2.insertionMode || 0 === a2.insertionMode ? D2(1, null) : a2;
  }
  var Ca = w2("<!-- -->");
  function Da(a2, b2, c2, d2) {
    if ("" === b2) return d2;
    d2 && a2.push(Ca);
    a2.push(u2(C2(b2)));
    return true;
  }
  var Ea = /* @__PURE__ */ new Map(), Fa = w2(' style="'), Ga = w2(":"), Ha = w2(";");
  function Ia(a2, b2, c2) {
    if ("object" !== typeof c2) throw Error(k2(62));
    b2 = true;
    for (var d2 in c2) if (x2.call(c2, d2)) {
      var f2 = c2[d2];
      if (null != f2 && "boolean" !== typeof f2 && "" !== f2) {
        if (0 === d2.indexOf("--")) {
          var e2 = u2(C2(d2));
          f2 = u2(C2(("" + f2).trim()));
        } else {
          e2 = d2;
          var g2 = Ea.get(e2);
          void 0 !== g2 ? e2 = g2 : (g2 = w2(C2(e2.replace(pa, "-$1").toLowerCase().replace(qa, "-ms-"))), Ea.set(e2, g2), e2 = g2);
          f2 = "number" === typeof f2 ? 0 === f2 || x2.call(B2, d2) ? u2("" + f2) : u2(f2 + "px") : u2(C2(("" + f2).trim()));
        }
        b2 ? (b2 = false, a2.push(Fa, e2, Ga, f2)) : a2.push(Ha, e2, Ga, f2);
      }
    }
    b2 || a2.push(E2);
  }
  var H2 = w2(" "), I2 = w2('="'), E2 = w2('"'), Ja = w2('=""');
  function J2(a2, b2, c2, d2) {
    switch (c2) {
      case "style":
        Ia(a2, b2, d2);
        return;
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
        return;
    }
    if (!(2 < c2.length) || "o" !== c2[0] && "O" !== c2[0] || "n" !== c2[1] && "N" !== c2[1]) {
      if (b2 = z2.hasOwnProperty(c2) ? z2[c2] : null, null !== b2) {
        switch (typeof d2) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (!b2.acceptsBooleans) return;
        }
        c2 = u2(b2.attributeName);
        switch (b2.type) {
          case 3:
            d2 && a2.push(H2, c2, Ja);
            break;
          case 4:
            true === d2 ? a2.push(H2, c2, Ja) : false !== d2 && a2.push(H2, c2, I2, u2(C2(d2)), E2);
            break;
          case 5:
            isNaN(d2) || a2.push(H2, c2, I2, u2(C2(d2)), E2);
            break;
          case 6:
            !isNaN(d2) && 1 <= d2 && a2.push(H2, c2, I2, u2(C2(d2)), E2);
            break;
          default:
            b2.sanitizeURL && (d2 = "" + d2), a2.push(H2, c2, I2, u2(C2(d2)), E2);
        }
      } else if (ia2(c2)) {
        switch (typeof d2) {
          case "function":
          case "symbol":
            return;
          case "boolean":
            if (b2 = c2.toLowerCase().slice(0, 5), "data-" !== b2 && "aria-" !== b2) return;
        }
        a2.push(H2, u2(c2), I2, u2(C2(d2)), E2);
      }
    }
  }
  var K2 = w2(">"), Ka = w2("/>");
  function L2(a2, b2, c2) {
    if (null != b2) {
      if (null != c2) throw Error(k2(60));
      if ("object" !== typeof b2 || !("__html" in b2)) throw Error(k2(61));
      b2 = b2.__html;
      null !== b2 && void 0 !== b2 && a2.push(u2("" + b2));
    }
  }
  function La(a2) {
    var b2 = "";
    aa2.Children.forEach(a2, function(a3) {
      null != a3 && (b2 += a3);
    });
    return b2;
  }
  var Ma = w2(' selected=""');
  function Na(a2, b2, c2, d2) {
    a2.push(M2(c2));
    var f2 = c2 = null, e2;
    for (e2 in b2) if (x2.call(b2, e2)) {
      var g2 = b2[e2];
      if (null != g2) switch (e2) {
        case "children":
          c2 = g2;
          break;
        case "dangerouslySetInnerHTML":
          f2 = g2;
          break;
        default:
          J2(a2, d2, e2, g2);
      }
    }
    a2.push(K2);
    L2(a2, f2, c2);
    return "string" === typeof c2 ? (a2.push(u2(C2(c2))), null) : c2;
  }
  var Oa = w2("\n"), Pa = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/, Qa = /* @__PURE__ */ new Map();
  function M2(a2) {
    var b2 = Qa.get(a2);
    if (void 0 === b2) {
      if (!Pa.test(a2)) throw Error(k2(65, a2));
      b2 = w2("<" + a2);
      Qa.set(a2, b2);
    }
    return b2;
  }
  var Ra = w2("<!DOCTYPE html>");
  function Sa(a2, b2, c2, d2, f2) {
    switch (b2) {
      case "select":
        a2.push(M2("select"));
        var e2 = null, g2 = null;
        for (r2 in c2) if (x2.call(c2, r2)) {
          var h2 = c2[r2];
          if (null != h2) switch (r2) {
            case "children":
              e2 = h2;
              break;
            case "dangerouslySetInnerHTML":
              g2 = h2;
              break;
            case "defaultValue":
            case "value":
              break;
            default:
              J2(a2, d2, r2, h2);
          }
        }
        a2.push(K2);
        L2(a2, g2, e2);
        return e2;
      case "option":
        g2 = f2.selectedValue;
        a2.push(M2("option"));
        var m2 = h2 = null, q2 = null;
        var r2 = null;
        for (e2 in c2) if (x2.call(c2, e2)) {
          var v2 = c2[e2];
          if (null != v2) switch (e2) {
            case "children":
              h2 = v2;
              break;
            case "selected":
              q2 = v2;
              break;
            case "dangerouslySetInnerHTML":
              r2 = v2;
              break;
            case "value":
              m2 = v2;
            default:
              J2(a2, d2, e2, v2);
          }
        }
        if (null != g2) if (c2 = null !== m2 ? "" + m2 : La(h2), ra2(g2)) for (d2 = 0; d2 < g2.length; d2++) {
          if ("" + g2[d2] === c2) {
            a2.push(Ma);
            break;
          }
        }
        else "" + g2 === c2 && a2.push(Ma);
        else q2 && a2.push(Ma);
        a2.push(K2);
        L2(a2, r2, h2);
        return h2;
      case "textarea":
        a2.push(M2("textarea"));
        r2 = g2 = e2 = null;
        for (h2 in c2) if (x2.call(c2, h2) && (m2 = c2[h2], null != m2)) switch (h2) {
          case "children":
            r2 = m2;
            break;
          case "value":
            e2 = m2;
            break;
          case "defaultValue":
            g2 = m2;
            break;
          case "dangerouslySetInnerHTML":
            throw Error(k2(91));
          default:
            J2(a2, d2, h2, m2);
        }
        null === e2 && null !== g2 && (e2 = g2);
        a2.push(K2);
        if (null != r2) {
          if (null != e2) throw Error(k2(92));
          if (ra2(r2) && 1 < r2.length) throw Error(k2(93));
          e2 = "" + r2;
        }
        "string" === typeof e2 && "\n" === e2[0] && a2.push(Oa);
        null !== e2 && a2.push(u2(C2("" + e2)));
        return null;
      case "input":
        a2.push(M2("input"));
        m2 = r2 = h2 = e2 = null;
        for (g2 in c2) if (x2.call(c2, g2) && (q2 = c2[g2], null != q2)) switch (g2) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error(k2(399, "input"));
          case "defaultChecked":
            m2 = q2;
            break;
          case "defaultValue":
            h2 = q2;
            break;
          case "checked":
            r2 = q2;
            break;
          case "value":
            e2 = q2;
            break;
          default:
            J2(a2, d2, g2, q2);
        }
        null !== r2 ? J2(
          a2,
          d2,
          "checked",
          r2
        ) : null !== m2 && J2(a2, d2, "checked", m2);
        null !== e2 ? J2(a2, d2, "value", e2) : null !== h2 && J2(a2, d2, "value", h2);
        a2.push(Ka);
        return null;
      case "menuitem":
        a2.push(M2("menuitem"));
        for (var A2 in c2) if (x2.call(c2, A2) && (e2 = c2[A2], null != e2)) switch (A2) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error(k2(400));
          default:
            J2(a2, d2, A2, e2);
        }
        a2.push(K2);
        return null;
      case "title":
        a2.push(M2("title"));
        e2 = null;
        for (v2 in c2) if (x2.call(c2, v2) && (g2 = c2[v2], null != g2)) switch (v2) {
          case "children":
            e2 = g2;
            break;
          case "dangerouslySetInnerHTML":
            throw Error(k2(434));
          default:
            J2(a2, d2, v2, g2);
        }
        a2.push(K2);
        return e2;
      case "listing":
      case "pre":
        a2.push(M2(b2));
        g2 = e2 = null;
        for (m2 in c2) if (x2.call(c2, m2) && (h2 = c2[m2], null != h2)) switch (m2) {
          case "children":
            e2 = h2;
            break;
          case "dangerouslySetInnerHTML":
            g2 = h2;
            break;
          default:
            J2(a2, d2, m2, h2);
        }
        a2.push(K2);
        if (null != g2) {
          if (null != e2) throw Error(k2(60));
          if ("object" !== typeof g2 || !("__html" in g2)) throw Error(k2(61));
          c2 = g2.__html;
          null !== c2 && void 0 !== c2 && ("string" === typeof c2 && 0 < c2.length && "\n" === c2[0] ? a2.push(Oa, u2(c2)) : a2.push(u2("" + c2)));
        }
        "string" === typeof e2 && "\n" === e2[0] && a2.push(Oa);
        return e2;
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "img":
      case "keygen":
      case "link":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
        a2.push(M2(b2));
        for (var F2 in c2) if (x2.call(c2, F2) && (e2 = c2[F2], null != e2)) switch (F2) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error(k2(399, b2));
          default:
            J2(a2, d2, F2, e2);
        }
        a2.push(Ka);
        return null;
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return Na(a2, c2, b2, d2);
      case "html":
        return 0 === f2.insertionMode && a2.push(Ra), Na(a2, c2, b2, d2);
      default:
        if (-1 === b2.indexOf("-") && "string" !== typeof c2.is) return Na(a2, c2, b2, d2);
        a2.push(M2(b2));
        g2 = e2 = null;
        for (q2 in c2) if (x2.call(c2, q2) && (h2 = c2[q2], null != h2)) switch (q2) {
          case "children":
            e2 = h2;
            break;
          case "dangerouslySetInnerHTML":
            g2 = h2;
            break;
          case "style":
            Ia(a2, d2, h2);
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
            break;
          default:
            ia2(q2) && "function" !== typeof h2 && "symbol" !== typeof h2 && a2.push(H2, u2(q2), I2, u2(C2(h2)), E2);
        }
        a2.push(K2);
        L2(a2, g2, e2);
        return e2;
    }
  }
  var Ta = w2("</"), Ua = w2(">"), Va = w2('<template id="'), Wa = w2('"></template>'), Xa = w2("<!--$-->"), Ya = w2('<!--$?--><template id="'), Za = w2('"></template>'), $a = w2("<!--$!-->"), ab = w2("<!--/$-->"), bb = w2("<template"), cb = w2('"'), db = w2(' data-dgst="');
  w2(' data-msg="');
  w2(' data-stck="');
  var eb = w2("></template>");
  function fb(a2, b2, c2) {
    p2(a2, Ya);
    if (null === c2) throw Error(k2(395));
    p2(a2, c2);
    return t2(a2, Za);
  }
  var gb = w2('<div hidden id="'), hb = w2('">'), ib = w2("</div>"), jb = w2('<svg aria-hidden="true" style="display:none" id="'), kb = w2('">'), lb = w2("</svg>"), mb = w2('<math aria-hidden="true" style="display:none" id="'), nb = w2('">'), ob = w2("</math>"), pb = w2('<table hidden id="'), qb = w2('">'), rb = w2("</table>"), sb = w2('<table hidden><tbody id="'), tb = w2('">'), ub = w2("</tbody></table>"), vb = w2('<table hidden><tr id="'), wb = w2('">'), xb = w2("</tr></table>"), yb = w2('<table hidden><colgroup id="'), zb = w2('">'), Ab = w2("</colgroup></table>");
  function Bb(a2, b2, c2, d2) {
    switch (c2.insertionMode) {
      case 0:
      case 1:
        return p2(a2, gb), p2(a2, b2.segmentPrefix), p2(a2, u2(d2.toString(16))), t2(a2, hb);
      case 2:
        return p2(a2, jb), p2(a2, b2.segmentPrefix), p2(a2, u2(d2.toString(16))), t2(a2, kb);
      case 3:
        return p2(a2, mb), p2(a2, b2.segmentPrefix), p2(a2, u2(d2.toString(16))), t2(a2, nb);
      case 4:
        return p2(a2, pb), p2(a2, b2.segmentPrefix), p2(a2, u2(d2.toString(16))), t2(a2, qb);
      case 5:
        return p2(a2, sb), p2(a2, b2.segmentPrefix), p2(a2, u2(d2.toString(16))), t2(a2, tb);
      case 6:
        return p2(a2, vb), p2(a2, b2.segmentPrefix), p2(a2, u2(d2.toString(16))), t2(a2, wb);
      case 7:
        return p2(
          a2,
          yb
        ), p2(a2, b2.segmentPrefix), p2(a2, u2(d2.toString(16))), t2(a2, zb);
      default:
        throw Error(k2(397));
    }
  }
  function Cb(a2, b2) {
    switch (b2.insertionMode) {
      case 0:
      case 1:
        return t2(a2, ib);
      case 2:
        return t2(a2, lb);
      case 3:
        return t2(a2, ob);
      case 4:
        return t2(a2, rb);
      case 5:
        return t2(a2, ub);
      case 6:
        return t2(a2, xb);
      case 7:
        return t2(a2, Ab);
      default:
        throw Error(k2(397));
    }
  }
  var Db = w2('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'), Eb = w2('$RS("'), Gb = w2('","'), Hb = w2('")<\/script>'), Ib = w2('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("'), Jb = w2('$RC("'), Kb = w2('","'), Lb = w2('")<\/script>'), Mb = w2('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("'), Nb = w2('$RX("'), Ob = w2('"'), Pb = w2(")<\/script>"), Qb = w2(","), Rb = /[<\u2028\u2029]/g;
  function Sb(a2) {
    return JSON.stringify(a2).replace(Rb, function(a3) {
      switch (a3) {
        case "<":
          return "\\u003c";
        case "\u2028":
          return "\\u2028";
        case "\u2029":
          return "\\u2029";
        default:
          throw Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
      }
    });
  }
  var N2 = Object.assign, Tb = Symbol.for("react.element"), Ub = Symbol.for("react.portal"), Vb = Symbol.for("react.fragment"), Wb = Symbol.for("react.strict_mode"), Xb = Symbol.for("react.profiler"), Yb = Symbol.for("react.provider"), Zb = Symbol.for("react.context"), $b = Symbol.for("react.forward_ref"), ac = Symbol.for("react.suspense"), bc = Symbol.for("react.suspense_list"), cc = Symbol.for("react.memo"), dc = Symbol.for("react.lazy"), ec = Symbol.for("react.scope"), fc = Symbol.for("react.debug_trace_mode"), gc = Symbol.for("react.legacy_hidden"), hc = Symbol.for("react.default_value"), ic = Symbol.iterator;
  function jc(a2) {
    if (null == a2) return null;
    if ("function" === typeof a2) return a2.displayName || a2.name || null;
    if ("string" === typeof a2) return a2;
    switch (a2) {
      case Vb:
        return "Fragment";
      case Ub:
        return "Portal";
      case Xb:
        return "Profiler";
      case Wb:
        return "StrictMode";
      case ac:
        return "Suspense";
      case bc:
        return "SuspenseList";
    }
    if ("object" === typeof a2) switch (a2.$$typeof) {
      case Zb:
        return (a2.displayName || "Context") + ".Consumer";
      case Yb:
        return (a2._context.displayName || "Context") + ".Provider";
      case $b:
        var b2 = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case cc:
        return b2 = a2.displayName || null, null !== b2 ? b2 : jc(a2.type) || "Memo";
      case dc:
        b2 = a2._payload;
        a2 = a2._init;
        try {
          return jc(a2(b2));
        } catch (c2) {
        }
    }
    return null;
  }
  var kc = {};
  function lc(a2, b2) {
    a2 = a2.contextTypes;
    if (!a2) return kc;
    var c2 = {}, d2;
    for (d2 in a2) c2[d2] = b2[d2];
    return c2;
  }
  var O2 = null;
  function P2(a2, b2) {
    if (a2 !== b2) {
      a2.context._currentValue = a2.parentValue;
      a2 = a2.parent;
      var c2 = b2.parent;
      if (null === a2) {
        if (null !== c2) throw Error(k2(401));
      } else {
        if (null === c2) throw Error(k2(401));
        P2(a2, c2);
      }
      b2.context._currentValue = b2.value;
    }
  }
  function mc(a2) {
    a2.context._currentValue = a2.parentValue;
    a2 = a2.parent;
    null !== a2 && mc(a2);
  }
  function nc(a2) {
    var b2 = a2.parent;
    null !== b2 && nc(b2);
    a2.context._currentValue = a2.value;
  }
  function oc(a2, b2) {
    a2.context._currentValue = a2.parentValue;
    a2 = a2.parent;
    if (null === a2) throw Error(k2(402));
    a2.depth === b2.depth ? P2(a2, b2) : oc(a2, b2);
  }
  function pc(a2, b2) {
    var c2 = b2.parent;
    if (null === c2) throw Error(k2(402));
    a2.depth === c2.depth ? P2(a2, c2) : pc(a2, c2);
    b2.context._currentValue = b2.value;
  }
  function Q2(a2) {
    var b2 = O2;
    b2 !== a2 && (null === b2 ? nc(a2) : null === a2 ? mc(b2) : b2.depth === a2.depth ? P2(b2, a2) : b2.depth > a2.depth ? oc(b2, a2) : pc(b2, a2), O2 = a2);
  }
  var qc = { isMounted: function() {
    return false;
  }, enqueueSetState: function(a2, b2) {
    a2 = a2._reactInternals;
    null !== a2.queue && a2.queue.push(b2);
  }, enqueueReplaceState: function(a2, b2) {
    a2 = a2._reactInternals;
    a2.replace = true;
    a2.queue = [b2];
  }, enqueueForceUpdate: function() {
  } };
  function rc(a2, b2, c2, d2) {
    var f2 = void 0 !== a2.state ? a2.state : null;
    a2.updater = qc;
    a2.props = c2;
    a2.state = f2;
    var e2 = { queue: [], replace: false };
    a2._reactInternals = e2;
    var g2 = b2.contextType;
    a2.context = "object" === typeof g2 && null !== g2 ? g2._currentValue : d2;
    g2 = b2.getDerivedStateFromProps;
    "function" === typeof g2 && (g2 = g2(c2, f2), f2 = null === g2 || void 0 === g2 ? f2 : N2({}, f2, g2), a2.state = f2);
    if ("function" !== typeof b2.getDerivedStateFromProps && "function" !== typeof a2.getSnapshotBeforeUpdate && ("function" === typeof a2.UNSAFE_componentWillMount || "function" === typeof a2.componentWillMount)) if (b2 = a2.state, "function" === typeof a2.componentWillMount && a2.componentWillMount(), "function" === typeof a2.UNSAFE_componentWillMount && a2.UNSAFE_componentWillMount(), b2 !== a2.state && qc.enqueueReplaceState(a2, a2.state, null), null !== e2.queue && 0 < e2.queue.length) if (b2 = e2.queue, g2 = e2.replace, e2.queue = null, e2.replace = false, g2 && 1 === b2.length) a2.state = b2[0];
    else {
      e2 = g2 ? b2[0] : a2.state;
      f2 = true;
      for (g2 = g2 ? 1 : 0; g2 < b2.length; g2++) {
        var h2 = b2[g2];
        h2 = "function" === typeof h2 ? h2.call(a2, e2, c2, d2) : h2;
        null != h2 && (f2 ? (f2 = false, e2 = N2({}, e2, h2)) : N2(e2, h2));
      }
      a2.state = e2;
    }
    else e2.queue = null;
  }
  var sc = { id: 1, overflow: "" };
  function tc(a2, b2, c2) {
    var d2 = a2.id;
    a2 = a2.overflow;
    var f2 = 32 - uc(d2) - 1;
    d2 &= ~(1 << f2);
    c2 += 1;
    var e2 = 32 - uc(b2) + f2;
    if (30 < e2) {
      var g2 = f2 - f2 % 5;
      e2 = (d2 & (1 << g2) - 1).toString(32);
      d2 >>= g2;
      f2 -= g2;
      return { id: 1 << 32 - uc(b2) + f2 | c2 << f2 | d2, overflow: e2 + a2 };
    }
    return { id: 1 << e2 | c2 << f2 | d2, overflow: a2 };
  }
  var uc = Math.clz32 ? Math.clz32 : vc, wc = Math.log, xc = Math.LN2;
  function vc(a2) {
    a2 >>>= 0;
    return 0 === a2 ? 32 : 31 - (wc(a2) / xc | 0) | 0;
  }
  function yc(a2, b2) {
    return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
  }
  var zc = "function" === typeof Object.is ? Object.is : yc, R2 = null, Ac = null, Bc = null, S2 = null, T2 = false, Cc = false, U2 = 0, V3 = null, Dc = 0;
  function W2() {
    if (null === R2) throw Error(k2(321));
    return R2;
  }
  function Ec() {
    if (0 < Dc) throw Error(k2(312));
    return { memoizedState: null, queue: null, next: null };
  }
  function Fc() {
    null === S2 ? null === Bc ? (T2 = false, Bc = S2 = Ec()) : (T2 = true, S2 = Bc) : null === S2.next ? (T2 = false, S2 = S2.next = Ec()) : (T2 = true, S2 = S2.next);
    return S2;
  }
  function Gc() {
    Ac = R2 = null;
    Cc = false;
    Bc = null;
    Dc = 0;
    S2 = V3 = null;
  }
  function Hc(a2, b2) {
    return "function" === typeof b2 ? b2(a2) : b2;
  }
  function Ic(a2, b2, c2) {
    R2 = W2();
    S2 = Fc();
    if (T2) {
      var d2 = S2.queue;
      b2 = d2.dispatch;
      if (null !== V3 && (c2 = V3.get(d2), void 0 !== c2)) {
        V3.delete(d2);
        d2 = S2.memoizedState;
        do
          d2 = a2(d2, c2.action), c2 = c2.next;
        while (null !== c2);
        S2.memoizedState = d2;
        return [d2, b2];
      }
      return [S2.memoizedState, b2];
    }
    a2 = a2 === Hc ? "function" === typeof b2 ? b2() : b2 : void 0 !== c2 ? c2(b2) : b2;
    S2.memoizedState = a2;
    a2 = S2.queue = { last: null, dispatch: null };
    a2 = a2.dispatch = Jc.bind(null, R2, a2);
    return [S2.memoizedState, a2];
  }
  function Kc(a2, b2) {
    R2 = W2();
    S2 = Fc();
    b2 = void 0 === b2 ? null : b2;
    if (null !== S2) {
      var c2 = S2.memoizedState;
      if (null !== c2 && null !== b2) {
        var d2 = c2[1];
        a: if (null === d2) d2 = false;
        else {
          for (var f2 = 0; f2 < d2.length && f2 < b2.length; f2++) if (!zc(b2[f2], d2[f2])) {
            d2 = false;
            break a;
          }
          d2 = true;
        }
        if (d2) return c2[0];
      }
    }
    a2 = a2();
    S2.memoizedState = [a2, b2];
    return a2;
  }
  function Jc(a2, b2, c2) {
    if (25 <= Dc) throw Error(k2(301));
    if (a2 === R2) if (Cc = true, a2 = { action: c2, next: null }, null === V3 && (V3 = /* @__PURE__ */ new Map()), c2 = V3.get(b2), void 0 === c2) V3.set(b2, a2);
    else {
      for (b2 = c2; null !== b2.next; ) b2 = b2.next;
      b2.next = a2;
    }
  }
  function Lc() {
    throw Error(k2(394));
  }
  function Mc() {
  }
  var Oc = { readContext: function(a2) {
    return a2._currentValue;
  }, useContext: function(a2) {
    W2();
    return a2._currentValue;
  }, useMemo: Kc, useReducer: Ic, useRef: function(a2) {
    R2 = W2();
    S2 = Fc();
    var b2 = S2.memoizedState;
    return null === b2 ? (a2 = { current: a2 }, S2.memoizedState = a2) : b2;
  }, useState: function(a2) {
    return Ic(Hc, a2);
  }, useInsertionEffect: Mc, useLayoutEffect: function() {
  }, useCallback: function(a2, b2) {
    return Kc(function() {
      return a2;
    }, b2);
  }, useImperativeHandle: Mc, useEffect: Mc, useDebugValue: Mc, useDeferredValue: function(a2) {
    W2();
    return a2;
  }, useTransition: function() {
    W2();
    return [false, Lc];
  }, useId: function() {
    var a2 = Ac.treeContext;
    var b2 = a2.overflow;
    a2 = a2.id;
    a2 = (a2 & ~(1 << 32 - uc(a2) - 1)).toString(32) + b2;
    var c2 = Nc;
    if (null === c2) throw Error(k2(404));
    b2 = U2++;
    a2 = ":" + c2.idPrefix + "R" + a2;
    0 < b2 && (a2 += "H" + b2.toString(32));
    return a2 + ":";
  }, useMutableSource: function(a2, b2) {
    W2();
    return b2(a2._source);
  }, useSyncExternalStore: function(a2, b2, c2) {
    if (void 0 === c2) throw Error(k2(407));
    return c2();
  } }, Nc = null, Pc = aa2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
  function Qc(a2) {
    console.error(a2);
    return null;
  }
  function X2() {
  }
  function Rc(a2, b2, c2, d2, f2, e2, g2, h2, m2) {
    var q2 = [], r2 = /* @__PURE__ */ new Set();
    b2 = { destination: null, responseState: b2, progressiveChunkSize: void 0 === d2 ? 12800 : d2, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: r2, pingedTasks: q2, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: void 0 === f2 ? Qc : f2, onAllReady: void 0 === e2 ? X2 : e2, onShellReady: void 0 === g2 ? X2 : g2, onShellError: void 0 === h2 ? X2 : h2, onFatalError: void 0 === m2 ? X2 : m2 };
    c2 = Sc(b2, 0, null, c2, false, false);
    c2.parentFlushed = true;
    a2 = Tc(b2, a2, null, c2, r2, kc, null, sc);
    q2.push(a2);
    return b2;
  }
  function Tc(a2, b2, c2, d2, f2, e2, g2, h2) {
    a2.allPendingTasks++;
    null === c2 ? a2.pendingRootTasks++ : c2.pendingTasks++;
    var m2 = { node: b2, ping: function() {
      var b3 = a2.pingedTasks;
      b3.push(m2);
      1 === b3.length && Uc(a2);
    }, blockedBoundary: c2, blockedSegment: d2, abortSet: f2, legacyContext: e2, context: g2, treeContext: h2 };
    f2.add(m2);
    return m2;
  }
  function Sc(a2, b2, c2, d2, f2, e2) {
    return { status: 0, id: -1, index: b2, parentFlushed: false, chunks: [], children: [], formatContext: d2, boundary: c2, lastPushedText: f2, textEmbedded: e2 };
  }
  function Y2(a2, b2) {
    a2 = a2.onError(b2);
    if (null != a2 && "string" !== typeof a2) throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof a2 + '" instead');
    return a2;
  }
  function Vc(a2, b2) {
    var c2 = a2.onShellError;
    c2(b2);
    c2 = a2.onFatalError;
    c2(b2);
    null !== a2.destination ? (a2.status = 2, da(a2.destination, b2)) : (a2.status = 1, a2.fatalError = b2);
  }
  function Wc(a2, b2, c2, d2, f2) {
    R2 = {};
    Ac = b2;
    U2 = 0;
    for (a2 = c2(d2, f2); Cc; ) Cc = false, U2 = 0, Dc += 1, S2 = null, a2 = c2(d2, f2);
    Gc();
    return a2;
  }
  function Xc(a2, b2, c2, d2) {
    var f2 = c2.render(), e2 = d2.childContextTypes;
    if (null !== e2 && void 0 !== e2) {
      var g2 = b2.legacyContext;
      if ("function" !== typeof c2.getChildContext) d2 = g2;
      else {
        c2 = c2.getChildContext();
        for (var h2 in c2) if (!(h2 in e2)) throw Error(k2(108, jc(d2) || "Unknown", h2));
        d2 = N2({}, g2, c2);
      }
      b2.legacyContext = d2;
      Z2(a2, b2, f2);
      b2.legacyContext = g2;
    } else Z2(a2, b2, f2);
  }
  function Yc(a2, b2) {
    if (a2 && a2.defaultProps) {
      b2 = N2({}, b2);
      a2 = a2.defaultProps;
      for (var c2 in a2) void 0 === b2[c2] && (b2[c2] = a2[c2]);
      return b2;
    }
    return b2;
  }
  function Zc(a2, b2, c2, d2, f2) {
    if ("function" === typeof c2) if (c2.prototype && c2.prototype.isReactComponent) {
      f2 = lc(c2, b2.legacyContext);
      var e2 = c2.contextType;
      e2 = new c2(d2, "object" === typeof e2 && null !== e2 ? e2._currentValue : f2);
      rc(e2, c2, d2, f2);
      Xc(a2, b2, e2, c2);
    } else {
      e2 = lc(c2, b2.legacyContext);
      f2 = Wc(a2, b2, c2, d2, e2);
      var g2 = 0 !== U2;
      if ("object" === typeof f2 && null !== f2 && "function" === typeof f2.render && void 0 === f2.$$typeof) rc(f2, c2, d2, e2), Xc(a2, b2, f2, c2);
      else if (g2) {
        d2 = b2.treeContext;
        b2.treeContext = tc(d2, 1, 0);
        try {
          Z2(a2, b2, f2);
        } finally {
          b2.treeContext = d2;
        }
      } else Z2(a2, b2, f2);
    }
    else if ("string" === typeof c2) {
      f2 = b2.blockedSegment;
      e2 = Sa(f2.chunks, c2, d2, a2.responseState, f2.formatContext);
      f2.lastPushedText = false;
      g2 = f2.formatContext;
      f2.formatContext = Ba(g2, c2, d2);
      $c(a2, b2, e2);
      f2.formatContext = g2;
      switch (c2) {
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "img":
        case "input":
        case "keygen":
        case "link":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
          break;
        default:
          f2.chunks.push(Ta, u2(c2), Ua);
      }
      f2.lastPushedText = false;
    } else {
      switch (c2) {
        case gc:
        case fc:
        case Wb:
        case Xb:
        case Vb:
          Z2(a2, b2, d2.children);
          return;
        case bc:
          Z2(a2, b2, d2.children);
          return;
        case ec:
          throw Error(k2(343));
        case ac:
          a: {
            c2 = b2.blockedBoundary;
            f2 = b2.blockedSegment;
            e2 = d2.fallback;
            d2 = d2.children;
            g2 = /* @__PURE__ */ new Set();
            var h2 = { id: null, rootSegmentID: -1, parentFlushed: false, pendingTasks: 0, forceClientRender: false, completedSegments: [], byteSize: 0, fallbackAbortableTasks: g2, errorDigest: null }, m2 = Sc(a2, f2.chunks.length, h2, f2.formatContext, false, false);
            f2.children.push(m2);
            f2.lastPushedText = false;
            var q2 = Sc(a2, 0, null, f2.formatContext, false, false);
            q2.parentFlushed = true;
            b2.blockedBoundary = h2;
            b2.blockedSegment = q2;
            try {
              if ($c(
                a2,
                b2,
                d2
              ), q2.lastPushedText && q2.textEmbedded && q2.chunks.push(Ca), q2.status = 1, ad(h2, q2), 0 === h2.pendingTasks) break a;
            } catch (r2) {
              q2.status = 4, h2.forceClientRender = true, h2.errorDigest = Y2(a2, r2);
            } finally {
              b2.blockedBoundary = c2, b2.blockedSegment = f2;
            }
            b2 = Tc(a2, e2, c2, m2, g2, b2.legacyContext, b2.context, b2.treeContext);
            a2.pingedTasks.push(b2);
          }
          return;
      }
      if ("object" === typeof c2 && null !== c2) switch (c2.$$typeof) {
        case $b:
          d2 = Wc(a2, b2, c2.render, d2, f2);
          if (0 !== U2) {
            c2 = b2.treeContext;
            b2.treeContext = tc(c2, 1, 0);
            try {
              Z2(a2, b2, d2);
            } finally {
              b2.treeContext = c2;
            }
          } else Z2(a2, b2, d2);
          return;
        case cc:
          c2 = c2.type;
          d2 = Yc(c2, d2);
          Zc(a2, b2, c2, d2, f2);
          return;
        case Yb:
          f2 = d2.children;
          c2 = c2._context;
          d2 = d2.value;
          e2 = c2._currentValue;
          c2._currentValue = d2;
          g2 = O2;
          O2 = d2 = { parent: g2, depth: null === g2 ? 0 : g2.depth + 1, context: c2, parentValue: e2, value: d2 };
          b2.context = d2;
          Z2(a2, b2, f2);
          a2 = O2;
          if (null === a2) throw Error(k2(403));
          d2 = a2.parentValue;
          a2.context._currentValue = d2 === hc ? a2.context._defaultValue : d2;
          a2 = O2 = a2.parent;
          b2.context = a2;
          return;
        case Zb:
          d2 = d2.children;
          d2 = d2(c2._currentValue);
          Z2(a2, b2, d2);
          return;
        case dc:
          f2 = c2._init;
          c2 = f2(c2._payload);
          d2 = Yc(c2, d2);
          Zc(a2, b2, c2, d2, void 0);
          return;
      }
      throw Error(k2(
        130,
        null == c2 ? c2 : typeof c2,
        ""
      ));
    }
  }
  function Z2(a2, b2, c2) {
    b2.node = c2;
    if ("object" === typeof c2 && null !== c2) {
      switch (c2.$$typeof) {
        case Tb:
          Zc(a2, b2, c2.type, c2.props, c2.ref);
          return;
        case Ub:
          throw Error(k2(257));
        case dc:
          var d2 = c2._init;
          c2 = d2(c2._payload);
          Z2(a2, b2, c2);
          return;
      }
      if (ra2(c2)) {
        bd(a2, b2, c2);
        return;
      }
      null === c2 || "object" !== typeof c2 ? d2 = null : (d2 = ic && c2[ic] || c2["@@iterator"], d2 = "function" === typeof d2 ? d2 : null);
      if (d2 && (d2 = d2.call(c2))) {
        c2 = d2.next();
        if (!c2.done) {
          var f2 = [];
          do
            f2.push(c2.value), c2 = d2.next();
          while (!c2.done);
          bd(a2, b2, f2);
        }
        return;
      }
      a2 = Object.prototype.toString.call(c2);
      throw Error(k2(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(c2).join(", ") + "}" : a2));
    }
    "string" === typeof c2 ? (d2 = b2.blockedSegment, d2.lastPushedText = Da(b2.blockedSegment.chunks, c2, a2.responseState, d2.lastPushedText)) : "number" === typeof c2 && (d2 = b2.blockedSegment, d2.lastPushedText = Da(b2.blockedSegment.chunks, "" + c2, a2.responseState, d2.lastPushedText));
  }
  function bd(a2, b2, c2) {
    for (var d2 = c2.length, f2 = 0; f2 < d2; f2++) {
      var e2 = b2.treeContext;
      b2.treeContext = tc(e2, d2, f2);
      try {
        $c(a2, b2, c2[f2]);
      } finally {
        b2.treeContext = e2;
      }
    }
  }
  function $c(a2, b2, c2) {
    var d2 = b2.blockedSegment.formatContext, f2 = b2.legacyContext, e2 = b2.context;
    try {
      return Z2(a2, b2, c2);
    } catch (m2) {
      if (Gc(), "object" === typeof m2 && null !== m2 && "function" === typeof m2.then) {
        c2 = m2;
        var g2 = b2.blockedSegment, h2 = Sc(a2, g2.chunks.length, null, g2.formatContext, g2.lastPushedText, true);
        g2.children.push(h2);
        g2.lastPushedText = false;
        a2 = Tc(a2, b2.node, b2.blockedBoundary, h2, b2.abortSet, b2.legacyContext, b2.context, b2.treeContext).ping;
        c2.then(a2, a2);
        b2.blockedSegment.formatContext = d2;
        b2.legacyContext = f2;
        b2.context = e2;
        Q2(e2);
      } else throw b2.blockedSegment.formatContext = d2, b2.legacyContext = f2, b2.context = e2, Q2(e2), m2;
    }
  }
  function cd(a2) {
    var b2 = a2.blockedBoundary;
    a2 = a2.blockedSegment;
    a2.status = 3;
    dd(this, b2, a2);
  }
  function ed(a2, b2, c2) {
    var d2 = a2.blockedBoundary;
    a2.blockedSegment.status = 3;
    null === d2 ? (b2.allPendingTasks--, 2 !== b2.status && (b2.status = 2, null !== b2.destination && b2.destination.close())) : (d2.pendingTasks--, d2.forceClientRender || (d2.forceClientRender = true, a2 = void 0 === c2 ? Error(k2(432)) : c2, d2.errorDigest = b2.onError(a2), d2.parentFlushed && b2.clientRenderedBoundaries.push(d2)), d2.fallbackAbortableTasks.forEach(function(a3) {
      return ed(a3, b2, c2);
    }), d2.fallbackAbortableTasks.clear(), b2.allPendingTasks--, 0 === b2.allPendingTasks && (d2 = b2.onAllReady, d2()));
  }
  function ad(a2, b2) {
    if (0 === b2.chunks.length && 1 === b2.children.length && null === b2.children[0].boundary) {
      var c2 = b2.children[0];
      c2.id = b2.id;
      c2.parentFlushed = true;
      1 === c2.status && ad(a2, c2);
    } else a2.completedSegments.push(b2);
  }
  function dd(a2, b2, c2) {
    if (null === b2) {
      if (c2.parentFlushed) {
        if (null !== a2.completedRootSegment) throw Error(k2(389));
        a2.completedRootSegment = c2;
      }
      a2.pendingRootTasks--;
      0 === a2.pendingRootTasks && (a2.onShellError = X2, b2 = a2.onShellReady, b2());
    } else b2.pendingTasks--, b2.forceClientRender || (0 === b2.pendingTasks ? (c2.parentFlushed && 1 === c2.status && ad(b2, c2), b2.parentFlushed && a2.completedBoundaries.push(b2), b2.fallbackAbortableTasks.forEach(cd, a2), b2.fallbackAbortableTasks.clear()) : c2.parentFlushed && 1 === c2.status && (ad(b2, c2), 1 === b2.completedSegments.length && b2.parentFlushed && a2.partialBoundaries.push(b2)));
    a2.allPendingTasks--;
    0 === a2.allPendingTasks && (a2 = a2.onAllReady, a2());
  }
  function Uc(a2) {
    if (2 !== a2.status) {
      var b2 = O2, c2 = Pc.current;
      Pc.current = Oc;
      var d2 = Nc;
      Nc = a2.responseState;
      try {
        var f2 = a2.pingedTasks, e2;
        for (e2 = 0; e2 < f2.length; e2++) {
          var g2 = f2[e2];
          var h2 = a2, m2 = g2.blockedSegment;
          if (0 === m2.status) {
            Q2(g2.context);
            try {
              Z2(h2, g2, g2.node), m2.lastPushedText && m2.textEmbedded && m2.chunks.push(Ca), g2.abortSet.delete(g2), m2.status = 1, dd(h2, g2.blockedBoundary, m2);
            } catch (G2) {
              if (Gc(), "object" === typeof G2 && null !== G2 && "function" === typeof G2.then) {
                var q2 = g2.ping;
                G2.then(q2, q2);
              } else {
                g2.abortSet.delete(g2);
                m2.status = 4;
                var r2 = g2.blockedBoundary, v2 = G2, A2 = Y2(h2, v2);
                null === r2 ? Vc(h2, v2) : (r2.pendingTasks--, r2.forceClientRender || (r2.forceClientRender = true, r2.errorDigest = A2, r2.parentFlushed && h2.clientRenderedBoundaries.push(r2)));
                h2.allPendingTasks--;
                if (0 === h2.allPendingTasks) {
                  var F2 = h2.onAllReady;
                  F2();
                }
              }
            } finally {
            }
          }
        }
        f2.splice(0, e2);
        null !== a2.destination && fd(a2, a2.destination);
      } catch (G2) {
        Y2(a2, G2), Vc(a2, G2);
      } finally {
        Nc = d2, Pc.current = c2, c2 === Oc && Q2(b2);
      }
    }
  }
  function gd(a2, b2, c2) {
    c2.parentFlushed = true;
    switch (c2.status) {
      case 0:
        var d2 = c2.id = a2.nextSegmentId++;
        c2.lastPushedText = false;
        c2.textEmbedded = false;
        a2 = a2.responseState;
        p2(b2, Va);
        p2(b2, a2.placeholderPrefix);
        a2 = u2(d2.toString(16));
        p2(b2, a2);
        return t2(b2, Wa);
      case 1:
        c2.status = 2;
        var f2 = true;
        d2 = c2.chunks;
        var e2 = 0;
        c2 = c2.children;
        for (var g2 = 0; g2 < c2.length; g2++) {
          for (f2 = c2[g2]; e2 < f2.index; e2++) p2(b2, d2[e2]);
          f2 = hd(a2, b2, f2);
        }
        for (; e2 < d2.length - 1; e2++) p2(b2, d2[e2]);
        e2 < d2.length && (f2 = t2(b2, d2[e2]));
        return f2;
      default:
        throw Error(k2(390));
    }
  }
  function hd(a2, b2, c2) {
    var d2 = c2.boundary;
    if (null === d2) return gd(a2, b2, c2);
    d2.parentFlushed = true;
    if (d2.forceClientRender) d2 = d2.errorDigest, t2(b2, $a), p2(b2, bb), d2 && (p2(b2, db), p2(b2, u2(C2(d2))), p2(b2, cb)), t2(b2, eb), gd(a2, b2, c2);
    else if (0 < d2.pendingTasks) {
      d2.rootSegmentID = a2.nextSegmentId++;
      0 < d2.completedSegments.length && a2.partialBoundaries.push(d2);
      var f2 = a2.responseState;
      var e2 = f2.nextSuspenseID++;
      f2 = w2(f2.boundaryPrefix + e2.toString(16));
      d2 = d2.id = f2;
      fb(b2, a2.responseState, d2);
      gd(a2, b2, c2);
    } else if (d2.byteSize > a2.progressiveChunkSize) d2.rootSegmentID = a2.nextSegmentId++, a2.completedBoundaries.push(d2), fb(b2, a2.responseState, d2.id), gd(a2, b2, c2);
    else {
      t2(b2, Xa);
      c2 = d2.completedSegments;
      if (1 !== c2.length) throw Error(k2(391));
      hd(a2, b2, c2[0]);
    }
    return t2(b2, ab);
  }
  function id2(a2, b2, c2) {
    Bb(b2, a2.responseState, c2.formatContext, c2.id);
    hd(a2, b2, c2);
    return Cb(b2, c2.formatContext);
  }
  function jd(a2, b2, c2) {
    for (var d2 = c2.completedSegments, f2 = 0; f2 < d2.length; f2++) kd(a2, b2, c2, d2[f2]);
    d2.length = 0;
    a2 = a2.responseState;
    d2 = c2.id;
    c2 = c2.rootSegmentID;
    p2(b2, a2.startInlineScript);
    a2.sentCompleteBoundaryFunction ? p2(b2, Jb) : (a2.sentCompleteBoundaryFunction = true, p2(b2, Ib));
    if (null === d2) throw Error(k2(395));
    c2 = u2(c2.toString(16));
    p2(b2, d2);
    p2(b2, Kb);
    p2(b2, a2.segmentPrefix);
    p2(b2, c2);
    return t2(b2, Lb);
  }
  function kd(a2, b2, c2, d2) {
    if (2 === d2.status) return true;
    var f2 = d2.id;
    if (-1 === f2) {
      if (-1 === (d2.id = c2.rootSegmentID)) throw Error(k2(392));
      return id2(a2, b2, d2);
    }
    id2(a2, b2, d2);
    a2 = a2.responseState;
    p2(b2, a2.startInlineScript);
    a2.sentCompleteSegmentFunction ? p2(b2, Eb) : (a2.sentCompleteSegmentFunction = true, p2(b2, Db));
    p2(b2, a2.segmentPrefix);
    f2 = u2(f2.toString(16));
    p2(b2, f2);
    p2(b2, Gb);
    p2(b2, a2.placeholderPrefix);
    p2(b2, f2);
    return t2(b2, Hb);
  }
  function fd(a2, b2) {
    l2 = new Uint8Array(512);
    n2 = 0;
    try {
      var c2 = a2.completedRootSegment;
      if (null !== c2 && 0 === a2.pendingRootTasks) {
        hd(a2, b2, c2);
        a2.completedRootSegment = null;
        var d2 = a2.responseState.bootstrapChunks;
        for (c2 = 0; c2 < d2.length - 1; c2++) p2(b2, d2[c2]);
        c2 < d2.length && t2(b2, d2[c2]);
      }
      var f2 = a2.clientRenderedBoundaries, e2;
      for (e2 = 0; e2 < f2.length; e2++) {
        var g2 = f2[e2];
        d2 = b2;
        var h2 = a2.responseState, m2 = g2.id, q2 = g2.errorDigest, r2 = g2.errorMessage, v2 = g2.errorComponentStack;
        p2(d2, h2.startInlineScript);
        h2.sentClientRenderFunction ? p2(d2, Nb) : (h2.sentClientRenderFunction = true, p2(
          d2,
          Mb
        ));
        if (null === m2) throw Error(k2(395));
        p2(d2, m2);
        p2(d2, Ob);
        if (q2 || r2 || v2) p2(d2, Qb), p2(d2, u2(Sb(q2 || "")));
        if (r2 || v2) p2(d2, Qb), p2(d2, u2(Sb(r2 || "")));
        v2 && (p2(d2, Qb), p2(d2, u2(Sb(v2))));
        if (!t2(d2, Pb)) ;
      }
      f2.splice(0, e2);
      var A2 = a2.completedBoundaries;
      for (e2 = 0; e2 < A2.length; e2++) if (!jd(a2, b2, A2[e2])) ;
      A2.splice(0, e2);
      ba(b2);
      l2 = new Uint8Array(512);
      n2 = 0;
      var F2 = a2.partialBoundaries;
      for (e2 = 0; e2 < F2.length; e2++) {
        var G2 = F2[e2];
        a: {
          f2 = a2;
          g2 = b2;
          var ma = G2.completedSegments;
          for (h2 = 0; h2 < ma.length; h2++) if (!kd(
            f2,
            g2,
            G2,
            ma[h2]
          )) {
            h2++;
            ma.splice(0, h2);
            var Fb = false;
            break a;
          }
          ma.splice(0, h2);
          Fb = true;
        }
        if (!Fb) {
          a2.destination = null;
          e2++;
          F2.splice(0, e2);
          return;
        }
      }
      F2.splice(0, e2);
      var na2 = a2.completedBoundaries;
      for (e2 = 0; e2 < na2.length; e2++) if (!jd(a2, b2, na2[e2])) ;
      na2.splice(0, e2);
    } finally {
      ba(b2), 0 === a2.allPendingTasks && 0 === a2.pingedTasks.length && 0 === a2.clientRenderedBoundaries.length && 0 === a2.completedBoundaries.length && b2.close();
    }
  }
  function ld(a2, b2) {
    try {
      var c2 = a2.abortableTasks;
      c2.forEach(function(c3) {
        return ed(c3, a2, b2);
      });
      c2.clear();
      null !== a2.destination && fd(a2, a2.destination);
    } catch (d2) {
      Y2(a2, d2), Vc(a2, d2);
    }
  }
  reactDomServer_browser_production_min.renderToReadableStream = function(a2, b2) {
    return new Promise(function(c2, d2) {
      var f2, e2, g2 = new Promise(function(a3, b3) {
        e2 = a3;
        f2 = b3;
      }), h2 = Rc(a2, za(b2 ? b2.identifierPrefix : void 0, b2 ? b2.nonce : void 0, b2 ? b2.bootstrapScriptContent : void 0, b2 ? b2.bootstrapScripts : void 0, b2 ? b2.bootstrapModules : void 0), Aa(b2 ? b2.namespaceURI : void 0), b2 ? b2.progressiveChunkSize : void 0, b2 ? b2.onError : void 0, e2, function() {
        var a3 = new ReadableStream({ type: "bytes", pull: function(a4) {
          if (1 === h2.status) h2.status = 2, da(a4, h2.fatalError);
          else if (2 !== h2.status && null === h2.destination) {
            h2.destination = a4;
            try {
              fd(h2, a4);
            } catch (A2) {
              Y2(h2, A2), Vc(h2, A2);
            }
          }
        }, cancel: function() {
          ld(h2);
        } }, { highWaterMark: 0 });
        a3.allReady = g2;
        c2(a3);
      }, function(a3) {
        g2.catch(function() {
        });
        d2(a3);
      }, f2);
      if (b2 && b2.signal) {
        var m2 = b2.signal, q2 = function() {
          ld(h2, m2.reason);
          m2.removeEventListener("abort", q2);
        };
        m2.addEventListener("abort", q2);
      }
      Uc(h2);
    });
  };
  reactDomServer_browser_production_min.version = "18.3.1";
  return reactDomServer_browser_production_min;
}
var hasRequiredServer_browser;
function requireServer_browser() {
  if (hasRequiredServer_browser) return server_browser;
  hasRequiredServer_browser = 1;
  var l2, s2;
  {
    l2 = requireReactDomServerLegacy_browser_production_min();
    s2 = requireReactDomServer_browser_production_min();
  }
  server_browser.version = l2.version;
  server_browser.renderToString = l2.renderToString;
  server_browser.renderToStaticMarkup = l2.renderToStaticMarkup;
  server_browser.renderToNodeStream = l2.renderToNodeStream;
  server_browser.renderToStaticNodeStream = l2.renderToStaticNodeStream;
  server_browser.renderToReadableStream = s2.renderToReadableStream;
  return server_browser;
}
var server_browserExports = requireServer_browser();
async function handleRequest(request, responseStatusCode, responseHeaders, routerContext, _loadContext) {
  let shellRendered = false;
  const userAgent = request.headers.get("user-agent");
  const body = await server_browserExports.renderToReadableStream(
    /* @__PURE__ */ jsxRuntimeExports.jsx(ServerRouter, { context: routerContext, url: request.url }),
    {
      onError(error) {
        responseStatusCode = 500;
        if (shellRendered) {
          console.error(error);
        }
      }
    }
  );
  shellRendered = true;
  if (userAgent && isbot(userAgent) || routerContext.isSpaMode) {
    await body.allReady;
  }
  responseHeaders.set("Content-Type", "text/html");
  return new Response(body, {
    headers: responseHeaders,
    status: responseStatusCode
  });
}
const entryServer = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: handleRequest
}, Symbol.toStringTag, { value: "Module" }));
const translations = {
  "en": {
    "nav.howItWorks": "How it works",
    "nav.benefits": "Benefits",
    "nav.pricing": "Pricing",
    "nav.faq": "FAQ",
    "nav.getStarted": "Get started",
    "nav.joinWaitlist": "Join waitlist",
    "footer.product": "Product",
    "footer.support": "Support",
    "footer.legal": "Legal",
    "footer.examples": "Examples",
    "footer.contactUs": "Contact us",
    "footer.helpCenter": "Help center",
    "footer.tutorials": "Tutorials",
    "footer.privacyPolicy": "Privacy policy",
    "footer.termsOfService": "Terms of service",
    "footer.cookiePolicy": "Cookie policy",
    "footer.gdpr": "GDPR",
    "footer.rights": "All rights reserved.",
    "footer.madeWith": "Made with",
    "footer.colorful": "for colorful moments",
    "landing.hero.title": "Transform your photos into beautiful",
    "landing.hero.titleHighlight": "coloring books",
    "landing.hero.subtitle": "Our AI technology turns your favorite photos into personalized coloring pages, creating unique, memorable experiences for all ages.",
    "landing.seeTheMagic": "See the magic in action",
    "landing.seeTheMagicSubtitle": "Swipe to see how our AI transforms ordinary photos into extraordinary coloring pages",
    "landing.pricing.title": "Simple, transparent pricing",
    "landing.pricing.subtitle": "Create your personalized coloring book with our easy-to-understand pricing",
    "landing.features.title": "What's included:",
    "landing.features.transform": "Transform up to 20 photos",
    "landing.features.quality": "High-quality line art conversion",
    "landing.features.cover": "Custom cover design",
    "landing.features.download": "Digital PDF download",
    "landing.features.print": "Print-ready format",
    "landing.features.commercial": "Commercial use license",
    "landing.cta.title": "Ready to create your custom coloring book?",
    "landing.cta.subtitle": "Start with just one photo and see the magic happen. Then create a full 20-page personalized coloring book with your favorite memories.",
    "landing.cta.button": "Create your coloring book",
    "waitlist.title": "Join our waitlist",
    "waitlist.subtitle": "Be the first to know when our AI coloring book creator launches",
    "waitlist.comingSoon": "Coming soon!",
    "waitlist.description": "We're putting the finishing touches on our AI-powered coloring book creator. Join our waitlist to:",
    "waitlist.benefits.earlyAccess": "Get early access when we launch",
    "waitlist.benefits.discount": "Receive a special discount on your first coloring book",
    "waitlist.benefits.features": "Be the first to try new features",
    "pricing.addons.title": "Optional add-ons",
    "pricing.addons.printing": "Professional printing",
    "pricing.addons.printing.description": "Get your coloring book professionally printed and bound",
    "pricing.addons.rush": "Rush processing",
    "pricing.addons.rush.description": "Get your digital coloring book within 2 hours",
    "pricing.addons.pages": "Extra pages",
    "pricing.addons.pages.description": "Add more pages to your coloring book",
    "pricing.needMore.title": "Need more?",
    "pricing.needMore.subtitle": "Contact us for custom packages, bulk orders, or special requirements",
    "pricing.needMore.button": "Contact sales",
    "howItWorks.title": "How it works",
    "howItWorks.subtitle": "Create your custom coloring book in just a few simple steps",
    "howItWorks.steps.upload.title": "Upload your photos",
    "howItWorks.steps.upload.description": "Select and upload your favorite photos to be transformed.",
    "howItWorks.steps.preview.title": "Preview & customize",
    "howItWorks.steps.preview.description": "See how your photos will look as coloring pages and make adjustments.",
    "howItWorks.steps.purchase.title": "Purchase your book",
    "howItWorks.steps.purchase.description": "Complete your purchase to create your personalized coloring book.",
    "howItWorks.steps.enjoy.title": "Color & enjoy",
    "howItWorks.steps.enjoy.description": "Print your coloring book at home or have it professionally printed and shipped.",
    "benefits.title": "The benefits of MylineArts",
    "benefits.subtitle": "Why create a personalized coloring book with us?",
    "benefits.personal.title": "Personalized experience",
    "benefits.personal.description": "Create coloring pages from your own photos for a truly personal experience",
    "benefits.fast.title": "Fast & easy",
    "benefits.fast.description": "Our AI transforms your photos into coloring pages in seconds",
    "benefits.creative.title": "Creative fun",
    "benefits.creative.description": "Enjoy hours of creative relaxation coloring your personal memories",
    "benefits.family.title": "Perfect for families",
    "benefits.family.description": "Create enjoyable activities for children and adults of all ages",
    "benefits.gift.title": "Unique gift",
    "benefits.gift.description": "Give a one-of-a-kind gift that's personal and thoughtful",
    "benefits.quality.title": "High quality",
    "benefits.quality.description": "Premium quality line art that's perfect for coloring",
    "landing.pricing.customBook": "Custom coloring book",
    "landing.pricing.transform": "Transform your photos into a beautiful coloring book",
    "landing.pricing.oneTime": "One-time purchase",
    "landing.pricing.viewDetails": "View full pricing details",
    "faq.title": "Frequently asked questions",
    "faq.subtitle": "Get answers to common questions about our coloring book creation process",
    "faq.time.question": "How long does it take to convert my photos?",
    "faq.time.answer": "Our AI technology typically transforms your photos into coloring pages within 30-60 seconds per image, depending on complexity.",
    "faq.photos.question": "What type of photos work best?",
    "faq.photos.answer": "Photos with clear subjects, good lighting, and minimal background clutter work best. However, our AI is designed to handle a wide variety of images.",
    "faq.edit.question": "Can I edit the coloring pages after they're created?",
    "faq.edit.answer": "No, you cannot edit the coloring pages after they're generated. If you're not satisfied with the result, you'll need to generate a new image using another credit.",
    "faq.text.question": "Can I include text or captions with my coloring pages?",
    "faq.text.answer": "Yes, you can add custom titles, captions, or messages to each page of your coloring book during the creation process."
  },
  "pt-BR": {
    "nav.howItWorks": "Como funciona",
    "nav.benefits": "Benefícios",
    "nav.pricing": "Preços",
    "nav.faq": "Dúvidas",
    "nav.getStarted": "Começar",
    "nav.joinWaitlist": "Entrar na lista",
    "footer.product": "Produto",
    "footer.support": "Suporte",
    "footer.legal": "Legal",
    "footer.examples": "Exemplos",
    "footer.contactUs": "Fale conosco",
    "footer.helpCenter": "Central de ajuda",
    "footer.tutorials": "Tutoriais",
    "footer.privacyPolicy": "Política de privacidade",
    "footer.termsOfService": "Termos de serviço",
    "footer.cookiePolicy": "Política de cookies",
    "footer.gdpr": "LGPD",
    "footer.rights": "Todos os direitos reservados.",
    "footer.madeWith": "Feito com",
    "footer.colorful": "para momentos coloridos",
    "landing.hero.title": "Transforme suas fotos em lindos",
    "landing.hero.titleHighlight": "livros de colorir",
    "landing.hero.subtitle": "Nossa tecnologia de IA transforma suas fotos favoritas em páginas para colorir personalizadas, criando experiências únicas e memoráveis para todas as idades.",
    "landing.seeTheMagic": "Veja a mágica acontecer",
    "landing.seeTheMagicSubtitle": "Deslize para ver como nossa IA transforma fotos comuns em extraordinárias páginas para colorir",
    "landing.pricing.title": "Preços simples e transparentes",
    "landing.pricing.subtitle": "Crie seu livro de colorir personalizado com nossa precificação fácil de entender",
    "landing.features.title": "O que está incluído:",
    "landing.features.transform": "Transforme até 20 fotos",
    "landing.features.quality": "Conversão em arte linear de alta qualidade",
    "landing.features.cover": "Design de capa personalizado",
    "landing.features.download": "Download em PDF digital",
    "landing.features.print": "Formato pronto para impressão",
    "landing.features.commercial": "Licença de uso comercial",
    "landing.cta.title": "Pronto para criar seu livro de colorir personalizado?",
    "landing.cta.subtitle": "Comece com uma foto e veja a mágica acontecer. Depois crie um livro de colorir personalizado completo com 20 páginas de suas memórias favoritas.",
    "landing.cta.button": "Criar seu livro de colorir",
    "waitlist.title": "Entre na nossa lista de espera",
    "waitlist.subtitle": "Seja o primeiro a saber quando nosso criador de livros de colorir com IA for lançado",
    "waitlist.comingSoon": "Em breve!",
    "waitlist.description": "Estamos dando os últimos retoques em nosso criador de livros de colorir com IA. Entre na lista de espera para:",
    "waitlist.benefits.earlyAccess": "Ter acesso antecipado quando lançarmos",
    "waitlist.benefits.discount": "Receber um desconto especial no seu primeiro livro",
    "waitlist.benefits.features": "Ser o primeiro a experimentar novos recursos",
    "pricing.addons.title": "Adicionais opcionais",
    "pricing.addons.printing": "Impressão profissional",
    "pricing.addons.printing.description": "Receba seu livro de colorir impresso e encadernado profissionalmente",
    "pricing.addons.rush": "Processamento rápido",
    "pricing.addons.rush.description": "Receba seu livro digital em até 2 horas",
    "pricing.addons.pages": "Páginas extras",
    "pricing.addons.pages.description": "Adicione mais páginas ao seu livro de colorir",
    "pricing.needMore.title": "Precisa de mais?",
    "pricing.needMore.subtitle": "Entre em contato para pacotes personalizados, pedidos em quantidade ou requisitos especiais",
    "pricing.needMore.button": "Falar com vendas",
    "howItWorks.title": "Como funciona",
    "howItWorks.subtitle": "Crie seu livro de colorir personalizado em apenas alguns passos simples",
    "howItWorks.steps.upload.title": "Envie suas fotos",
    "howItWorks.steps.upload.description": "Selecione e envie suas fotos favoritas para serem transformadas.",
    "howItWorks.steps.preview.title": "Visualize e personalize",
    "howItWorks.steps.preview.description": "Veja como suas fotos ficarão como páginas para colorir e faça ajustes.",
    "howItWorks.steps.purchase.title": "Compre seu livro",
    "howItWorks.steps.purchase.description": "Complete sua compra para criar seu livro de colorir personalizado.",
    "howItWorks.steps.enjoy.title": "Pinte e aproveite",
    "howItWorks.steps.enjoy.description": "Imprima seu livro de colorir em casa ou peça a impressão profissional e envio.",
    "benefits.title": "Os benefícios do MylineArts",
    "benefits.subtitle": "Por que criar um livro de colorir personalizado conosco?",
    "benefits.personal.title": "Experiência personalizada",
    "benefits.personal.description": "Crie páginas para colorir a partir de suas próprias fotos para uma experiência verdadeiramente pessoal",
    "benefits.fast.title": "Rápido & fácil",
    "benefits.fast.description": "Nossa IA transforma suas fotos em páginas para colorir em segundos",
    "benefits.creative.title": "Diversão criativa",
    "benefits.creative.description": "Aproveite horas de relaxamento criativo colorindo suas memórias pessoais",
    "benefits.family.title": "Perfeito para famílias",
    "benefits.family.description": "Crie atividades divertidas para crianças e adultos de todas as idades",
    "benefits.gift.title": "Presente único",
    "benefits.gift.description": "Dê um presente único que é pessoal e significativo",
    "benefits.quality.title": "Alta qualidade",
    "benefits.quality.description": "Arte linear de qualidade premium perfeita para colorir",
    "landing.pricing.customBook": "Livro de colorir personalizado",
    "landing.pricing.transform": "Transforme suas fotos em um lindo livro de colorir",
    "landing.pricing.oneTime": "Compra única",
    "landing.pricing.viewDetails": "Ver detalhes completos de preços",
    "faq.title": "Perguntas frequentes",
    "faq.subtitle": "Obtenha respostas para perguntas comuns sobre nosso processo de criação de livros de colorir",
    "faq.time.question": "Quanto tempo leva para converter minhas fotos?",
    "faq.time.answer": "Nossa tecnologia de IA geralmente transforma suas fotos em páginas para colorir em 30-60 segundos por imagem, dependendo da complexidade.",
    "faq.photos.question": "Que tipo de fotos funcionam melhor?",
    "faq.photos.answer": "Fotos com assuntos claros, boa iluminação e fundo com pouca interferência funcionam melhor. No entanto, nossa IA é projetada para lidar com uma grande variedade de imagens.",
    "faq.edit.question": "Posso editar as páginas para colorir depois de criadas?",
    "faq.edit.answer": "Não, você não pode editar as páginas para colorir após serem geradas. Se não estiver satisfeito com o resultado, será necessário gerar uma nova imagem usando outro crédito.",
    "faq.text.question": "Posso incluir texto ou legendas nas páginas para colorir?",
    "faq.text.answer": "Sim, você pode adicionar títulos personalizados, legendas ou mensagens em cada página do seu livro de colorir durante o processo de criação."
  }
};
const LanguageContext = reactExports.createContext(void 0);
const LanguageProvider = ({ children }) => {
  const location2 = useLocation();
  const detectLanguageFromPath = (pathname) => {
    return pathname.startsWith("/en") ? "en" : "pt-BR";
  };
  const [language, setLanguage] = reactExports.useState(
    () => detectLanguageFromPath(location2.pathname)
  );
  reactExports.useEffect(() => {
    const detectedLanguage = detectLanguageFromPath(location2.pathname);
    setLanguage(detectedLanguage);
  }, [location2.pathname]);
  const t2 = (key) => {
    return translations[language][key] || key;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageContext.Provider, { value: { language, setLanguage, t: t2 }, children });
};
const useLanguage = () => {
  const context = reactExports.useContext(LanguageContext);
  if (context === void 0) {
    throw new Error("useLanguage must be used within a LanguageProvider");
  }
  return context;
};
var t = "undefined" != typeof window ? window : void 0, i = "undefined" != typeof globalThis ? globalThis : t, e = Array.prototype, r = e.forEach, s = e.indexOf, n = null == i ? void 0 : i.navigator, o = null == i ? void 0 : i.document, a = null == i ? void 0 : i.location, l = null == i ? void 0 : i.fetch, u = null != i && i.XMLHttpRequest && "withCredentials" in new i.XMLHttpRequest() ? i.XMLHttpRequest : void 0, h = null == i ? void 0 : i.AbortController, d = null == n ? void 0 : n.userAgent, v = null != t ? t : {}, c = { DEBUG: false, LIB_VERSION: "1.253.3" }, f = "$copy_autocapture", p = ["$snapshot", "$pageview", "$pageleave", "$set", "survey dismissed", "survey sent", "survey shown", "$identify", "$groupidentify", "$create_alias", "$$client_ingestion_warning", "$web_experiment_applied", "$feature_enrollment_update", "$feature_flag_called"], g = function(t2) {
  return t2.GZipJS = "gzip-js", t2.Base64 = "base64", t2;
}({}), _ = ["fatal", "error", "warning", "log", "info", "debug"];
function m(t2, i2) {
  return -1 !== t2.indexOf(i2);
}
var b = function(t2) {
  return t2.trim();
}, y = function(t2) {
  return t2.replace(/^\$/, "");
};
var w = Array.isArray, S = Object.prototype, $$1 = S.hasOwnProperty, k = S.toString, x = w || function(t2) {
  return "[object Array]" === k.call(t2);
}, E = (t2) => "function" == typeof t2, I$1 = (t2) => t2 === Object(t2) && !x(t2), P = (t2) => {
  if (I$1(t2)) {
    for (var i2 in t2) if ($$1.call(t2, i2)) return false;
    return true;
  }
  return false;
}, R = (t2) => void 0 === t2, T = (t2) => "[object String]" == k.call(t2), M = (t2) => T(t2) && 0 === t2.trim().length, C = (t2) => null === t2, F$1 = (t2) => R(t2) || C(t2), O = (t2) => "[object Number]" == k.call(t2), A = (t2) => "[object Boolean]" === k.call(t2), D = (t2) => t2 instanceof FormData, L = (t2) => m(p, t2), j = (i2) => {
  var e2 = { t: function(e3) {
    if (t && (c.DEBUG || v.POSTHOG_DEBUG) && !R(t.console) && t.console) {
      for (var r2 = ("__rrweb_original__" in t.console[e3]) ? t.console[e3].__rrweb_original__ : t.console[e3], s2 = arguments.length, n2 = new Array(s2 > 1 ? s2 - 1 : 0), o2 = 1; o2 < s2; o2++) n2[o2 - 1] = arguments[o2];
      r2(i2, ...n2);
    }
  }, info: function() {
    for (var t2 = arguments.length, i3 = new Array(t2), r2 = 0; r2 < t2; r2++) i3[r2] = arguments[r2];
    e2.t("log", ...i3);
  }, warn: function() {
    for (var t2 = arguments.length, i3 = new Array(t2), r2 = 0; r2 < t2; r2++) i3[r2] = arguments[r2];
    e2.t("warn", ...i3);
  }, error: function() {
    for (var t2 = arguments.length, i3 = new Array(t2), r2 = 0; r2 < t2; r2++) i3[r2] = arguments[r2];
    e2.t("error", ...i3);
  }, critical: function() {
    for (var t2 = arguments.length, e3 = new Array(t2), r2 = 0; r2 < t2; r2++) e3[r2] = arguments[r2];
    console.error(i2, ...e3);
  }, uninitializedWarning: (t2) => {
    e2.error("You must initialize PostHog before calling " + t2);
  }, createLogger: (t2) => j(i2 + " " + t2) };
  return e2;
}, N = j("[PostHog.js]"), z = N.createLogger, U$1 = z("[ExternalScriptsLoader]"), q = (t2, i2, e2) => {
  if (t2.config.disable_external_dependency_loading) return U$1.warn(i2 + " was requested but loading of external scripts is disabled."), e2("Loading of external scripts is disabled");
  var r2 = null == o ? void 0 : o.querySelectorAll("script");
  if (r2) {
    for (var s2 = 0; s2 < r2.length; s2++) if (r2[s2].src === i2) return e2();
  }
  var n2 = () => {
    if (!o) return e2("document not found");
    var r3 = o.createElement("script");
    if (r3.type = "text/javascript", r3.crossOrigin = "anonymous", r3.src = i2, r3.onload = (t3) => e2(void 0, t3), r3.onerror = (t3) => e2(t3), t2.config.prepare_external_dependency_script && (r3 = t2.config.prepare_external_dependency_script(r3)), !r3) return e2("prepare_external_dependency_script returned null");
    var s3, n3 = o.querySelectorAll("body > script");
    n3.length > 0 ? null == (s3 = n3[0].parentNode) || s3.insertBefore(r3, n3[0]) : o.body.appendChild(r3);
  };
  null != o && o.body ? n2() : null == o || o.addEventListener("DOMContentLoaded", n2);
};
function B$1() {
  return B$1 = Object.assign ? Object.assign.bind() : function(t2) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var e2 = arguments[i2];
      for (var r2 in e2) ({}).hasOwnProperty.call(e2, r2) && (t2[r2] = e2[r2]);
    }
    return t2;
  }, B$1.apply(null, arguments);
}
function H(t2, i2) {
  if (null == t2) return {};
  var e2 = {};
  for (var r2 in t2) if ({}.hasOwnProperty.call(t2, r2)) {
    if (-1 !== i2.indexOf(r2)) continue;
    e2[r2] = t2[r2];
  }
  return e2;
}
v.__PosthogExtensions__ = v.__PosthogExtensions__ || {}, v.__PosthogExtensions__.loadExternalDependency = (t2, i2, e2) => {
  var r2 = "/static/" + i2 + ".js?v=" + t2.version;
  if ("remote-config" === i2 && (r2 = "/array/" + t2.config.token + "/config.js"), "toolbar" === i2) {
    var s2 = 3e5;
    r2 = r2 + "&t=" + Math.floor(Date.now() / s2) * s2;
  }
  var n2 = t2.requestRouter.endpointFor("assets", r2);
  q(t2, n2, e2);
}, v.__PosthogExtensions__.loadSiteApp = (t2, i2, e2) => {
  var r2 = t2.requestRouter.endpointFor("api", i2);
  q(t2, r2, e2);
};
var W$1 = {};
function G$1(t2, i2, e2) {
  if (x(t2)) {
    if (r && t2.forEach === r) t2.forEach(i2, e2);
    else if ("length" in t2 && t2.length === +t2.length) {
      for (var s2 = 0, n2 = t2.length; s2 < n2; s2++) if (s2 in t2 && i2.call(e2, t2[s2], s2) === W$1) return;
    }
  }
}
function J(t2, i2, e2) {
  if (!F$1(t2)) {
    if (x(t2)) return G$1(t2, i2, e2);
    if (D(t2)) {
      for (var r2 of t2.entries()) if (i2.call(e2, r2[1], r2[0]) === W$1) return;
    } else for (var s2 in t2) if ($$1.call(t2, s2) && i2.call(e2, t2[s2], s2) === W$1) return;
  }
}
var V = function(t2) {
  for (var i2 = arguments.length, e2 = new Array(i2 > 1 ? i2 - 1 : 0), r2 = 1; r2 < i2; r2++) e2[r2 - 1] = arguments[r2];
  return G$1(e2, function(i3) {
    for (var e3 in i3) void 0 !== i3[e3] && (t2[e3] = i3[e3]);
  }), t2;
}, K = function(t2) {
  for (var i2 = arguments.length, e2 = new Array(i2 > 1 ? i2 - 1 : 0), r2 = 1; r2 < i2; r2++) e2[r2 - 1] = arguments[r2];
  return G$1(e2, function(i3) {
    G$1(i3, function(i4) {
      t2.push(i4);
    });
  }), t2;
};
function Y(t2) {
  for (var i2 = Object.keys(t2), e2 = i2.length, r2 = new Array(e2); e2--; ) r2[e2] = [i2[e2], t2[i2[e2]]];
  return r2;
}
var X$2 = function(t2) {
  try {
    return t2();
  } catch (t3) {
    return;
  }
}, Q = function(t2) {
  return function() {
    try {
      for (var i2 = arguments.length, e2 = new Array(i2), r2 = 0; r2 < i2; r2++) e2[r2] = arguments[r2];
      return t2.apply(this, e2);
    } catch (t3) {
      N.critical("Implementation error. Please turn on debug mode and open a ticket on https://app.posthog.com/home#panel=support%3Asupport%3A."), N.critical(t3);
    }
  };
}, Z = function(t2) {
  var i2 = {};
  return J(t2, function(t3, e2) {
    (T(t3) && t3.length > 0 || O(t3)) && (i2[e2] = t3);
  }), i2;
};
function tt(t2, i2) {
  return e2 = t2, r2 = (t3) => T(t3) && !C(i2) ? t3.slice(0, i2) : t3, s2 = /* @__PURE__ */ new Set(), function t3(i3, e3) {
    return i3 !== Object(i3) ? r2 ? r2(i3, e3) : i3 : s2.has(i3) ? void 0 : (s2.add(i3), x(i3) ? (n2 = [], G$1(i3, (i4) => {
      n2.push(t3(i4));
    })) : (n2 = {}, J(i3, (i4, e4) => {
      s2.has(i4) || (n2[e4] = t3(i4, e4));
    })), n2);
    var n2;
  }(e2);
  var e2, r2, s2;
}
var it = ["herokuapp.com", "vercel.app", "netlify.app"];
function et(t2) {
  var i2 = null == t2 ? void 0 : t2.hostname;
  if (!T(i2)) return false;
  var e2 = i2.split(".").slice(-2).join(".");
  for (var r2 of it) if (e2 === r2) return false;
  return true;
}
function rt(t2, i2) {
  for (var e2 = 0; e2 < t2.length; e2++) if (i2(t2[e2])) return t2[e2];
}
function st(t2, i2, e2, r2) {
  var { capture: s2 = false, passive: n2 = true } = null != r2 ? r2 : {};
  null == t2 || t2.addEventListener(i2, e2, { capture: s2, passive: n2 });
}
var nt = "$people_distinct_id", ot = "__alias", at = "__timers", lt = "$autocapture_disabled_server_side", ut = "$heatmaps_enabled_server_side", ht = "$exception_capture_enabled_server_side", dt = "$error_tracking_suppression_rules", vt = "$web_vitals_enabled_server_side", ct = "$dead_clicks_enabled_server_side", ft = "$web_vitals_allowed_metrics", pt = "$session_recording_enabled_server_side", gt = "$console_log_recording_enabled_server_side", _t = "$session_recording_network_payload_capture", mt = "$session_recording_masking", bt = "$session_recording_canvas_recording", yt = "$replay_sample_rate", wt = "$replay_minimum_duration", St = "$replay_script_config", $t = "$sesid", kt = "$session_is_sampled", xt = "$session_recording_url_trigger_activated_session", Et = "$session_recording_event_trigger_activated_session", It = "$enabled_feature_flags", Pt = "$early_access_features", Rt = "$feature_flag_details", Tt = "$stored_person_properties", Mt = "$stored_group_properties", Ct = "$surveys", Ft = "$surveys_activated", Ot = "$flag_call_reported", At = "$user_state", Dt = "$client_session_props", Lt = "$capture_rate_limit", jt = "$initial_campaign_params", Nt = "$initial_referrer_info", zt = "$initial_person_info", Ut = "$epp", qt = "__POSTHOG_TOOLBAR__", Bt = "$posthog_cookieless", Ht = [nt, ot, "__cmpns", at, pt, ut, $t, It, dt, At, Pt, Rt, Mt, Tt, Ct, Ot, Dt, Lt, jt, Nt, Ut, zt];
function Wt(t2) {
  return t2 instanceof Element && (t2.id === qt || !(null == t2.closest || !t2.closest(".toolbar-global-fade-container")));
}
function Gt(t2) {
  return !!t2 && 1 === t2.nodeType;
}
function Jt(t2, i2) {
  return !!t2 && !!t2.tagName && t2.tagName.toLowerCase() === i2.toLowerCase();
}
function Vt(t2) {
  return !!t2 && 3 === t2.nodeType;
}
function Kt(t2) {
  return !!t2 && 11 === t2.nodeType;
}
function Yt(t2) {
  return t2 ? b(t2).split(/\s+/) : [];
}
function Xt(i2) {
  var e2 = null == t ? void 0 : t.location.href;
  return !!(e2 && i2 && i2.some((t2) => e2.match(t2)));
}
function Qt(t2) {
  var i2 = "";
  switch (typeof t2.className) {
    case "string":
      i2 = t2.className;
      break;
    case "object":
      i2 = (t2.className && "baseVal" in t2.className ? t2.className.baseVal : null) || t2.getAttribute("class") || "";
      break;
    default:
      i2 = "";
  }
  return Yt(i2);
}
function Zt(t2) {
  return F$1(t2) ? null : b(t2).split(/(\s+)/).filter((t3) => ci(t3)).join("").replace(/[\r\n]/g, " ").replace(/[ ]+/g, " ").substring(0, 255);
}
function ti(t2) {
  var i2 = "";
  return ni(t2) && !oi(t2) && t2.childNodes && t2.childNodes.length && J(t2.childNodes, function(t3) {
    var e2;
    Vt(t3) && t3.textContent && (i2 += null !== (e2 = Zt(t3.textContent)) && void 0 !== e2 ? e2 : "");
  }), b(i2);
}
function ii(t2) {
  return R(t2.target) ? t2.srcElement || null : null != (i2 = t2.target) && i2.shadowRoot ? t2.composedPath()[0] || null : t2.target || null;
  var i2;
}
var ei = ["a", "button", "form", "input", "select", "textarea", "label"];
function ri(t2) {
  var i2 = t2.parentNode;
  return !(!i2 || !Gt(i2)) && i2;
}
function si(i2, e2, r2, s2, n2) {
  var o2, a2, l2;
  if (void 0 === r2 && (r2 = void 0), !t || !i2 || Jt(i2, "html") || !Gt(i2)) return false;
  if (null != (o2 = r2) && o2.url_allowlist && !Xt(r2.url_allowlist)) return false;
  if (null != (a2 = r2) && a2.url_ignorelist && Xt(r2.url_ignorelist)) return false;
  if (null != (l2 = r2) && l2.dom_event_allowlist) {
    var u2 = r2.dom_event_allowlist;
    if (u2 && !u2.some((t2) => e2.type === t2)) return false;
  }
  for (var h2 = false, d2 = [i2], v2 = true, c2 = i2; c2.parentNode && !Jt(c2, "body"); ) if (Kt(c2.parentNode)) d2.push(c2.parentNode.host), c2 = c2.parentNode.host;
  else {
    if (!(v2 = ri(c2))) break;
    if (s2 || ei.indexOf(v2.tagName.toLowerCase()) > -1) h2 = true;
    else {
      var f2 = t.getComputedStyle(v2);
      f2 && "pointer" === f2.getPropertyValue("cursor") && (h2 = true);
    }
    d2.push(v2), c2 = v2;
  }
  if (!function(t2, i3) {
    var e3 = null == i3 ? void 0 : i3.element_allowlist;
    if (R(e3)) return true;
    var r3, s3 = function(t3) {
      if (e3.some((i4) => t3.tagName.toLowerCase() === i4)) return { v: true };
    };
    for (var n3 of t2) if (r3 = s3(n3)) return r3.v;
    return false;
  }(d2, r2)) return false;
  if (!function(t2, i3) {
    var e3 = null == i3 ? void 0 : i3.css_selector_allowlist;
    if (R(e3)) return true;
    var r3, s3 = function(t3) {
      if (e3.some((i4) => t3.matches(i4))) return { v: true };
    };
    for (var n3 of t2) if (r3 = s3(n3)) return r3.v;
    return false;
  }(d2, r2)) return false;
  var p2 = t.getComputedStyle(i2);
  if (p2 && "pointer" === p2.getPropertyValue("cursor") && "click" === e2.type) return true;
  var g2 = i2.tagName.toLowerCase();
  switch (g2) {
    case "html":
      return false;
    case "form":
      return (n2 || ["submit"]).indexOf(e2.type) >= 0;
    case "input":
    case "select":
    case "textarea":
      return (n2 || ["change", "click"]).indexOf(e2.type) >= 0;
    default:
      return h2 ? (n2 || ["click"]).indexOf(e2.type) >= 0 : (n2 || ["click"]).indexOf(e2.type) >= 0 && (ei.indexOf(g2) > -1 || "true" === i2.getAttribute("contenteditable"));
  }
}
function ni(t2) {
  for (var i2 = t2; i2.parentNode && !Jt(i2, "body"); i2 = i2.parentNode) {
    var e2 = Qt(i2);
    if (m(e2, "ph-sensitive") || m(e2, "ph-no-capture")) return false;
  }
  if (m(Qt(t2), "ph-include")) return true;
  var r2 = t2.type || "";
  if (T(r2)) switch (r2.toLowerCase()) {
    case "hidden":
    case "password":
      return false;
  }
  var s2 = t2.name || t2.id || "";
  if (T(s2)) {
    if (/^cc|cardnum|ccnum|creditcard|csc|cvc|cvv|exp|pass|pwd|routing|seccode|securitycode|securitynum|socialsec|socsec|ssn/i.test(s2.replace(/[^a-zA-Z0-9]/g, ""))) return false;
  }
  return true;
}
function oi(t2) {
  return !!(Jt(t2, "input") && !["button", "checkbox", "submit", "reset"].includes(t2.type) || Jt(t2, "select") || Jt(t2, "textarea") || "true" === t2.getAttribute("contenteditable"));
}
var ai = "(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11})", li = new RegExp("^(?:" + ai + ")$"), ui = new RegExp(ai), hi = "\\d{3}-?\\d{2}-?\\d{4}", di = new RegExp("^(" + hi + ")$"), vi = new RegExp("(" + hi + ")");
function ci(t2, i2) {
  if (void 0 === i2 && (i2 = true), F$1(t2)) return false;
  if (T(t2)) {
    if (t2 = b(t2), (i2 ? li : ui).test((t2 || "").replace(/[- ]/g, ""))) return false;
    if ((i2 ? di : vi).test(t2)) return false;
  }
  return true;
}
function fi(t2) {
  var i2 = ti(t2);
  return ci(i2 = (i2 + " " + pi(t2)).trim()) ? i2 : "";
}
function pi(t2) {
  var i2 = "";
  return t2 && t2.childNodes && t2.childNodes.length && J(t2.childNodes, function(t3) {
    var e2;
    if (t3 && "span" === (null == (e2 = t3.tagName) ? void 0 : e2.toLowerCase())) try {
      var r2 = ti(t3);
      i2 = (i2 + " " + r2).trim(), t3.childNodes && t3.childNodes.length && (i2 = (i2 + " " + pi(t3)).trim());
    } catch (t4) {
      N.error("[AutoCapture]", t4);
    }
  }), i2;
}
function gi(t2) {
  return function(t3) {
    var i2 = t3.map((t4) => {
      var i3, e2, r2 = "";
      if (t4.tag_name && (r2 += t4.tag_name), t4.attr_class) for (var s2 of (t4.attr_class.sort(), t4.attr_class)) r2 += "." + s2.replace(/"/g, "");
      var n2 = B$1({}, t4.text ? { text: t4.text } : {}, { "nth-child": null !== (i3 = t4.nth_child) && void 0 !== i3 ? i3 : 0, "nth-of-type": null !== (e2 = t4.nth_of_type) && void 0 !== e2 ? e2 : 0 }, t4.href ? { href: t4.href } : {}, t4.attr_id ? { attr_id: t4.attr_id } : {}, t4.attributes), o2 = {};
      return Y(n2).sort((t5, i4) => {
        var [e3] = t5, [r3] = i4;
        return e3.localeCompare(r3);
      }).forEach((t5) => {
        var [i4, e3] = t5;
        return o2[_i(i4.toString())] = _i(e3.toString());
      }), r2 += ":", r2 += Y(o2).map((t5) => {
        var [i4, e3] = t5;
        return i4 + '="' + e3 + '"';
      }).join("");
    });
    return i2.join(";");
  }(function(t3) {
    return t3.map((t4) => {
      var i2, e2, r2 = { text: null == (i2 = t4.$el_text) ? void 0 : i2.slice(0, 400), tag_name: t4.tag_name, href: null == (e2 = t4.attr__href) ? void 0 : e2.slice(0, 2048), attr_class: mi(t4), attr_id: t4.attr__id, nth_child: t4.nth_child, nth_of_type: t4.nth_of_type, attributes: {} };
      return Y(t4).filter((t5) => {
        var [i3] = t5;
        return 0 === i3.indexOf("attr__");
      }).forEach((t5) => {
        var [i3, e3] = t5;
        return r2.attributes[i3] = e3;
      }), r2;
    });
  }(t2));
}
function _i(t2) {
  return t2.replace(/"|\\"/g, '\\"');
}
function mi(t2) {
  var i2 = t2.attr__class;
  return i2 ? x(i2) ? i2 : Yt(i2) : void 0;
}
class bi {
  constructor() {
    this.clicks = [];
  }
  isRageClick(t2, i2, e2) {
    var r2 = this.clicks[this.clicks.length - 1];
    if (r2 && Math.abs(t2 - r2.x) + Math.abs(i2 - r2.y) < 30 && e2 - r2.timestamp < 1e3) {
      if (this.clicks.push({ x: t2, y: i2, timestamp: e2 }), 3 === this.clicks.length) return true;
    } else this.clicks = [{ x: t2, y: i2, timestamp: e2 }];
    return false;
  }
}
var yi = ["localhost", "127.0.0.1"], wi = (t2) => {
  var i2 = null == o ? void 0 : o.createElement("a");
  return R(i2) ? null : (i2.href = t2, i2);
}, Si = function(t2, i2) {
  var e2, r2;
  void 0 === i2 && (i2 = "&");
  var s2 = [];
  return J(t2, function(t3, i3) {
    R(t3) || R(i3) || "undefined" === i3 || (e2 = encodeURIComponent(((t4) => t4 instanceof File)(t3) ? t3.name : t3.toString()), r2 = encodeURIComponent(i3), s2[s2.length] = r2 + "=" + e2);
  }), s2.join(i2);
}, $i = function(t2, i2) {
  for (var e2, r2 = ((t2.split("#")[0] || "").split(/\?(.*)/)[1] || "").replace(/^\?+/g, "").split("&"), s2 = 0; s2 < r2.length; s2++) {
    var n2 = r2[s2].split("=");
    if (n2[0] === i2) {
      e2 = n2;
      break;
    }
  }
  if (!x(e2) || e2.length < 2) return "";
  var o2 = e2[1];
  try {
    o2 = decodeURIComponent(o2);
  } catch (t3) {
    N.error("Skipping decoding for malformed query param: " + o2);
  }
  return o2.replace(/\+/g, " ");
}, ki = function(t2, i2, e2) {
  if (!t2 || !i2 || !i2.length) return t2;
  for (var r2 = t2.split("#"), s2 = r2[0] || "", n2 = r2[1], o2 = s2.split("?"), a2 = o2[1], l2 = o2[0], u2 = (a2 || "").split("&"), h2 = [], d2 = 0; d2 < u2.length; d2++) {
    var v2 = u2[d2].split("=");
    x(v2) && (i2.includes(v2[0]) ? h2.push(v2[0] + "=" + e2) : h2.push(u2[d2]));
  }
  var c2 = l2;
  return null != a2 && (c2 += "?" + h2.join("&")), null != n2 && (c2 += "#" + n2), c2;
}, xi = function(t2, i2) {
  var e2 = t2.match(new RegExp(i2 + "=([^&]*)"));
  return e2 ? e2[1] : null;
}, Ei = z("[AutoCapture]");
function Ii(t2, i2) {
  return i2.length > t2 ? i2.slice(0, t2) + "..." : i2;
}
function Pi(t2) {
  if (t2.previousElementSibling) return t2.previousElementSibling;
  var i2 = t2;
  do {
    i2 = i2.previousSibling;
  } while (i2 && !Gt(i2));
  return i2;
}
function Ri(t2, i2, e2, r2) {
  var s2 = t2.tagName.toLowerCase(), n2 = { tag_name: s2 };
  ei.indexOf(s2) > -1 && !e2 && ("a" === s2.toLowerCase() || "button" === s2.toLowerCase() ? n2.$el_text = Ii(1024, fi(t2)) : n2.$el_text = Ii(1024, ti(t2)));
  var o2 = Qt(t2);
  o2.length > 0 && (n2.classes = o2.filter(function(t3) {
    return "" !== t3;
  })), J(t2.attributes, function(e3) {
    var s3;
    if ((!oi(t2) || -1 !== ["name", "id", "class", "aria-label"].indexOf(e3.name)) && ((null == r2 || !r2.includes(e3.name)) && !i2 && ci(e3.value) && (s3 = e3.name, !T(s3) || "_ngcontent" !== s3.substring(0, 10) && "_nghost" !== s3.substring(0, 7)))) {
      var o3 = e3.value;
      "class" === e3.name && (o3 = Yt(o3).join(" ")), n2["attr__" + e3.name] = Ii(1024, o3);
    }
  });
  for (var a2 = 1, l2 = 1, u2 = t2; u2 = Pi(u2); ) a2++, u2.tagName === t2.tagName && l2++;
  return n2.nth_child = a2, n2.nth_of_type = l2, n2;
}
function Ti(i2, e2) {
  for (var r2, s2, { e: n2, maskAllElementAttributes: o2, maskAllText: a2, elementAttributeIgnoreList: l2, elementsChainAsString: u2 } = e2, h2 = [i2], d2 = i2; d2.parentNode && !Jt(d2, "body"); ) Kt(d2.parentNode) ? (h2.push(d2.parentNode.host), d2 = d2.parentNode.host) : (h2.push(d2.parentNode), d2 = d2.parentNode);
  var v2, c2 = [], f2 = {}, p2 = false, g2 = false;
  if (J(h2, (t2) => {
    var i3 = ni(t2);
    "a" === t2.tagName.toLowerCase() && (p2 = t2.getAttribute("href"), p2 = i3 && p2 && ci(p2) && p2), m(Qt(t2), "ph-no-capture") && (g2 = true), c2.push(Ri(t2, o2, a2, l2));
    var e3 = function(t3) {
      if (!ni(t3)) return {};
      var i4 = {};
      return J(t3.attributes, function(t4) {
        if (t4.name && 0 === t4.name.indexOf("data-ph-capture-attribute")) {
          var e4 = t4.name.replace("data-ph-capture-attribute-", ""), r3 = t4.value;
          e4 && r3 && ci(r3) && (i4[e4] = r3);
        }
      }), i4;
    }(t2);
    V(f2, e3);
  }), g2) return { props: {}, explicitNoCapture: g2 };
  if (a2 || ("a" === i2.tagName.toLowerCase() || "button" === i2.tagName.toLowerCase() ? c2[0].$el_text = fi(i2) : c2[0].$el_text = ti(i2)), p2) {
    var _2, b2;
    c2[0].attr__href = p2;
    var y2 = null == (_2 = wi(p2)) ? void 0 : _2.host, w2 = null == t || null == (b2 = t.location) ? void 0 : b2.host;
    y2 && w2 && y2 !== w2 && (v2 = p2);
  }
  return { props: V({ $event_type: n2.type, $ce_version: 1 }, u2 ? {} : { $elements: c2 }, { $elements_chain: gi(c2) }, null != (r2 = c2[0]) && r2.$el_text ? { $el_text: null == (s2 = c2[0]) ? void 0 : s2.$el_text } : {}, v2 && "click" === n2.type ? { $external_click_url: v2 } : {}, f2) };
}
class Mi {
  constructor(t2) {
    this.i = false, this.o = null, this.rageclicks = new bi(), this.h = false, this.instance = t2, this.m = null;
  }
  get S() {
    var t2, i2, e2 = I$1(this.instance.config.autocapture) ? this.instance.config.autocapture : {};
    return e2.url_allowlist = null == (t2 = e2.url_allowlist) ? void 0 : t2.map((t3) => new RegExp(t3)), e2.url_ignorelist = null == (i2 = e2.url_ignorelist) ? void 0 : i2.map((t3) => new RegExp(t3)), e2;
  }
  $() {
    if (this.isBrowserSupported()) {
      if (t && o) {
        var i2 = (i3) => {
          i3 = i3 || (null == t ? void 0 : t.event);
          try {
            this.k(i3);
          } catch (t2) {
            Ei.error("Failed to capture event", t2);
          }
        };
        if (st(o, "submit", i2, { capture: true }), st(o, "change", i2, { capture: true }), st(o, "click", i2, { capture: true }), this.S.capture_copied_text) {
          var e2 = (i3) => {
            i3 = i3 || (null == t ? void 0 : t.event), this.k(i3, f);
          };
          st(o, "copy", e2, { capture: true }), st(o, "cut", e2, { capture: true });
        }
      }
    } else Ei.info("Disabling Automatic Event Collection because this browser is not supported");
  }
  startIfEnabled() {
    this.isEnabled && !this.i && (this.$(), this.i = true);
  }
  onRemoteConfig(t2) {
    t2.elementsChainAsString && (this.h = t2.elementsChainAsString), this.instance.persistence && this.instance.persistence.register({ [lt]: !!t2.autocapture_opt_out }), this.o = !!t2.autocapture_opt_out, this.startIfEnabled();
  }
  setElementSelectors(t2) {
    this.m = t2;
  }
  getElementSelectors(t2) {
    var i2, e2 = [];
    return null == (i2 = this.m) || i2.forEach((i3) => {
      var r2 = null == o ? void 0 : o.querySelectorAll(i3);
      null == r2 || r2.forEach((r3) => {
        t2 === r3 && e2.push(i3);
      });
    }), e2;
  }
  get isEnabled() {
    var t2, i2, e2 = null == (t2 = this.instance.persistence) ? void 0 : t2.props[lt], r2 = this.o;
    if (C(r2) && !A(e2) && !this.instance.I()) return false;
    var s2 = null !== (i2 = this.o) && void 0 !== i2 ? i2 : !!e2;
    return !!this.instance.config.autocapture && !s2;
  }
  k(i2, e2) {
    if (void 0 === e2 && (e2 = "$autocapture"), this.isEnabled) {
      var r2, s2 = ii(i2);
      if (Vt(s2) && (s2 = s2.parentNode || null), "$autocapture" === e2 && "click" === i2.type && i2 instanceof MouseEvent) this.instance.config.rageclick && null != (r2 = this.rageclicks) && r2.isRageClick(i2.clientX, i2.clientY, (/* @__PURE__ */ new Date()).getTime()) && this.k(i2, "$rageclick");
      var n2 = e2 === f;
      if (s2 && si(s2, i2, this.S, n2, n2 ? ["copy", "cut"] : void 0)) {
        var { props: o2, explicitNoCapture: a2 } = Ti(s2, { e: i2, maskAllElementAttributes: this.instance.config.mask_all_element_attributes, maskAllText: this.instance.config.mask_all_text, elementAttributeIgnoreList: this.S.element_attribute_ignorelist, elementsChainAsString: this.h });
        if (a2) return false;
        var l2 = this.getElementSelectors(s2);
        if (l2 && l2.length > 0 && (o2.$element_selectors = l2), e2 === f) {
          var u2, h2 = Zt(null == t || null == (u2 = t.getSelection()) ? void 0 : u2.toString()), d2 = i2.type || "clipboard";
          if (!h2) return false;
          o2.$selected_content = h2, o2.$copy_type = d2;
        }
        return this.instance.capture(e2, o2), true;
      }
    }
  }
  isBrowserSupported() {
    return E(null == o ? void 0 : o.querySelectorAll);
  }
}
Math.trunc || (Math.trunc = function(t2) {
  return t2 < 0 ? Math.ceil(t2) : Math.floor(t2);
}), Number.isInteger || (Number.isInteger = function(t2) {
  return O(t2) && isFinite(t2) && Math.floor(t2) === t2;
});
var Ci = "0123456789abcdef";
class Fi {
  constructor(t2) {
    if (this.bytes = t2, 16 !== t2.length) throw new TypeError("not 128-bit length");
  }
  static fromFieldsV7(t2, i2, e2, r2) {
    if (!Number.isInteger(t2) || !Number.isInteger(i2) || !Number.isInteger(e2) || !Number.isInteger(r2) || t2 < 0 || i2 < 0 || e2 < 0 || r2 < 0 || t2 > 281474976710655 || i2 > 4095 || e2 > 1073741823 || r2 > 4294967295) throw new RangeError("invalid field value");
    var s2 = new Uint8Array(16);
    return s2[0] = t2 / Math.pow(2, 40), s2[1] = t2 / Math.pow(2, 32), s2[2] = t2 / Math.pow(2, 24), s2[3] = t2 / Math.pow(2, 16), s2[4] = t2 / Math.pow(2, 8), s2[5] = t2, s2[6] = 112 | i2 >>> 8, s2[7] = i2, s2[8] = 128 | e2 >>> 24, s2[9] = e2 >>> 16, s2[10] = e2 >>> 8, s2[11] = e2, s2[12] = r2 >>> 24, s2[13] = r2 >>> 16, s2[14] = r2 >>> 8, s2[15] = r2, new Fi(s2);
  }
  toString() {
    for (var t2 = "", i2 = 0; i2 < this.bytes.length; i2++) t2 = t2 + Ci.charAt(this.bytes[i2] >>> 4) + Ci.charAt(15 & this.bytes[i2]), 3 !== i2 && 5 !== i2 && 7 !== i2 && 9 !== i2 || (t2 += "-");
    if (36 !== t2.length) throw new Error("Invalid UUIDv7 was generated");
    return t2;
  }
  clone() {
    return new Fi(this.bytes.slice(0));
  }
  equals(t2) {
    return 0 === this.compareTo(t2);
  }
  compareTo(t2) {
    for (var i2 = 0; i2 < 16; i2++) {
      var e2 = this.bytes[i2] - t2.bytes[i2];
      if (0 !== e2) return Math.sign(e2);
    }
    return 0;
  }
}
class Oi {
  constructor() {
    this.P = 0, this.R = 0, this.T = new Li();
  }
  generate() {
    var t2 = this.generateOrAbort();
    if (R(t2)) {
      this.P = 0;
      var i2 = this.generateOrAbort();
      if (R(i2)) throw new Error("Could not generate UUID after timestamp reset");
      return i2;
    }
    return t2;
  }
  generateOrAbort() {
    var t2 = Date.now();
    if (t2 > this.P) this.P = t2, this.M();
    else {
      if (!(t2 + 1e4 > this.P)) return;
      this.R++, this.R > 4398046511103 && (this.P++, this.M());
    }
    return Fi.fromFieldsV7(this.P, Math.trunc(this.R / Math.pow(2, 30)), this.R & Math.pow(2, 30) - 1, this.T.nextUint32());
  }
  M() {
    this.R = 1024 * this.T.nextUint32() + (1023 & this.T.nextUint32());
  }
}
var Ai, Di = (t2) => {
  if ("undefined" != typeof UUIDV7_DENY_WEAK_RNG && UUIDV7_DENY_WEAK_RNG) throw new Error("no cryptographically strong RNG available");
  for (var i2 = 0; i2 < t2.length; i2++) t2[i2] = 65536 * Math.trunc(65536 * Math.random()) + Math.trunc(65536 * Math.random());
  return t2;
};
t && !R(t.crypto) && crypto.getRandomValues && (Di = (t2) => crypto.getRandomValues(t2));
class Li {
  constructor() {
    this.C = new Uint32Array(8), this.F = 1 / 0;
  }
  nextUint32() {
    return this.F >= this.C.length && (Di(this.C), this.F = 0), this.C[this.F++];
  }
}
var ji = () => Ni().toString(), Ni = () => (Ai || (Ai = new Oi())).generate(), zi = "";
var Ui = /[a-z0-9][a-z0-9-]+\.[a-z]{2,}$/i;
function qi(t2, i2) {
  if (i2) {
    var e2 = function(t3, i3) {
      if (void 0 === i3 && (i3 = o), zi) return zi;
      if (!i3) return "";
      if (["localhost", "127.0.0.1"].includes(t3)) return "";
      for (var e3 = t3.split("."), r3 = Math.min(e3.length, 8), s2 = "dmn_chk_" + ji(); !zi && r3--; ) {
        var n2 = e3.slice(r3).join("."), a2 = s2 + "=1;domain=." + n2 + ";path=/";
        i3.cookie = a2 + ";max-age=3", i3.cookie.includes(s2) && (i3.cookie = a2 + ";max-age=0", zi = n2);
      }
      return zi;
    }(t2);
    if (!e2) {
      var r2 = ((t3) => {
        var i3 = t3.match(Ui);
        return i3 ? i3[0] : "";
      })(t2);
      r2 !== e2 && N.info("Warning: cookie subdomain discovery mismatch", r2, e2), e2 = r2;
    }
    return e2 ? "; domain=." + e2 : "";
  }
  return "";
}
var Bi = { O: () => !!o, A: function(t2) {
  N.error("cookieStore error: " + t2);
}, D: function(t2) {
  if (o) {
    try {
      for (var i2 = t2 + "=", e2 = o.cookie.split(";").filter((t3) => t3.length), r2 = 0; r2 < e2.length; r2++) {
        for (var s2 = e2[r2]; " " == s2.charAt(0); ) s2 = s2.substring(1, s2.length);
        if (0 === s2.indexOf(i2)) return decodeURIComponent(s2.substring(i2.length, s2.length));
      }
    } catch (t3) {
    }
    return null;
  }
}, L: function(t2) {
  var i2;
  try {
    i2 = JSON.parse(Bi.D(t2)) || {};
  } catch (t3) {
  }
  return i2;
}, j: function(t2, i2, e2, r2, s2) {
  if (o) try {
    var n2 = "", a2 = "", l2 = qi(o.location.hostname, r2);
    if (e2) {
      var u2 = /* @__PURE__ */ new Date();
      u2.setTime(u2.getTime() + 24 * e2 * 60 * 60 * 1e3), n2 = "; expires=" + u2.toUTCString();
    }
    s2 && (a2 = "; secure");
    var h2 = t2 + "=" + encodeURIComponent(JSON.stringify(i2)) + n2 + "; SameSite=Lax; path=/" + l2 + a2;
    return h2.length > 3686.4 && N.warn("cookieStore warning: large cookie, len=" + h2.length), o.cookie = h2, h2;
  } catch (t3) {
    return;
  }
}, N: function(t2, i2) {
  try {
    Bi.j(t2, "", -1, i2);
  } catch (t3) {
    return;
  }
} }, Hi = null, Wi = { O: function() {
  if (!C(Hi)) return Hi;
  var i2 = true;
  if (R(t)) i2 = false;
  else try {
    var e2 = "__mplssupport__";
    Wi.j(e2, "xyz"), '"xyz"' !== Wi.D(e2) && (i2 = false), Wi.N(e2);
  } catch (t2) {
    i2 = false;
  }
  return i2 || N.error("localStorage unsupported; falling back to cookie store"), Hi = i2, i2;
}, A: function(t2) {
  N.error("localStorage error: " + t2);
}, D: function(i2) {
  try {
    return null == t ? void 0 : t.localStorage.getItem(i2);
  } catch (t2) {
    Wi.A(t2);
  }
  return null;
}, L: function(t2) {
  try {
    return JSON.parse(Wi.D(t2)) || {};
  } catch (t3) {
  }
  return null;
}, j: function(i2, e2) {
  try {
    null == t || t.localStorage.setItem(i2, JSON.stringify(e2));
  } catch (t2) {
    Wi.A(t2);
  }
}, N: function(i2) {
  try {
    null == t || t.localStorage.removeItem(i2);
  } catch (t2) {
    Wi.A(t2);
  }
} }, Gi = ["distinct_id", $t, kt, Ut, zt], Ji = B$1({}, Wi, { L: function(t2) {
  try {
    var i2 = {};
    try {
      i2 = Bi.L(t2) || {};
    } catch (t3) {
    }
    var e2 = V(i2, JSON.parse(Wi.D(t2) || "{}"));
    return Wi.j(t2, e2), e2;
  } catch (t3) {
  }
  return null;
}, j: function(t2, i2, e2, r2, s2, n2) {
  try {
    Wi.j(t2, i2, void 0, void 0, n2);
    var o2 = {};
    Gi.forEach((t3) => {
      i2[t3] && (o2[t3] = i2[t3]);
    }), Object.keys(o2).length && Bi.j(t2, o2, e2, r2, s2, n2);
  } catch (t3) {
    Wi.A(t3);
  }
}, N: function(i2, e2) {
  try {
    null == t || t.localStorage.removeItem(i2), Bi.N(i2, e2);
  } catch (t2) {
    Wi.A(t2);
  }
} }), Vi = {}, Ki = { O: function() {
  return true;
}, A: function(t2) {
  N.error("memoryStorage error: " + t2);
}, D: function(t2) {
  return Vi[t2] || null;
}, L: function(t2) {
  return Vi[t2] || null;
}, j: function(t2, i2) {
  Vi[t2] = i2;
}, N: function(t2) {
  delete Vi[t2];
} }, Yi = null, Xi = { O: function() {
  if (!C(Yi)) return Yi;
  if (Yi = true, R(t)) Yi = false;
  else try {
    var i2 = "__support__";
    Xi.j(i2, "xyz"), '"xyz"' !== Xi.D(i2) && (Yi = false), Xi.N(i2);
  } catch (t2) {
    Yi = false;
  }
  return Yi;
}, A: function(t2) {
  N.error("sessionStorage error: ", t2);
}, D: function(i2) {
  try {
    return null == t ? void 0 : t.sessionStorage.getItem(i2);
  } catch (t2) {
    Xi.A(t2);
  }
  return null;
}, L: function(t2) {
  try {
    return JSON.parse(Xi.D(t2)) || null;
  } catch (t3) {
  }
  return null;
}, j: function(i2, e2) {
  try {
    null == t || t.sessionStorage.setItem(i2, JSON.stringify(e2));
  } catch (t2) {
    Xi.A(t2);
  }
}, N: function(i2) {
  try {
    null == t || t.sessionStorage.removeItem(i2);
  } catch (t2) {
    Xi.A(t2);
  }
} }, Qi = function(t2) {
  return t2[t2.PENDING = -1] = "PENDING", t2[t2.DENIED = 0] = "DENIED", t2[t2.GRANTED = 1] = "GRANTED", t2;
}({});
class Zi {
  constructor(t2) {
    this._instance = t2;
  }
  get S() {
    return this._instance.config;
  }
  get consent() {
    return this.U() ? Qi.DENIED : this.q;
  }
  isOptedOut() {
    return this.consent === Qi.DENIED || this.consent === Qi.PENDING && this.S.opt_out_capturing_by_default;
  }
  isOptedIn() {
    return !this.isOptedOut();
  }
  optInOut(t2) {
    this.B.j(this.H, t2 ? 1 : 0, this.S.cookie_expiration, this.S.cross_subdomain_cookie, this.S.secure_cookie);
  }
  reset() {
    this.B.N(this.H, this.S.cross_subdomain_cookie);
  }
  get H() {
    var { token: t2, opt_out_capturing_cookie_prefix: i2 } = this._instance.config;
    return (i2 || "__ph_opt_in_out_") + t2;
  }
  get q() {
    var t2 = this.B.D(this.H);
    return "1" === t2 ? Qi.GRANTED : "0" === t2 ? Qi.DENIED : Qi.PENDING;
  }
  get B() {
    if (!this.W) {
      var t2 = this.S.opt_out_capturing_persistence_type;
      this.W = "localStorage" === t2 ? Wi : Bi;
      var i2 = "localStorage" === t2 ? Bi : Wi;
      i2.D(this.H) && (this.W.D(this.H) || this.optInOut("1" === i2.D(this.H)), i2.N(this.H, this.S.cross_subdomain_cookie));
    }
    return this.W;
  }
  U() {
    return !!this.S.respect_dnt && !!rt([null == n ? void 0 : n.doNotTrack, null == n ? void 0 : n.msDoNotTrack, v.doNotTrack], (t2) => m([true, 1, "1", "yes"], t2));
  }
}
var te = z("[Dead Clicks]"), ie$1 = () => true, ee = (t2) => {
  var i2, e2 = !(null == (i2 = t2.instance.persistence) || !i2.get_property(ct)), r2 = t2.instance.config.capture_dead_clicks;
  return A(r2) ? r2 : e2;
};
let re$1 = class re {
  get lazyLoadedDeadClicksAutocapture() {
    return this.G;
  }
  constructor(t2, i2, e2) {
    this.instance = t2, this.isEnabled = i2, this.onCapture = e2, this.startIfEnabled();
  }
  onRemoteConfig(t2) {
    this.instance.persistence && this.instance.persistence.register({ [ct]: null == t2 ? void 0 : t2.captureDeadClicks }), this.startIfEnabled();
  }
  startIfEnabled() {
    this.isEnabled(this) && this.J(() => {
      this.V();
    });
  }
  J(t2) {
    var i2, e2;
    null != (i2 = v.__PosthogExtensions__) && i2.initDeadClicksAutocapture && t2(), null == (e2 = v.__PosthogExtensions__) || null == e2.loadExternalDependency || e2.loadExternalDependency(this.instance, "dead-clicks-autocapture", (i3) => {
      i3 ? te.error("failed to load script", i3) : t2();
    });
  }
  V() {
    var t2;
    if (o) {
      if (!this.G && null != (t2 = v.__PosthogExtensions__) && t2.initDeadClicksAutocapture) {
        var i2 = I$1(this.instance.config.capture_dead_clicks) ? this.instance.config.capture_dead_clicks : {};
        i2.__onCapture = this.onCapture, this.G = v.__PosthogExtensions__.initDeadClicksAutocapture(this.instance, i2), this.G.start(o), te.info("starting...");
      }
    } else te.error("`document` not found. Cannot start.");
  }
  stop() {
    this.G && (this.G.stop(), this.G = void 0, te.info("stopping..."));
  }
};
function se$1(t2, i2, e2, r2, s2) {
  return i2 > e2 && (N.warn("min cannot be greater than max."), i2 = e2), O(t2) ? t2 > e2 ? (r2 && N.warn(r2 + " cannot be  greater than max: " + e2 + ". Using max value instead."), e2) : t2 < i2 ? (r2 && N.warn(r2 + " cannot be less than min: " + i2 + ". Using min value instead."), i2) : t2 : (r2 && N.warn(r2 + " must be a number. using max or fallback. max: " + e2 + ", fallback: " + s2), se$1(s2 || e2, i2, e2, r2));
}
class ne {
  constructor(t2) {
    this.K = {}, this.Y = () => {
      Object.keys(this.K).forEach((t3) => {
        var i2 = this.X(t3) + this.Z;
        i2 >= this.tt ? delete this.K[t3] : this.it(t3, i2);
      });
    }, this.X = (t3) => this.K[String(t3)], this.it = (t3, i2) => {
      this.K[String(t3)] = i2;
    }, this.consumeRateLimit = (t3) => {
      var i2, e2 = null !== (i2 = this.X(t3)) && void 0 !== i2 ? i2 : this.tt;
      if (0 === (e2 = Math.max(e2 - 1, 0))) return true;
      this.it(t3, e2);
      var r2, s2 = 0 === e2;
      s2 && (null == (r2 = this.et) || r2.call(this, t3));
      return s2;
    }, this.rt = t2, this.et = this.rt.et, this.tt = se$1(this.rt.bucketSize, 0, 100, "rate limiter bucket size"), this.Z = se$1(this.rt.refillRate, 0, this.tt, "rate limiter refill rate"), this.st = se$1(this.rt.refillInterval, 0, 864e5, "rate limiter refill interval"), setInterval(() => {
      this.Y();
    }, this.st);
  }
}
var oe$1 = z("[ExceptionAutocapture]");
let ae$1 = class ae {
  constructor(i2) {
    var e2, r2, s2;
    this.nt = () => {
      var i3;
      if (t && this.isEnabled && null != (i3 = v.__PosthogExtensions__) && i3.errorWrappingFunctions) {
        var e3 = v.__PosthogExtensions__.errorWrappingFunctions.wrapOnError, r3 = v.__PosthogExtensions__.errorWrappingFunctions.wrapUnhandledRejection, s3 = v.__PosthogExtensions__.errorWrappingFunctions.wrapConsoleError;
        try {
          !this.ot && this.S.capture_unhandled_errors && (this.ot = e3(this.captureException.bind(this))), !this.lt && this.S.capture_unhandled_rejections && (this.lt = r3(this.captureException.bind(this))), !this.ut && this.S.capture_console_errors && (this.ut = s3(this.captureException.bind(this)));
        } catch (t2) {
          oe$1.error("failed to start", t2), this.ht();
        }
      }
    }, this._instance = i2, this.dt = !(null == (e2 = this._instance.persistence) || !e2.props[ht]), this.S = this.vt(), this.ct = new ne({ refillRate: null !== (r2 = this._instance.config.error_tracking.__exceptionRateLimiterRefillRate) && void 0 !== r2 ? r2 : 1, bucketSize: null !== (s2 = this._instance.config.error_tracking.__exceptionRateLimiterBucketSize) && void 0 !== s2 ? s2 : 10, refillInterval: 1e4 }), this.startIfEnabled();
  }
  vt() {
    var t2 = this._instance.config.capture_exceptions, i2 = { capture_unhandled_errors: false, capture_unhandled_rejections: false, capture_console_errors: false };
    return I$1(t2) ? i2 = B$1({}, i2, t2) : (R(t2) ? this.dt : t2) && (i2 = B$1({}, i2, { capture_unhandled_errors: true, capture_unhandled_rejections: true })), i2;
  }
  get isEnabled() {
    return this.S.capture_console_errors || this.S.capture_unhandled_errors || this.S.capture_unhandled_rejections;
  }
  startIfEnabled() {
    this.isEnabled && (oe$1.info("enabled"), this.J(this.nt));
  }
  J(t2) {
    var i2, e2;
    null != (i2 = v.__PosthogExtensions__) && i2.errorWrappingFunctions && t2(), null == (e2 = v.__PosthogExtensions__) || null == e2.loadExternalDependency || e2.loadExternalDependency(this._instance, "exception-autocapture", (i3) => {
      if (i3) return oe$1.error("failed to load script", i3);
      t2();
    });
  }
  ht() {
    var t2, i2, e2;
    null == (t2 = this.ot) || t2.call(this), this.ot = void 0, null == (i2 = this.lt) || i2.call(this), this.lt = void 0, null == (e2 = this.ut) || e2.call(this), this.ut = void 0;
  }
  onRemoteConfig(t2) {
    var i2 = t2.autocaptureExceptions;
    this.dt = !!i2 || false, this.S = this.vt(), this._instance.persistence && this._instance.persistence.register({ [ht]: this.dt }), this.startIfEnabled();
  }
  captureException(t2) {
    var i2, e2 = this._instance.requestRouter.endpointFor("ui");
    t2.$exception_personURL = e2 + "/project/" + this._instance.config.token + "/person/" + this._instance.get_distinct_id();
    var r2 = null !== (i2 = t2.$exception_list[0].type) && void 0 !== i2 ? i2 : "Exception";
    this.ct.consumeRateLimit(r2) ? oe$1.info("Skipping exception capture because of client rate limiting.", { exception: t2.$exception_list[0].type }) : this._instance.exceptions.sendExceptionEvent(t2);
  }
};
function le(t2) {
  return !R(Event) && ue(t2, Event);
}
function ue(t2, i2) {
  try {
    return t2 instanceof i2;
  } catch (t3) {
    return false;
  }
}
function he(t2) {
  switch (Object.prototype.toString.call(t2)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
    case "[object DOMError]":
      return true;
    default:
      return ue(t2, Error);
  }
}
function de(t2, i2) {
  return Object.prototype.toString.call(t2) === "[object " + i2 + "]";
}
function ve(t2) {
  return de(t2, "DOMError");
}
var ce = /\(error: (.*)\)/, fe = 50, pe = "?";
function ge(t2, i2, e2, r2) {
  var s2 = { platform: "web:javascript", filename: t2, function: "<anonymous>" === i2 ? pe : i2, in_app: true };
  return R(e2) || (s2.lineno = e2), R(r2) || (s2.colno = r2), s2;
}
var _e = /^\s*at (\S+?)(?::(\d+))(?::(\d+))\s*$/i, me = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i, be = /\((\S*)(?::(\d+))(?::(\d+))\)/, ye = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i, we = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i, Se = function() {
  for (var t2 = arguments.length, i2 = new Array(t2), e2 = 0; e2 < t2; e2++) i2[e2] = arguments[e2];
  var r2 = i2.sort((t3, i3) => t3[0] - i3[0]).map((t3) => t3[1]);
  return function(t3, i3) {
    void 0 === i3 && (i3 = 0);
    for (var e3 = [], s2 = t3.split("\n"), n2 = i3; n2 < s2.length; n2++) {
      var o2 = s2[n2];
      if (!(o2.length > 1024)) {
        var a2 = ce.test(o2) ? o2.replace(ce, "$1") : o2;
        if (!a2.match(/\S*Error: /)) {
          for (var l2 of r2) {
            var u2 = l2(a2);
            if (u2) {
              e3.push(u2);
              break;
            }
          }
          if (e3.length >= fe) break;
        }
      }
    }
    return function(t4) {
      if (!t4.length) return [];
      var i4 = Array.from(t4);
      return i4.reverse(), i4.slice(0, fe).map((t5) => B$1({}, t5, { filename: t5.filename || $e(i4).filename, function: t5.function || pe }));
    }(e3);
  };
}(...[[30, (t2) => {
  var i2 = _e.exec(t2);
  if (i2) {
    var [, e2, r2, s2] = i2;
    return ge(e2, pe, +r2, +s2);
  }
  var n2 = me.exec(t2);
  if (n2) {
    if (n2[2] && 0 === n2[2].indexOf("eval")) {
      var o2 = be.exec(n2[2]);
      o2 && (n2[2] = o2[1], n2[3] = o2[2], n2[4] = o2[3]);
    }
    var [a2, l2] = Ie(n2[1] || pe, n2[2]);
    return ge(l2, a2, n2[3] ? +n2[3] : void 0, n2[4] ? +n2[4] : void 0);
  }
}], [50, (t2) => {
  var i2 = ye.exec(t2);
  if (i2) {
    if (i2[3] && i2[3].indexOf(" > eval") > -1) {
      var e2 = we.exec(i2[3]);
      e2 && (i2[1] = i2[1] || "eval", i2[3] = e2[1], i2[4] = e2[2], i2[5] = "");
    }
    var r2 = i2[3], s2 = i2[1] || pe;
    return [s2, r2] = Ie(s2, r2), ge(r2, s2, i2[4] ? +i2[4] : void 0, i2[5] ? +i2[5] : void 0);
  }
}]]);
function $e(t2) {
  return t2[t2.length - 1] || {};
}
var ke, xe, Ee, Ie = (t2, i2) => {
  var e2 = -1 !== t2.indexOf("safari-extension"), r2 = -1 !== t2.indexOf("safari-web-extension");
  return e2 || r2 ? [-1 !== t2.indexOf("@") ? t2.split("@")[0] : pe, e2 ? "safari-extension:" + i2 : "safari-web-extension:" + i2] : [t2, i2];
};
var Pe = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;
function Re(t2, i2) {
  void 0 === i2 && (i2 = 0);
  var e2 = t2.stacktrace || t2.stack || "", r2 = function(t3) {
    if (t3 && Te$1.test(t3.message)) return 1;
    return 0;
  }(t2);
  try {
    var s2 = Se, n2 = function(t3, i3) {
      var e3 = function(t4) {
        var i4 = globalThis._posthogChunkIds;
        if (!i4) return {};
        var e4 = Object.keys(i4);
        return Ee && e4.length === xe || (xe = e4.length, Ee = e4.reduce((e5, r3) => {
          ke || (ke = {});
          var s3 = ke[r3];
          if (s3) e5[s3[0]] = s3[1];
          else for (var n3 = t4(r3), o2 = n3.length - 1; o2 >= 0; o2--) {
            var a2 = n3[o2], l2 = null == a2 ? void 0 : a2.filename, u2 = i4[r3];
            if (l2 && u2) {
              e5[l2] = u2, ke[r3] = [l2, u2];
              break;
            }
          }
          return e5;
        }, {})), Ee;
      }(i3);
      return t3.forEach((t4) => {
        t4.filename && (t4.chunk_id = e3[t4.filename]);
      }), t3;
    }(s2(e2, r2), s2);
    return n2.slice(0, n2.length - i2);
  } catch (t3) {
  }
  return [];
}
var Te$1 = /Minified React error #\d+;/i;
function Me$1(t2, i2) {
  var e2, r2, s2 = Re(t2), n2 = null === (e2 = null == i2 ? void 0 : i2.handled) || void 0 === e2 || e2, o2 = null !== (r2 = null == i2 ? void 0 : i2.synthetic) && void 0 !== r2 && r2;
  return { type: null != i2 && i2.overrideExceptionType ? i2.overrideExceptionType : t2.name, value: function(t3) {
    var i3 = t3.message;
    if (i3.error && "string" == typeof i3.error.message) return String(i3.error.message);
    return String(i3);
  }(t2), stacktrace: { frames: s2, type: "raw" }, mechanism: { handled: n2, synthetic: o2 } };
}
function Ce(t2, i2) {
  var e2 = Me$1(t2, i2);
  return t2.cause && he(t2.cause) && t2.cause !== t2 ? [e2, ...Ce(t2.cause, { handled: null == i2 ? void 0 : i2.handled, synthetic: null == i2 ? void 0 : i2.synthetic })] : [e2];
}
function Fe(t2, i2) {
  return { $exception_list: Ce(t2, i2), $exception_level: "error" };
}
function Oe(t2, i2) {
  var e2, r2, s2, n2 = null === (e2 = null == i2 ? void 0 : i2.handled) || void 0 === e2 || e2, o2 = null === (r2 = null == i2 ? void 0 : i2.synthetic) || void 0 === r2 || r2, a2 = { type: null != i2 && i2.overrideExceptionType ? i2.overrideExceptionType : null !== (s2 = null == i2 ? void 0 : i2.defaultExceptionType) && void 0 !== s2 ? s2 : "Error", value: t2 || (null == i2 ? void 0 : i2.defaultExceptionMessage), mechanism: { handled: n2, synthetic: o2 } };
  if (null != i2 && i2.syntheticException) {
    var l2 = Re(i2.syntheticException, 1);
    l2.length && (a2.stacktrace = { frames: l2, type: "raw" });
  }
  return { $exception_list: [a2], $exception_level: "error" };
}
function Ae(t2) {
  return T(t2) && !M(t2) && _.indexOf(t2) >= 0;
}
function De(t2, i2) {
  var e2, r2, s2 = null === (e2 = null == i2 ? void 0 : i2.handled) || void 0 === e2 || e2, n2 = null === (r2 = null == i2 ? void 0 : i2.synthetic) || void 0 === r2 || r2, o2 = null != i2 && i2.overrideExceptionType ? i2.overrideExceptionType : le(t2) ? t2.constructor.name : "Error", a2 = "Non-Error 'exception' captured with keys: " + function(t3, i3) {
    void 0 === i3 && (i3 = 40);
    var e3 = Object.keys(t3);
    if (e3.sort(), !e3.length) return "[object has no keys]";
    for (var r3 = e3.length; r3 > 0; r3--) {
      var s3 = e3.slice(0, r3).join(", ");
      if (!(s3.length > i3)) return r3 === e3.length || s3.length <= i3 ? s3 : s3.slice(0, i3) + "...";
    }
    return "";
  }(t2), l2 = { type: o2, value: a2, mechanism: { handled: s2, synthetic: n2 } };
  if (null != i2 && i2.syntheticException) {
    var u2 = Re(null == i2 ? void 0 : i2.syntheticException, 1);
    u2.length && (l2.stacktrace = { frames: u2, type: "raw" });
  }
  return { $exception_list: [l2], $exception_level: Ae(t2.level) ? t2.level : "error" };
}
function Le(t2, i2) {
  var { error: e2, event: r2 } = t2, s2 = { $exception_list: [] }, n2 = e2 || r2;
  if (ve(n2) || function(t3) {
    return de(t3, "DOMException");
  }(n2)) {
    var o2 = n2;
    if (function(t3) {
      return "stack" in t3;
    }(n2)) s2 = Fe(n2, i2);
    else {
      var a2 = o2.name || (ve(o2) ? "DOMError" : "DOMException"), l2 = o2.message ? a2 + ": " + o2.message : a2;
      s2 = Oe(l2, B$1({}, i2, { overrideExceptionType: ve(o2) ? "DOMError" : "DOMException", defaultExceptionMessage: l2 }));
    }
    return "code" in o2 && (s2.$exception_DOMException_code = "" + o2.code), s2;
  }
  if (function(t3) {
    return de(t3, "ErrorEvent");
  }(n2) && n2.error) return Fe(n2.error, i2);
  if (he(n2)) return Fe(n2, i2);
  if (function(t3) {
    return de(t3, "Object");
  }(n2) || le(n2)) return De(n2, i2);
  if (R(e2) && T(r2)) {
    var u2 = "Error", h2 = r2, d2 = r2.match(Pe);
    return d2 && (u2 = d2[1], h2 = d2[2]), Oe(h2, B$1({}, i2, { overrideExceptionType: u2, defaultExceptionMessage: h2 }));
  }
  return Oe(n2, i2);
}
function je(t2, i2, e2) {
  try {
    if (!(i2 in t2)) return () => {
    };
    var r2 = t2[i2], s2 = e2(r2);
    return E(s2) && (s2.prototype = s2.prototype || {}, Object.defineProperties(s2, { __posthog_wrapped__: { enumerable: false, value: true } })), t2[i2] = s2, () => {
      t2[i2] = r2;
    };
  } catch (t3) {
    return () => {
    };
  }
}
class Ne {
  constructor(i2) {
    var e2;
    this._instance = i2, this.ft = (null == t || null == (e2 = t.location) ? void 0 : e2.pathname) || "";
  }
  get isEnabled() {
    return "history_change" === this._instance.config.capture_pageview;
  }
  startIfEnabled() {
    this.isEnabled && (N.info("History API monitoring enabled, starting..."), this.monitorHistoryChanges());
  }
  stop() {
    this.gt && this.gt(), this.gt = void 0, N.info("History API monitoring stopped");
  }
  monitorHistoryChanges() {
    var i2, e2;
    if (t && t.history) {
      var r2 = this;
      null != (i2 = t.history.pushState) && i2.__posthog_wrapped__ || je(t.history, "pushState", (t2) => function(i3, e3, s2) {
        t2.call(this, i3, e3, s2), r2._t("pushState");
      }), null != (e2 = t.history.replaceState) && e2.__posthog_wrapped__ || je(t.history, "replaceState", (t2) => function(i3, e3, s2) {
        t2.call(this, i3, e3, s2), r2._t("replaceState");
      }), this.bt();
    }
  }
  _t(i2) {
    try {
      var e2, r2 = null == t || null == (e2 = t.location) ? void 0 : e2.pathname;
      if (!r2) return;
      r2 !== this.ft && this.isEnabled && this._instance.capture("$pageview", { navigation_type: i2 }), this.ft = r2;
    } catch (t2) {
      N.error("Error capturing " + i2 + " pageview", t2);
    }
  }
  bt() {
    if (!this.gt) {
      var i2 = () => {
        this._t("popstate");
      };
      st(t, "popstate", i2), this.gt = () => {
        t && t.removeEventListener("popstate", i2);
      };
    }
  }
}
function ze(t2) {
  var i2, e2;
  return (null == (i2 = JSON.stringify(t2, (e2 = [], function(t3, i3) {
    if (I$1(i3)) {
      for (; e2.length > 0 && e2[e2.length - 1] !== this; ) e2.pop();
      return e2.includes(i3) ? "[Circular]" : (e2.push(i3), i3);
    }
    return i3;
  }))) ? void 0 : i2.length) || 0;
}
function Ue(t2, i2) {
  if (void 0 === i2 && (i2 = 66060288e-1), t2.size >= i2 && t2.data.length > 1) {
    var e2 = Math.floor(t2.data.length / 2), r2 = t2.data.slice(0, e2), s2 = t2.data.slice(e2);
    return [Ue({ size: ze(r2), data: r2, sessionId: t2.sessionId, windowId: t2.windowId }), Ue({ size: ze(s2), data: s2, sessionId: t2.sessionId, windowId: t2.windowId })].flatMap((t3) => t3);
  }
  return [t2];
}
var qe = ((t2) => (t2[t2.DomContentLoaded = 0] = "DomContentLoaded", t2[t2.Load = 1] = "Load", t2[t2.FullSnapshot = 2] = "FullSnapshot", t2[t2.IncrementalSnapshot = 3] = "IncrementalSnapshot", t2[t2.Meta = 4] = "Meta", t2[t2.Custom = 5] = "Custom", t2[t2.Plugin = 6] = "Plugin", t2))(qe || {}), Be = ((t2) => (t2[t2.Mutation = 0] = "Mutation", t2[t2.MouseMove = 1] = "MouseMove", t2[t2.MouseInteraction = 2] = "MouseInteraction", t2[t2.Scroll = 3] = "Scroll", t2[t2.ViewportResize = 4] = "ViewportResize", t2[t2.Input = 5] = "Input", t2[t2.TouchMove = 6] = "TouchMove", t2[t2.MediaInteraction = 7] = "MediaInteraction", t2[t2.StyleSheetRule = 8] = "StyleSheetRule", t2[t2.CanvasMutation = 9] = "CanvasMutation", t2[t2.Font = 10] = "Font", t2[t2.Log = 11] = "Log", t2[t2.Drag = 12] = "Drag", t2[t2.StyleDeclaration = 13] = "StyleDeclaration", t2[t2.Selection = 14] = "Selection", t2[t2.AdoptedStyleSheet = 15] = "AdoptedStyleSheet", t2[t2.CustomElement = 16] = "CustomElement", t2))(Be || {}), He = "[SessionRecording]", We = "redacted", Ge = { initiatorTypes: ["audio", "beacon", "body", "css", "early-hint", "embed", "fetch", "frame", "iframe", "icon", "image", "img", "input", "link", "navigation", "object", "ping", "script", "track", "video", "xmlhttprequest"], maskRequestFn: (t2) => t2, recordHeaders: false, recordBody: false, recordInitialRequests: false, recordPerformance: false, performanceEntryTypeToObserve: ["first-input", "navigation", "paint", "resource"], payloadSizeLimitBytes: 1e6, payloadHostDenyList: [".lr-ingest.io", ".ingest.sentry.io", ".clarity.ms", "analytics.google.com", "bam.nr-data.net"] }, Je = ["authorization", "x-forwarded-for", "authorization", "cookie", "set-cookie", "x-api-key", "x-real-ip", "remote-addr", "forwarded", "proxy-authorization", "x-csrf-token", "x-csrftoken", "x-xsrf-token"], Ve = ["password", "secret", "passwd", "api_key", "apikey", "auth", "credentials", "mysql_pwd", "privatekey", "private_key", "token"], Ke = ["/s/", "/e/", "/i/"];
function Ye(t2, i2, e2, r2) {
  if (F$1(t2)) return t2;
  var s2 = (null == i2 ? void 0 : i2["content-length"]) || function(t3) {
    return new Blob([t3]).size;
  }(t2);
  return T(s2) && (s2 = parseInt(s2)), s2 > e2 ? He + " " + r2 + " body too large to record (" + s2 + " bytes)" : t2;
}
function Xe(t2, i2) {
  if (F$1(t2)) return t2;
  var e2 = t2;
  return ci(e2, false) || (e2 = He + " " + i2 + " body " + We), J(Ve, (t3) => {
    var r2, s2;
    null != (r2 = e2) && r2.length && -1 !== (null == (s2 = e2) ? void 0 : s2.indexOf(t3)) && (e2 = He + " " + i2 + " body " + We + " as might contain: " + t3);
  }), e2;
}
var Qe = (t2, i2) => {
  var e2, r2, s2, n2 = { payloadSizeLimitBytes: Ge.payloadSizeLimitBytes, performanceEntryTypeToObserve: [...Ge.performanceEntryTypeToObserve], payloadHostDenyList: [...i2.payloadHostDenyList || [], ...Ge.payloadHostDenyList] }, o2 = false !== t2.session_recording.recordHeaders && i2.recordHeaders, a2 = false !== t2.session_recording.recordBody && i2.recordBody, l2 = false !== t2.capture_performance && i2.recordPerformance, u2 = (e2 = n2, s2 = Math.min(1e6, null !== (r2 = e2.payloadSizeLimitBytes) && void 0 !== r2 ? r2 : 1e6), (t3) => (null != t3 && t3.requestBody && (t3.requestBody = Ye(t3.requestBody, t3.requestHeaders, s2, "Request")), null != t3 && t3.responseBody && (t3.responseBody = Ye(t3.responseBody, t3.responseHeaders, s2, "Response")), t3)), h2 = (i3) => {
    return u2(((t3, i4) => {
      var e4, r4 = wi(t3.name), s3 = 0 === i4.indexOf("http") ? null == (e4 = wi(i4)) ? void 0 : e4.pathname : i4;
      "/" === s3 && (s3 = "");
      var n3 = null == r4 ? void 0 : r4.pathname.replace(s3 || "", "");
      if (!(r4 && n3 && Ke.some((t4) => 0 === n3.indexOf(t4)))) return t3;
    })((r3 = (e3 = i3).requestHeaders, F$1(r3) || J(Object.keys(null != r3 ? r3 : {}), (t3) => {
      Je.includes(t3.toLowerCase()) && (r3[t3] = We);
    }), e3), t2.api_host));
    var e3, r3;
  }, d2 = E(t2.session_recording.maskNetworkRequestFn);
  return d2 && E(t2.session_recording.maskCapturedNetworkRequestFn) && N.warn("Both `maskNetworkRequestFn` and `maskCapturedNetworkRequestFn` are defined. `maskNetworkRequestFn` will be ignored."), d2 && (t2.session_recording.maskCapturedNetworkRequestFn = (i3) => {
    var e3 = t2.session_recording.maskNetworkRequestFn({ url: i3.name });
    return B$1({}, i3, { name: null == e3 ? void 0 : e3.url });
  }), n2.maskRequestFn = E(t2.session_recording.maskCapturedNetworkRequestFn) ? (i3) => {
    var e3, r3 = h2(i3);
    return r3 && null !== (e3 = null == t2.session_recording.maskCapturedNetworkRequestFn ? void 0 : t2.session_recording.maskCapturedNetworkRequestFn(r3)) && void 0 !== e3 ? e3 : void 0;
  } : (t3) => function(t4) {
    if (!R(t4)) return t4.requestBody = Xe(t4.requestBody, "Request"), t4.responseBody = Xe(t4.responseBody, "Response"), t4;
  }(h2(t3)), B$1({}, Ge, n2, { recordHeaders: o2, recordBody: a2, recordPerformance: l2, recordInitialRequests: l2 });
};
class Ze {
  constructor(t2, i2) {
    var e2, r2;
    void 0 === i2 && (i2 = {}), this.yt = {}, this.wt = (t3) => {
      if (!this.yt[t3]) {
        var i3, e3;
        this.yt[t3] = true;
        var r3 = this.St(t3);
        null == (i3 = (e3 = this.rt).onBlockedNode) || i3.call(e3, t3, r3);
      }
    }, this.$t = (t3) => {
      var i3 = this.St(t3);
      if ("svg" !== (null == i3 ? void 0 : i3.nodeName) && i3 instanceof Element) {
        var e3 = i3.closest("svg");
        if (e3) return [this._rrweb.mirror.getId(e3), e3];
      }
      return [t3, i3];
    }, this.St = (t3) => this._rrweb.mirror.getNode(t3), this.kt = (t3) => {
      var i3, e3, r3, s2, n2, o2, a2, l2;
      return (null !== (i3 = null == (e3 = t3.removes) ? void 0 : e3.length) && void 0 !== i3 ? i3 : 0) + (null !== (r3 = null == (s2 = t3.attributes) ? void 0 : s2.length) && void 0 !== r3 ? r3 : 0) + (null !== (n2 = null == (o2 = t3.texts) ? void 0 : o2.length) && void 0 !== n2 ? n2 : 0) + (null !== (a2 = null == (l2 = t3.adds) ? void 0 : l2.length) && void 0 !== a2 ? a2 : 0);
    }, this.throttleMutations = (t3) => {
      if (3 !== t3.type || 0 !== t3.data.source) return t3;
      var i3 = t3.data, e3 = this.kt(i3);
      i3.attributes && (i3.attributes = i3.attributes.filter((t4) => {
        var [i4] = this.$t(t4.id);
        return !this.ct.consumeRateLimit(i4) && t4;
      }));
      var r3 = this.kt(i3);
      return 0 !== r3 || e3 === r3 ? t3 : void 0;
    }, this._rrweb = t2, this.rt = i2, this.ct = new ne({ bucketSize: null !== (e2 = this.rt.bucketSize) && void 0 !== e2 ? e2 : 100, refillRate: null !== (r2 = this.rt.refillRate) && void 0 !== r2 ? r2 : 10, refillInterval: 1e3, et: this.wt });
  }
}
var tr = Uint8Array, ir = Uint16Array, er = Uint32Array, rr = new tr([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), sr = new tr([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), nr = new tr([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), or = function(t2, i2) {
  for (var e2 = new ir(31), r2 = 0; r2 < 31; ++r2) e2[r2] = i2 += 1 << t2[r2 - 1];
  var s2 = new er(e2[30]);
  for (r2 = 1; r2 < 30; ++r2) for (var n2 = e2[r2]; n2 < e2[r2 + 1]; ++n2) s2[n2] = n2 - e2[r2] << 5 | r2;
  return [e2, s2];
}, ar = or(rr, 2), lr = ar[0], ur = ar[1];
lr[28] = 258, ur[258] = 28;
for (var hr = or(sr, 0)[1], dr = new ir(32768), vr = 0; vr < 32768; ++vr) {
  var cr = (43690 & vr) >>> 1 | (21845 & vr) << 1;
  cr = (61680 & (cr = (52428 & cr) >>> 2 | (13107 & cr) << 2)) >>> 4 | (3855 & cr) << 4, dr[vr] = ((65280 & cr) >>> 8 | (255 & cr) << 8) >>> 1;
}
var fr = function(t2, i2, e2) {
  for (var r2 = t2.length, s2 = 0, n2 = new ir(i2); s2 < r2; ++s2) ++n2[t2[s2] - 1];
  var o2, a2 = new ir(i2);
  for (s2 = 0; s2 < i2; ++s2) a2[s2] = a2[s2 - 1] + n2[s2 - 1] << 1;
  for (o2 = new ir(r2), s2 = 0; s2 < r2; ++s2) o2[s2] = dr[a2[t2[s2] - 1]++] >>> 15 - t2[s2];
  return o2;
}, pr = new tr(288);
for (vr = 0; vr < 144; ++vr) pr[vr] = 8;
for (vr = 144; vr < 256; ++vr) pr[vr] = 9;
for (vr = 256; vr < 280; ++vr) pr[vr] = 7;
for (vr = 280; vr < 288; ++vr) pr[vr] = 8;
var gr = new tr(32);
for (vr = 0; vr < 32; ++vr) gr[vr] = 5;
var _r = fr(pr, 9), mr = fr(gr, 5), br = function(t2) {
  return (t2 / 8 >> 0) + (7 & t2 && 1);
}, yr = function(t2, i2, e2) {
  (null == e2 || e2 > t2.length) && (e2 = t2.length);
  var r2 = new (t2 instanceof ir ? ir : t2 instanceof er ? er : tr)(e2 - i2);
  return r2.set(t2.subarray(i2, e2)), r2;
}, wr = function(t2, i2, e2) {
  e2 <<= 7 & i2;
  var r2 = i2 / 8 >> 0;
  t2[r2] |= e2, t2[r2 + 1] |= e2 >>> 8;
}, Sr = function(t2, i2, e2) {
  e2 <<= 7 & i2;
  var r2 = i2 / 8 >> 0;
  t2[r2] |= e2, t2[r2 + 1] |= e2 >>> 8, t2[r2 + 2] |= e2 >>> 16;
}, $r = function(t2, i2) {
  for (var e2 = [], r2 = 0; r2 < t2.length; ++r2) t2[r2] && e2.push({ s: r2, f: t2[r2] });
  var s2 = e2.length, n2 = e2.slice();
  if (!s2) return [new tr(0), 0];
  if (1 == s2) {
    var o2 = new tr(e2[0].s + 1);
    return o2[e2[0].s] = 1, [o2, 1];
  }
  e2.sort(function(t3, i3) {
    return t3.f - i3.f;
  }), e2.push({ s: -1, f: 25001 });
  var a2 = e2[0], l2 = e2[1], u2 = 0, h2 = 1, d2 = 2;
  for (e2[0] = { s: -1, f: a2.f + l2.f, l: a2, r: l2 }; h2 != s2 - 1; ) a2 = e2[e2[u2].f < e2[d2].f ? u2++ : d2++], l2 = e2[u2 != h2 && e2[u2].f < e2[d2].f ? u2++ : d2++], e2[h2++] = { s: -1, f: a2.f + l2.f, l: a2, r: l2 };
  var v2 = n2[0].s;
  for (r2 = 1; r2 < s2; ++r2) n2[r2].s > v2 && (v2 = n2[r2].s);
  var c2 = new ir(v2 + 1), f2 = kr(e2[h2 - 1], c2, 0);
  if (f2 > i2) {
    r2 = 0;
    var p2 = 0, g2 = f2 - i2, _2 = 1 << g2;
    for (n2.sort(function(t3, i3) {
      return c2[i3.s] - c2[t3.s] || t3.f - i3.f;
    }); r2 < s2; ++r2) {
      var m2 = n2[r2].s;
      if (!(c2[m2] > i2)) break;
      p2 += _2 - (1 << f2 - c2[m2]), c2[m2] = i2;
    }
    for (p2 >>>= g2; p2 > 0; ) {
      var b2 = n2[r2].s;
      c2[b2] < i2 ? p2 -= 1 << i2 - c2[b2]++ - 1 : ++r2;
    }
    for (; r2 >= 0 && p2; --r2) {
      var y2 = n2[r2].s;
      c2[y2] == i2 && (--c2[y2], ++p2);
    }
    f2 = i2;
  }
  return [new tr(c2), f2];
}, kr = function(t2, i2, e2) {
  return -1 == t2.s ? Math.max(kr(t2.l, i2, e2 + 1), kr(t2.r, i2, e2 + 1)) : i2[t2.s] = e2;
}, xr = function(t2) {
  for (var i2 = t2.length; i2 && !t2[--i2]; ) ;
  for (var e2 = new ir(++i2), r2 = 0, s2 = t2[0], n2 = 1, o2 = function(t3) {
    e2[r2++] = t3;
  }, a2 = 1; a2 <= i2; ++a2) if (t2[a2] == s2 && a2 != i2) ++n2;
  else {
    if (!s2 && n2 > 2) {
      for (; n2 > 138; n2 -= 138) o2(32754);
      n2 > 2 && (o2(n2 > 10 ? n2 - 11 << 5 | 28690 : n2 - 3 << 5 | 12305), n2 = 0);
    } else if (n2 > 3) {
      for (o2(s2), --n2; n2 > 6; n2 -= 6) o2(8304);
      n2 > 2 && (o2(n2 - 3 << 5 | 8208), n2 = 0);
    }
    for (; n2--; ) o2(s2);
    n2 = 1, s2 = t2[a2];
  }
  return [e2.subarray(0, r2), i2];
}, Er = function(t2, i2) {
  for (var e2 = 0, r2 = 0; r2 < i2.length; ++r2) e2 += t2[r2] * i2[r2];
  return e2;
}, Ir = function(t2, i2, e2) {
  var r2 = e2.length, s2 = br(i2 + 2);
  t2[s2] = 255 & r2, t2[s2 + 1] = r2 >>> 8, t2[s2 + 2] = 255 ^ t2[s2], t2[s2 + 3] = 255 ^ t2[s2 + 1];
  for (var n2 = 0; n2 < r2; ++n2) t2[s2 + n2 + 4] = e2[n2];
  return 8 * (s2 + 4 + r2);
}, Pr = function(t2, i2, e2, r2, s2, n2, o2, a2, l2, u2, h2) {
  wr(i2, h2++, e2), ++s2[256];
  for (var d2 = $r(s2, 15), v2 = d2[0], c2 = d2[1], f2 = $r(n2, 15), p2 = f2[0], g2 = f2[1], _2 = xr(v2), m2 = _2[0], b2 = _2[1], y2 = xr(p2), w2 = y2[0], S2 = y2[1], $2 = new ir(19), k2 = 0; k2 < m2.length; ++k2) $2[31 & m2[k2]]++;
  for (k2 = 0; k2 < w2.length; ++k2) $2[31 & w2[k2]]++;
  for (var x2 = $r($2, 7), E2 = x2[0], I2 = x2[1], P2 = 19; P2 > 4 && !E2[nr[P2 - 1]]; --P2) ;
  var R2, T2, M2, C2, F2 = u2 + 5 << 3, O2 = Er(s2, pr) + Er(n2, gr) + o2, A2 = Er(s2, v2) + Er(n2, p2) + o2 + 14 + 3 * P2 + Er($2, E2) + (2 * $2[16] + 3 * $2[17] + 7 * $2[18]);
  if (F2 <= O2 && F2 <= A2) return Ir(i2, h2, t2.subarray(l2, l2 + u2));
  if (wr(i2, h2, 1 + (A2 < O2)), h2 += 2, A2 < O2) {
    R2 = fr(v2, c2), T2 = v2, M2 = fr(p2, g2), C2 = p2;
    var D2 = fr(E2, I2);
    wr(i2, h2, b2 - 257), wr(i2, h2 + 5, S2 - 1), wr(i2, h2 + 10, P2 - 4), h2 += 14;
    for (k2 = 0; k2 < P2; ++k2) wr(i2, h2 + 3 * k2, E2[nr[k2]]);
    h2 += 3 * P2;
    for (var L2 = [m2, w2], j2 = 0; j2 < 2; ++j2) {
      var N2 = L2[j2];
      for (k2 = 0; k2 < N2.length; ++k2) {
        var z2 = 31 & N2[k2];
        wr(i2, h2, D2[z2]), h2 += E2[z2], z2 > 15 && (wr(i2, h2, N2[k2] >>> 5 & 127), h2 += N2[k2] >>> 12);
      }
    }
  } else R2 = _r, T2 = pr, M2 = mr, C2 = gr;
  for (k2 = 0; k2 < a2; ++k2) if (r2[k2] > 255) {
    z2 = r2[k2] >>> 18 & 31;
    Sr(i2, h2, R2[z2 + 257]), h2 += T2[z2 + 257], z2 > 7 && (wr(i2, h2, r2[k2] >>> 23 & 31), h2 += rr[z2]);
    var U2 = 31 & r2[k2];
    Sr(i2, h2, M2[U2]), h2 += C2[U2], U2 > 3 && (Sr(i2, h2, r2[k2] >>> 5 & 8191), h2 += sr[U2]);
  } else Sr(i2, h2, R2[r2[k2]]), h2 += T2[r2[k2]];
  return Sr(i2, h2, R2[256]), h2 + T2[256];
}, Rr = new er([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), Tr = function() {
  for (var t2 = new er(256), i2 = 0; i2 < 256; ++i2) {
    for (var e2 = i2, r2 = 9; --r2; ) e2 = (1 & e2 && 3988292384) ^ e2 >>> 1;
    t2[i2] = e2;
  }
  return t2;
}(), Mr = function() {
  var t2 = 4294967295;
  return { p: function(i2) {
    for (var e2 = t2, r2 = 0; r2 < i2.length; ++r2) e2 = Tr[255 & e2 ^ i2[r2]] ^ e2 >>> 8;
    t2 = e2;
  }, d: function() {
    return 4294967295 ^ t2;
  } };
}, Cr = function(t2, i2, e2, r2, s2) {
  return function(t3, i3, e3, r3, s3, n2) {
    var o2 = t3.length, a2 = new tr(r3 + o2 + 5 * (1 + Math.floor(o2 / 7e3)) + s3), l2 = a2.subarray(r3, a2.length - s3), u2 = 0;
    if (!i3 || o2 < 8) for (var h2 = 0; h2 <= o2; h2 += 65535) {
      var d2 = h2 + 65535;
      d2 < o2 ? u2 = Ir(l2, u2, t3.subarray(h2, d2)) : (l2[h2] = n2, u2 = Ir(l2, u2, t3.subarray(h2, o2)));
    }
    else {
      for (var v2 = Rr[i3 - 1], c2 = v2 >>> 13, f2 = 8191 & v2, p2 = (1 << e3) - 1, g2 = new ir(32768), _2 = new ir(p2 + 1), m2 = Math.ceil(e3 / 3), b2 = 2 * m2, y2 = function(i4) {
        return (t3[i4] ^ t3[i4 + 1] << m2 ^ t3[i4 + 2] << b2) & p2;
      }, w2 = new er(25e3), S2 = new ir(288), $2 = new ir(32), k2 = 0, x2 = 0, E2 = (h2 = 0, 0), I2 = 0, P2 = 0; h2 < o2; ++h2) {
        var R2 = y2(h2), T2 = 32767 & h2, M2 = _2[R2];
        if (g2[T2] = M2, _2[R2] = T2, I2 <= h2) {
          var C2 = o2 - h2;
          if ((k2 > 7e3 || E2 > 24576) && C2 > 423) {
            u2 = Pr(t3, l2, 0, w2, S2, $2, x2, E2, P2, h2 - P2, u2), E2 = k2 = x2 = 0, P2 = h2;
            for (var F2 = 0; F2 < 286; ++F2) S2[F2] = 0;
            for (F2 = 0; F2 < 30; ++F2) $2[F2] = 0;
          }
          var O2 = 2, A2 = 0, D2 = f2, L2 = T2 - M2 & 32767;
          if (C2 > 2 && R2 == y2(h2 - L2)) for (var j2 = Math.min(c2, C2) - 1, N2 = Math.min(32767, h2), z2 = Math.min(258, C2); L2 <= N2 && --D2 && T2 != M2; ) {
            if (t3[h2 + O2] == t3[h2 + O2 - L2]) {
              for (var U2 = 0; U2 < z2 && t3[h2 + U2] == t3[h2 + U2 - L2]; ++U2) ;
              if (U2 > O2) {
                if (O2 = U2, A2 = L2, U2 > j2) break;
                var q2 = Math.min(L2, U2 - 2), B2 = 0;
                for (F2 = 0; F2 < q2; ++F2) {
                  var H2 = h2 - L2 + F2 + 32768 & 32767, W2 = H2 - g2[H2] + 32768 & 32767;
                  W2 > B2 && (B2 = W2, M2 = H2);
                }
              }
            }
            L2 += (T2 = M2) - (M2 = g2[T2]) + 32768 & 32767;
          }
          if (A2) {
            w2[E2++] = 268435456 | ur[O2] << 18 | hr[A2];
            var G2 = 31 & ur[O2], J2 = 31 & hr[A2];
            x2 += rr[G2] + sr[J2], ++S2[257 + G2], ++$2[J2], I2 = h2 + O2, ++k2;
          } else w2[E2++] = t3[h2], ++S2[t3[h2]];
        }
      }
      u2 = Pr(t3, l2, n2, w2, S2, $2, x2, E2, P2, h2 - P2, u2);
    }
    return yr(a2, 0, r3 + br(u2) + s3);
  }(t2, null == i2.level ? 6 : i2.level, null == i2.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(t2.length)))) : 12 + i2.mem, e2, r2, true);
}, Fr = function(t2, i2, e2) {
  for (; e2; ++i2) t2[i2] = e2, e2 >>>= 8;
}, Or = function(t2, i2) {
  var e2 = i2.filename;
  if (t2[0] = 31, t2[1] = 139, t2[2] = 8, t2[8] = i2.level < 2 ? 4 : 9 == i2.level ? 2 : 0, t2[9] = 3, 0 != i2.mtime && Fr(t2, 4, Math.floor(new Date(i2.mtime || Date.now()) / 1e3)), e2) {
    t2[3] = 8;
    for (var r2 = 0; r2 <= e2.length; ++r2) t2[r2 + 10] = e2.charCodeAt(r2);
  }
}, Ar = function(t2) {
  return 10 + (t2.filename && t2.filename.length + 1 || 0);
};
function Dr(t2, i2) {
  void 0 === i2 && (i2 = {});
  var e2 = Mr(), r2 = t2.length;
  e2.p(t2);
  var s2 = Cr(t2, i2, Ar(i2), 8), n2 = s2.length;
  return Or(s2, i2), Fr(s2, n2 - 8, e2.d()), Fr(s2, n2 - 4, r2), s2;
}
function Lr(t2, i2) {
  var e2 = t2.length;
  if ("undefined" != typeof TextEncoder) return new TextEncoder().encode(t2);
  for (var r2 = new tr(t2.length + (t2.length >>> 1)), s2 = 0, n2 = function(t3) {
    r2[s2++] = t3;
  }, o2 = 0; o2 < e2; ++o2) {
    if (s2 + 5 > r2.length) {
      var a2 = new tr(s2 + 8 + (e2 - o2 << 1));
      a2.set(r2), r2 = a2;
    }
    var l2 = t2.charCodeAt(o2);
    l2 < 128 || i2 ? n2(l2) : l2 < 2048 ? (n2(192 | l2 >>> 6), n2(128 | 63 & l2)) : l2 > 55295 && l2 < 57344 ? (n2(240 | (l2 = 65536 + (1047552 & l2) | 1023 & t2.charCodeAt(++o2)) >>> 18), n2(128 | l2 >>> 12 & 63), n2(128 | l2 >>> 6 & 63), n2(128 | 63 & l2)) : (n2(224 | l2 >>> 12), n2(128 | l2 >>> 6 & 63), n2(128 | 63 & l2));
  }
  return yr(r2, 0, s2);
}
function jr(t2, i2) {
  return function(t3) {
    for (var i3 = 0, e2 = 0; e2 < t3.length; e2++) i3 = (i3 << 5) - i3 + t3.charCodeAt(e2), i3 |= 0;
    return Math.abs(i3);
  }(t2) % 100 < se$1(100 * i2, 0, 100);
}
var Nr = "disabled", zr = "sampled", Ur = "active", qr = "buffering", Br = "paused", Hr = "trigger", Wr = Hr + "_activated", Gr = Hr + "_pending", Jr = Hr + "_" + Nr;
function Vr(t2, i2) {
  return i2.some((i3) => "regex" === i3.matching && new RegExp(i3.url).test(t2));
}
class Kr {
  constructor(t2) {
    this.xt = t2;
  }
  triggerStatus(t2) {
    var i2 = this.xt.map((i3) => i3.triggerStatus(t2));
    return i2.includes(Wr) ? Wr : i2.includes(Gr) ? Gr : Jr;
  }
  stop() {
    this.xt.forEach((t2) => t2.stop());
  }
}
class Yr {
  constructor(t2) {
    this.xt = t2;
  }
  triggerStatus(t2) {
    var i2 = /* @__PURE__ */ new Set();
    for (var e2 of this.xt) i2.add(e2.triggerStatus(t2));
    switch (i2.delete(Jr), i2.size) {
      case 0:
        return Jr;
      case 1:
        return Array.from(i2)[0];
      default:
        return Gr;
    }
  }
  stop() {
    this.xt.forEach((t2) => t2.stop());
  }
}
class Xr {
  triggerStatus() {
    return Gr;
  }
  stop() {
  }
}
class Qr {
  constructor(t2) {
    this.Et = [], this.It = [], this.urlBlocked = false, this._instance = t2;
  }
  onRemoteConfig(t2) {
    var i2, e2;
    this.Et = (null == (i2 = t2.sessionRecording) ? void 0 : i2.urlTriggers) || [], this.It = (null == (e2 = t2.sessionRecording) ? void 0 : e2.urlBlocklist) || [];
  }
  Pt(t2) {
    var i2;
    return 0 === this.Et.length ? Jr : (null == (i2 = this._instance) ? void 0 : i2.get_property(xt)) === t2 ? Wr : Gr;
  }
  triggerStatus(t2) {
    var i2 = this.Pt(t2), e2 = i2 === Wr ? Wr : i2 === Gr ? Gr : Jr;
    return this._instance.register_for_session({ $sdk_debug_replay_url_trigger_status: e2 }), e2;
  }
  checkUrlTriggerConditions(i2, e2, r2) {
    if (void 0 !== t && t.location.href) {
      var s2 = t.location.href, n2 = this.urlBlocked, o2 = Vr(s2, this.It);
      n2 && o2 || (o2 && !n2 ? i2() : !o2 && n2 && e2(), Vr(s2, this.Et) && r2("url"));
    }
  }
  stop() {
  }
}
class Zr {
  constructor(t2) {
    this.linkedFlag = null, this.linkedFlagSeen = false, this.Rt = () => {
    }, this._instance = t2;
  }
  triggerStatus() {
    var t2 = Gr;
    return F$1(this.linkedFlag) && (t2 = Jr), this.linkedFlagSeen && (t2 = Wr), this._instance.register_for_session({ $sdk_debug_replay_linked_flag_trigger_status: t2 }), t2;
  }
  onRemoteConfig(t2, i2) {
    var e2;
    if (this.linkedFlag = (null == (e2 = t2.sessionRecording) ? void 0 : e2.linkedFlag) || null, !F$1(this.linkedFlag) && !this.linkedFlagSeen) {
      var r2 = T(this.linkedFlag) ? this.linkedFlag : this.linkedFlag.flag, s2 = T(this.linkedFlag) ? null : this.linkedFlag.variant;
      this.Rt = this._instance.onFeatureFlags((t3, e3) => {
        var n2 = false;
        if (I$1(e3) && r2 in e3) {
          var o2 = e3[r2];
          n2 = A(o2) ? true === o2 : s2 ? o2 === s2 : !!o2;
        }
        this.linkedFlagSeen = n2, n2 && i2(r2, s2);
      });
    }
  }
  stop() {
    this.Rt();
  }
}
class ts {
  constructor(t2) {
    this.Tt = [], this._instance = t2;
  }
  onRemoteConfig(t2) {
    var i2;
    this.Tt = (null == (i2 = t2.sessionRecording) ? void 0 : i2.eventTriggers) || [];
  }
  Mt(t2) {
    var i2;
    return 0 === this.Tt.length ? Jr : (null == (i2 = this._instance) ? void 0 : i2.get_property(Et)) === t2 ? Wr : Gr;
  }
  triggerStatus(t2) {
    var i2 = this.Mt(t2), e2 = i2 === Wr ? Wr : i2 === Gr ? Gr : Jr;
    return this._instance.register_for_session({ $sdk_debug_replay_event_trigger_status: e2 }), e2;
  }
  stop() {
  }
}
function is(t2) {
  return t2.isRecordingEnabled ? qr : Nr;
}
function es(t2) {
  if (!t2.receivedFlags) return qr;
  if (!t2.isRecordingEnabled) return Nr;
  if (t2.urlTriggerMatching.urlBlocked) return Br;
  var i2 = true === t2.isSampled, e2 = new Kr([t2.eventTriggerMatching, t2.urlTriggerMatching, t2.linkedFlagMatching]).triggerStatus(t2.sessionId);
  return i2 ? zr : e2 === Wr ? Ur : e2 === Gr ? qr : false === t2.isSampled ? Nr : Ur;
}
function rs(t2) {
  if (!t2.receivedFlags) return qr;
  if (!t2.isRecordingEnabled) return Nr;
  if (t2.urlTriggerMatching.urlBlocked) return Br;
  var i2 = new Yr([t2.eventTriggerMatching, t2.urlTriggerMatching, t2.linkedFlagMatching]).triggerStatus(t2.sessionId), e2 = i2 !== Jr, r2 = A(t2.isSampled);
  return e2 && i2 === Gr ? qr : e2 && i2 === Jr || r2 && !t2.isSampled ? Nr : true === t2.isSampled ? zr : Ur;
}
var ss = "[SessionRecording]", ns = z(ss);
function os() {
  var t2;
  return null == v || null == (t2 = v.__PosthogExtensions__) || null == (t2 = t2.rrweb) ? void 0 : t2.record;
}
var as = 3e5, ls = [Be.MouseMove, Be.MouseInteraction, Be.Scroll, Be.ViewportResize, Be.Input, Be.TouchMove, Be.MediaInteraction, Be.Drag], us = (t2) => ({ rrwebMethod: t2, enqueuedAt: Date.now(), attempt: 1 });
function hs(t2) {
  return function(t3, i2) {
    for (var e2 = "", r2 = 0; r2 < t3.length; ) {
      var s2 = t3[r2++];
      e2 += String.fromCharCode(s2);
    }
    return e2;
  }(Dr(Lr(JSON.stringify(t2))));
}
function ds(t2) {
  return t2.type === qe.Custom && "sessionIdle" === t2.data.tag;
}
class vs {
  get sessionId() {
    return this.Ct;
  }
  get Ft() {
    return this._instance.config.session_recording.session_idle_threshold_ms || 3e5;
  }
  get started() {
    return this.Ot;
  }
  get At() {
    if (!this._instance.sessionManager) throw new Error(ss + " must be started with a valid sessionManager.");
    return this._instance.sessionManager;
  }
  get Dt() {
    var t2, i2;
    return this.Lt.triggerStatus(this.sessionId) === Gr ? 6e4 : null !== (t2 = null == (i2 = this._instance.config.session_recording) ? void 0 : i2.full_snapshot_interval_millis) && void 0 !== t2 ? t2 : as;
  }
  get jt() {
    var t2 = this._instance.get_property(kt);
    return A(t2) ? t2 : null;
  }
  get Nt() {
    var t2, i2, e2 = null == (t2 = this.C) ? void 0 : t2.data[(null == (i2 = this.C) ? void 0 : i2.data.length) - 1], { sessionStartTimestamp: r2 } = this.At.checkAndGetSessionAndWindowId(true);
    return e2 ? e2.timestamp - r2 : null;
  }
  get zt() {
    var i2 = !!this._instance.get_property(pt), e2 = !this._instance.config.disable_session_recording;
    return t && i2 && e2;
  }
  get Ut() {
    var t2 = !!this._instance.get_property(gt), i2 = this._instance.config.enable_recording_console_log;
    return null != i2 ? i2 : t2;
  }
  get qt() {
    var t2, i2, e2, r2, s2, n2, o2 = this._instance.config.session_recording.captureCanvas, a2 = this._instance.get_property(bt), l2 = null !== (t2 = null !== (i2 = null == o2 ? void 0 : o2.recordCanvas) && void 0 !== i2 ? i2 : null == a2 ? void 0 : a2.enabled) && void 0 !== t2 && t2, u2 = null !== (e2 = null !== (r2 = null == o2 ? void 0 : o2.canvasFps) && void 0 !== r2 ? r2 : null == a2 ? void 0 : a2.fps) && void 0 !== e2 ? e2 : 4, h2 = null !== (s2 = null !== (n2 = null == o2 ? void 0 : o2.canvasQuality) && void 0 !== n2 ? n2 : null == a2 ? void 0 : a2.quality) && void 0 !== s2 ? s2 : 0.4;
    if ("string" == typeof h2) {
      var d2 = parseFloat(h2);
      h2 = isNaN(d2) ? 0.4 : d2;
    }
    return { enabled: l2, fps: se$1(u2, 0, 12, "canvas recording fps", 4), quality: se$1(h2, 0, 1, "canvas recording quality", 0.4) };
  }
  get Bt() {
    var t2, i2, e2 = this._instance.get_property(_t), r2 = { recordHeaders: null == (t2 = this._instance.config.session_recording) ? void 0 : t2.recordHeaders, recordBody: null == (i2 = this._instance.config.session_recording) ? void 0 : i2.recordBody }, s2 = (null == r2 ? void 0 : r2.recordHeaders) || (null == e2 ? void 0 : e2.recordHeaders), n2 = (null == r2 ? void 0 : r2.recordBody) || (null == e2 ? void 0 : e2.recordBody), o2 = I$1(this._instance.config.capture_performance) ? this._instance.config.capture_performance.network_timing : this._instance.config.capture_performance, a2 = !!(A(o2) ? o2 : null == e2 ? void 0 : e2.capturePerformance);
    return s2 || n2 || a2 ? { recordHeaders: s2, recordBody: n2, recordPerformance: a2 } : void 0;
  }
  get Ht() {
    var t2, i2, e2, r2, s2, n2, o2 = this._instance.get_property(mt), a2 = { maskAllInputs: null == (t2 = this._instance.config.session_recording) ? void 0 : t2.maskAllInputs, maskTextSelector: null == (i2 = this._instance.config.session_recording) ? void 0 : i2.maskTextSelector, blockSelector: null == (e2 = this._instance.config.session_recording) ? void 0 : e2.blockSelector }, l2 = null !== (r2 = null == a2 ? void 0 : a2.maskAllInputs) && void 0 !== r2 ? r2 : null == o2 ? void 0 : o2.maskAllInputs, u2 = null !== (s2 = null == a2 ? void 0 : a2.maskTextSelector) && void 0 !== s2 ? s2 : null == o2 ? void 0 : o2.maskTextSelector, h2 = null !== (n2 = null == a2 ? void 0 : a2.blockSelector) && void 0 !== n2 ? n2 : null == o2 ? void 0 : o2.blockSelector;
    return R(l2) && R(u2) && R(h2) ? void 0 : { maskAllInputs: null == l2 || l2, maskTextSelector: u2, blockSelector: h2 };
  }
  get Wt() {
    var t2 = this._instance.get_property(yt);
    return O(t2) ? t2 : null;
  }
  get Gt() {
    var t2 = this._instance.get_property(wt);
    return O(t2) ? t2 : null;
  }
  get status() {
    return this.Jt ? this.Vt({ receivedFlags: this.Jt, isRecordingEnabled: this.zt, isSampled: this.jt, urlTriggerMatching: this.Kt, eventTriggerMatching: this.Yt, linkedFlagMatching: this.Xt, sessionId: this.sessionId }) : qr;
  }
  constructor(t2) {
    if (this.Vt = is, this.Jt = false, this.Qt = [], this.Zt = "unknown", this.ti = Date.now(), this.Lt = new Xr(), this.ii = void 0, this.ei = void 0, this.ri = void 0, this.si = void 0, this.ni = void 0, this._forceAllowLocalhostNetworkCapture = false, this.oi = () => {
      this.ai();
    }, this.li = () => {
      this.ui("browser offline", {});
    }, this.hi = () => {
      this.ui("browser online", {});
    }, this.di = () => {
      if (null != o && o.visibilityState) {
        var t3 = "window " + o.visibilityState;
        this.ui(t3, {});
      }
    }, this._instance = t2, this.Ot = false, this.vi = "/s/", this.ci = void 0, this.Jt = false, !this._instance.sessionManager) throw ns.error("started without valid sessionManager"), new Error(ss + " started without valid sessionManager. This is a bug.");
    if (this._instance.config.__preview_experimental_cookieless_mode) throw new Error(ss + " cannot be used with __preview_experimental_cookieless_mode.");
    this.Xt = new Zr(this._instance), this.Kt = new Qr(this._instance), this.Yt = new ts(this._instance);
    var { sessionId: i2, windowId: e2 } = this.At.checkAndGetSessionAndWindowId();
    this.Ct = i2, this.fi = e2, this.C = this.pi(), this.Ft >= this.At.sessionTimeoutMs && ns.warn("session_idle_threshold_ms (" + this.Ft + ") is greater than the session timeout (" + this.At.sessionTimeoutMs + "). Session will never be detected as idle");
  }
  startIfEnabledOrStop(i2) {
    this.zt ? (this.gi(i2), st(t, "beforeunload", this.oi), st(t, "offline", this.li), st(t, "online", this.hi), st(t, "visibilitychange", this.di), this.mi(), this.bi(), F$1(this.ii) && (this.ii = this._instance.on("eventCaptured", (t2) => {
      try {
        if ("$pageview" === t2.event) {
          var i3 = null != t2 && t2.properties.$current_url ? this.yi(null == t2 ? void 0 : t2.properties.$current_url) : "";
          if (!i3) return;
          this.ui("$pageview", { href: i3 });
        }
      } catch (t3) {
        ns.error("Could not add $pageview to rrweb session", t3);
      }
    })), this.ei || (this.ei = this.At.onSessionId((t2, i3, e2) => {
      var r2, s2;
      e2 && (this.ui("$session_id_change", { sessionId: t2, windowId: i3, changeReason: e2 }), null == (r2 = this._instance) || null == (r2 = r2.persistence) || r2.unregister(Et), null == (s2 = this._instance) || null == (s2 = s2.persistence) || s2.unregister(xt));
    }))) : this.stopRecording();
  }
  stopRecording() {
    var i2, e2, r2, s2;
    this.Ot && this.ci && (this.ci(), this.ci = void 0, this.Ot = false, null == t || t.removeEventListener("beforeunload", this.oi), null == t || t.removeEventListener("offline", this.li), null == t || t.removeEventListener("online", this.hi), null == t || t.removeEventListener("visibilitychange", this.di), this.pi(), clearInterval(this.wi), null == (i2 = this.ii) || i2.call(this), this.ii = void 0, null == (e2 = this.ni) || e2.call(this), this.ni = void 0, null == (r2 = this.ei) || r2.call(this), this.ei = void 0, null == (s2 = this.si) || s2.call(this), this.si = void 0, this.Yt.stop(), this.Kt.stop(), this.Xt.stop(), ns.info("stopped"));
  }
  Si() {
    var t2;
    null == (t2 = this._instance.persistence) || t2.unregister(kt);
  }
  $i(t2) {
    var i2, e2 = this.Ct !== t2, r2 = this.Wt;
    if (O(r2)) {
      var s2 = this.jt, n2 = e2 || !A(s2), o2 = n2 ? jr(t2, r2) : s2;
      n2 && (o2 ? this.ki(zr) : ns.warn("Sample rate (" + r2 + ") has determined that this sessionId (" + t2 + ") will not be sent to the server."), this.ui("samplingDecisionMade", { sampleRate: r2, isSampled: o2 })), null == (i2 = this._instance.persistence) || i2.register({ [kt]: o2 });
    } else this.Si();
  }
  onRemoteConfig(t2) {
    var i2, e2, r2, s2;
    (this.ui("$remote_config_received", t2), this.xi(t2), null != (i2 = t2.sessionRecording) && i2.endpoint) && (this.vi = null == (s2 = t2.sessionRecording) ? void 0 : s2.endpoint);
    this.mi(), "any" === (null == (e2 = t2.sessionRecording) ? void 0 : e2.triggerMatchType) ? (this.Vt = es, this.Lt = new Kr([this.Yt, this.Kt])) : (this.Vt = rs, this.Lt = new Yr([this.Yt, this.Kt])), this._instance.register_for_session({ $sdk_debug_replay_remote_trigger_matching_config: null == (r2 = t2.sessionRecording) ? void 0 : r2.triggerMatchType }), this.Kt.onRemoteConfig(t2), this.Yt.onRemoteConfig(t2), this.Xt.onRemoteConfig(t2, (t3, i3) => {
      this.ki("linked_flag_matched", { flag: t3, variant: i3 });
    }), this.Jt = true, this.startIfEnabledOrStop();
  }
  mi() {
    O(this.Wt) && F$1(this.si) && (this.si = this.At.onSessionId((t2) => {
      this.$i(t2);
    }));
  }
  xi(t2) {
    if (this._instance.persistence) {
      var i2, e2 = this._instance.persistence, r2 = () => {
        var i3, r3, s2, n2, o2, a2, l2, u2, h2, d2 = null == (i3 = t2.sessionRecording) ? void 0 : i3.sampleRate, v2 = F$1(d2) ? null : parseFloat(d2);
        F$1(v2) && this.Si();
        var c2 = null == (r3 = t2.sessionRecording) ? void 0 : r3.minimumDurationMilliseconds;
        e2.register({ [pt]: !!t2.sessionRecording, [gt]: null == (s2 = t2.sessionRecording) ? void 0 : s2.consoleLogRecordingEnabled, [_t]: B$1({ capturePerformance: t2.capturePerformance }, null == (n2 = t2.sessionRecording) ? void 0 : n2.networkPayloadCapture), [mt]: null == (o2 = t2.sessionRecording) ? void 0 : o2.masking, [bt]: { enabled: null == (a2 = t2.sessionRecording) ? void 0 : a2.recordCanvas, fps: null == (l2 = t2.sessionRecording) ? void 0 : l2.canvasFps, quality: null == (u2 = t2.sessionRecording) ? void 0 : u2.canvasQuality }, [yt]: v2, [wt]: R(c2) ? null : c2, [St]: null == (h2 = t2.sessionRecording) ? void 0 : h2.scriptConfig });
      };
      r2(), null == (i2 = this.ri) || i2.call(this), this.ri = this.At.onSessionId(r2);
    }
  }
  log(t2, i2) {
    var e2;
    void 0 === i2 && (i2 = "log"), null == (e2 = this._instance.sessionRecording) || e2.onRRwebEmit({ type: 6, data: { plugin: "rrweb/console@1", payload: { level: i2, trace: [], payload: [JSON.stringify(t2)] } }, timestamp: Date.now() });
  }
  gi(t2) {
    if (!R(Object.assign) && !R(Array.from) && !(this.Ot || this._instance.config.disable_session_recording || this._instance.consent.isOptedOut())) {
      var i2;
      if (this.Ot = true, this.At.checkAndGetSessionAndWindowId(), os()) this.Ei();
      else null == (i2 = v.__PosthogExtensions__) || null == i2.loadExternalDependency || i2.loadExternalDependency(this._instance, this.Ii, (t3) => {
        if (t3) return ns.error("could not load recorder", t3);
        this.Ei();
      });
      ns.info("starting"), this.status === Ur && this.ki(t2 || "recording_initialized");
    }
  }
  get Ii() {
    var t2;
    return (null == (t2 = this._instance) || null == (t2 = t2.persistence) || null == (t2 = t2.get_property(St)) ? void 0 : t2.script) || "recorder";
  }
  Pi(t2) {
    var i2;
    return 3 === t2.type && -1 !== ls.indexOf(null == (i2 = t2.data) ? void 0 : i2.source);
  }
  Ri(t2) {
    var i2 = this.Pi(t2);
    i2 || this.Zt || t2.timestamp - this.ti > this.Ft && (this.Zt = true, clearInterval(this.wi), this.ui("sessionIdle", { eventTimestamp: t2.timestamp, lastActivityTimestamp: this.ti, threshold: this.Ft, bufferLength: this.C.data.length, bufferSize: this.C.size }), this.ai());
    var e2 = false;
    if (i2 && (this.ti = t2.timestamp, this.Zt)) {
      var r2 = "unknown" === this.Zt;
      this.Zt = false, r2 || (this.ui("sessionNoLongerIdle", { reason: "user activity", type: t2.type }), e2 = true);
    }
    if (!this.Zt) {
      var { windowId: s2, sessionId: n2 } = this.At.checkAndGetSessionAndWindowId(!i2, t2.timestamp), o2 = this.Ct !== n2, a2 = this.fi !== s2;
      this.fi = s2, this.Ct = n2, o2 || a2 ? (this.stopRecording(), this.startIfEnabledOrStop("session_id_changed")) : e2 && this.Ti();
    }
  }
  Mi(t2) {
    try {
      return t2.rrwebMethod(), true;
    } catch (i2) {
      return this.Qt.length < 10 ? this.Qt.push({ enqueuedAt: t2.enqueuedAt || Date.now(), attempt: t2.attempt++, rrwebMethod: t2.rrwebMethod }) : ns.warn("could not emit queued rrweb event.", i2, t2), false;
    }
  }
  ui(t2, i2) {
    return this.Mi(us(() => os().addCustomEvent(t2, i2)));
  }
  Ci() {
    return this.Mi(us(() => os().takeFullSnapshot()));
  }
  Ei() {
    var t2, i2, e2, r2, s2 = { blockClass: "ph-no-capture", blockSelector: void 0, ignoreClass: "ph-ignore-input", maskTextClass: "ph-mask", maskTextSelector: void 0, maskTextFn: void 0, maskAllInputs: true, maskInputOptions: { password: true }, maskInputFn: void 0, slimDOMOptions: {}, collectFonts: false, inlineStylesheet: true, recordCrossOriginIframes: false }, n2 = this._instance.config.session_recording;
    for (var [o2, a2] of Object.entries(n2 || {})) o2 in s2 && ("maskInputOptions" === o2 ? s2.maskInputOptions = B$1({ password: true }, a2) : s2[o2] = a2);
    (this.qt && this.qt.enabled && (s2.recordCanvas = true, s2.sampling = { canvas: this.qt.fps }, s2.dataURLOptions = { type: "image/webp", quality: this.qt.quality }), this.Ht) && (s2.maskAllInputs = null === (i2 = this.Ht.maskAllInputs) || void 0 === i2 || i2, s2.maskTextSelector = null !== (e2 = this.Ht.maskTextSelector) && void 0 !== e2 ? e2 : void 0, s2.blockSelector = null !== (r2 = this.Ht.blockSelector) && void 0 !== r2 ? r2 : void 0);
    var l2 = os();
    if (l2) {
      this.Fi = null !== (t2 = this.Fi) && void 0 !== t2 ? t2 : new Ze(l2, { refillRate: this._instance.config.session_recording.__mutationThrottlerRefillRate, bucketSize: this._instance.config.session_recording.__mutationThrottlerBucketSize, onBlockedNode: (t3, i3) => {
        var e3 = "Too many mutations on node '" + t3 + "'. Rate limiting. This could be due to SVG animations or something similar";
        ns.info(e3, { node: i3 }), this.log(ss + " " + e3, "warn");
      } });
      var u2 = this.Oi();
      this.ci = l2(B$1({ emit: (t3) => {
        this.onRRwebEmit(t3);
      }, plugins: u2 }, s2)), this.ti = Date.now(), this.Zt = A(this.Zt) ? this.Zt : "unknown", this.ui("$session_options", { sessionRecordingOptions: s2, activePlugins: u2.map((t3) => null == t3 ? void 0 : t3.name) }), this.ui("$posthog_config", { config: this._instance.config });
    } else ns.error("onScriptLoaded was called but rrwebRecord is not available. This indicates something has gone wrong.");
  }
  Ti() {
    if (this.wi && clearInterval(this.wi), true !== this.Zt) {
      var t2 = this.Dt;
      t2 && (this.wi = setInterval(() => {
        this.Ci();
      }, t2));
    }
  }
  Oi() {
    var t2, i2, e2 = [], r2 = null == (t2 = v.__PosthogExtensions__) || null == (t2 = t2.rrwebPlugins) ? void 0 : t2.getRecordConsolePlugin;
    r2 && this.Ut && e2.push(r2());
    var s2 = null == (i2 = v.__PosthogExtensions__) || null == (i2 = i2.rrwebPlugins) ? void 0 : i2.getRecordNetworkPlugin;
    this.Bt && E(s2) && (!yi.includes(location.hostname) || this._forceAllowLocalhostNetworkCapture ? e2.push(s2(Qe(this._instance.config, this.Bt))) : ns.info("NetworkCapture not started because we are on localhost."));
    return e2;
  }
  onRRwebEmit(t2) {
    var i2;
    if (this.Ai(), t2 && I$1(t2)) {
      if (t2.type === qe.Meta) {
        var e2 = this.yi(t2.data.href);
        if (this.Di = e2, !e2) return;
        t2.data.href = e2;
      } else this.Li();
      if (this.Kt.checkUrlTriggerConditions(() => this.ji(), () => this.Ni(), (t3) => this.zi(t3)), !this.Kt.urlBlocked || (r2 = t2).type === qe.Custom && "recording paused" === r2.data.tag) {
        var r2;
        t2.type === qe.FullSnapshot && this.Ti(), t2.type === qe.FullSnapshot && this.Jt && this.Lt.triggerStatus(this.sessionId) === Gr && this.pi();
        var s2 = this.Fi ? this.Fi.throttleMutations(t2) : t2;
        if (s2) {
          var n2 = function(t3) {
            var i3 = t3;
            if (i3 && I$1(i3) && 6 === i3.type && I$1(i3.data) && "rrweb/console@1" === i3.data.plugin) {
              i3.data.payload.payload.length > 10 && (i3.data.payload.payload = i3.data.payload.payload.slice(0, 10), i3.data.payload.payload.push("...[truncated]"));
              for (var e3 = [], r3 = 0; r3 < i3.data.payload.payload.length; r3++) i3.data.payload.payload[r3] && i3.data.payload.payload[r3].length > 2e3 ? e3.push(i3.data.payload.payload[r3].slice(0, 2e3) + "...[truncated]") : e3.push(i3.data.payload.payload[r3]);
              return i3.data.payload.payload = e3, t3;
            }
            return t3;
          }(s2);
          if (this.Ri(n2), true !== this.Zt || ds(n2)) {
            if (ds(n2)) {
              var o2 = n2.data.payload;
              if (o2) {
                var a2 = o2.lastActivityTimestamp, l2 = o2.threshold;
                n2.timestamp = a2 + l2;
              }
            }
            var u2 = null === (i2 = this._instance.config.session_recording.compress_events) || void 0 === i2 || i2 ? function(t3) {
              if (ze(t3) < 1024) return t3;
              try {
                if (t3.type === qe.FullSnapshot) return B$1({}, t3, { data: hs(t3.data), cv: "2024-10" });
                if (t3.type === qe.IncrementalSnapshot && t3.data.source === Be.Mutation) return B$1({}, t3, { cv: "2024-10", data: B$1({}, t3.data, { texts: hs(t3.data.texts), attributes: hs(t3.data.attributes), removes: hs(t3.data.removes), adds: hs(t3.data.adds) }) });
                if (t3.type === qe.IncrementalSnapshot && t3.data.source === Be.StyleSheetRule) return B$1({}, t3, { cv: "2024-10", data: B$1({}, t3.data, { adds: t3.data.adds ? hs(t3.data.adds) : void 0, removes: t3.data.removes ? hs(t3.data.removes) : void 0 }) });
              } catch (t4) {
                ns.error("could not compress event - will use uncompressed event", t4);
              }
              return t3;
            }(n2) : n2, h2 = { $snapshot_bytes: ze(u2), $snapshot_data: u2, $session_id: this.Ct, $window_id: this.fi };
            this.status !== Nr ? this.Ui(h2) : this.pi();
          }
        }
      }
    }
  }
  Li() {
    if (!this._instance.config.capture_pageview && t) {
      var i2 = this.yi(t.location.href);
      this.Di !== i2 && (this.ui("$url_changed", { href: i2 }), this.Di = i2);
    }
  }
  Ai() {
    if (this.Qt.length) {
      var t2 = [...this.Qt];
      this.Qt = [], t2.forEach((t3) => {
        Date.now() - t3.enqueuedAt <= 2e3 && this.Mi(t3);
      });
    }
  }
  yi(t2) {
    var i2 = this._instance.config.session_recording;
    if (i2.maskNetworkRequestFn) {
      var e2, r2 = { url: t2 };
      return null == (e2 = r2 = i2.maskNetworkRequestFn(r2)) ? void 0 : e2.url;
    }
    return t2;
  }
  pi() {
    return this.C = { size: 0, data: [], sessionId: this.Ct, windowId: this.fi }, this.C;
  }
  ai() {
    this.qi && (clearTimeout(this.qi), this.qi = void 0);
    var t2 = this.Gt, i2 = this.Nt, e2 = O(i2) && i2 >= 0, r2 = O(t2) && e2 && i2 < t2;
    if (this.status === qr || this.status === Br || this.status === Nr || r2) return this.qi = setTimeout(() => {
      this.ai();
    }, 2e3), this.C;
    this.C.data.length > 0 && Ue(this.C).forEach((t3) => {
      this.Bi({ $snapshot_bytes: t3.size, $snapshot_data: t3.data, $session_id: t3.sessionId, $window_id: t3.windowId, $lib: "web", $lib_version: c.LIB_VERSION });
    });
    return this.pi();
  }
  Ui(t2) {
    var i2, e2 = 2 + ((null == (i2 = this.C) ? void 0 : i2.data.length) || 0);
    !this.Zt && (this.C.size + t2.$snapshot_bytes + e2 > 943718.4 || this.C.sessionId !== this.Ct) && (this.C = this.ai()), this.C.size += t2.$snapshot_bytes, this.C.data.push(t2.$snapshot_data), this.qi || this.Zt || (this.qi = setTimeout(() => {
      this.ai();
    }, 2e3));
  }
  Bi(t2) {
    this._instance.capture("$snapshot", t2, { _url: this._instance.requestRouter.endpointFor("api", this.vi), _noTruncate: true, _batchKey: "recordings", skip_client_rate_limiting: true });
  }
  zi(t2) {
    var i2;
    this.Lt.triggerStatus(this.sessionId) === Gr && (null == (i2 = this._instance) || null == (i2 = i2.persistence) || i2.register({ ["url" === t2 ? xt : Et]: this.Ct }), this.ai(), this.ki(t2 + "_trigger_matched"));
  }
  ji() {
    this.Kt.urlBlocked || (this.Kt.urlBlocked = true, clearInterval(this.wi), ns.info("recording paused due to URL blocker"), this.ui("recording paused", { reason: "url blocker" }));
  }
  Ni() {
    this.Kt.urlBlocked && (this.Kt.urlBlocked = false, this.Ci(), this.Ti(), this.ui("recording resumed", { reason: "left blocked url" }), ns.info("recording resumed"));
  }
  bi() {
    0 !== this.Yt.Tt.length && F$1(this.ni) && (this.ni = this._instance.on("eventCaptured", (t2) => {
      try {
        this.Yt.Tt.includes(t2.event) && this.zi("event");
      } catch (t3) {
        ns.error("Could not activate event trigger", t3);
      }
    }));
  }
  overrideLinkedFlag() {
    this.Xt.linkedFlagSeen = true, this.Ci(), this.ki("linked_flag_overridden");
  }
  overrideSampling() {
    var t2;
    null == (t2 = this._instance.persistence) || t2.register({ [kt]: true }), this.Ci(), this.ki("sampling_overridden");
  }
  overrideTrigger(t2) {
    this.zi(t2);
  }
  ki(t2, i2) {
    this._instance.register_for_session({ $session_recording_start_reason: t2 }), ns.info(t2.replace("_", " "), i2), m(["recording_initialized", "session_id_changed"], t2) || this.ui(t2, i2);
  }
  get sdkDebugProperties() {
    var { sessionStartTimestamp: t2 } = this.At.checkAndGetSessionAndWindowId(true);
    return { $recording_status: this.status, $sdk_debug_replay_internal_buffer_length: this.C.data.length, $sdk_debug_replay_internal_buffer_size: this.C.size, $sdk_debug_current_session_duration: this.Nt, $sdk_debug_session_start: t2 };
  }
}
var cs = z("[SegmentIntegration]");
function fs(t2, i2) {
  var e2 = t2.config.segment;
  if (!e2) return i2();
  !function(t3, i3) {
    var e3 = t3.config.segment;
    if (!e3) return i3();
    var r2 = (e4) => {
      var r3 = () => e4.anonymousId() || ji();
      t3.config.get_device_id = r3, e4.id() && (t3.register({ distinct_id: e4.id(), $device_id: r3() }), t3.persistence.set_property(At, "identified")), i3();
    }, s2 = e3.user();
    "then" in s2 && E(s2.then) ? s2.then((t4) => r2(t4)) : r2(s2);
  }(t2, () => {
    e2.register(((t3) => {
      Promise && Promise.resolve || cs.warn("This browser does not have Promise support, and can not use the segment integration");
      var i3 = (i4, e3) => {
        if (!e3) return i4;
        i4.event.userId || i4.event.anonymousId === t3.get_distinct_id() || (cs.info("No userId set, resetting PostHog"), t3.reset()), i4.event.userId && i4.event.userId !== t3.get_distinct_id() && (cs.info("UserId set, identifying with PostHog"), t3.identify(i4.event.userId));
        var r2 = t3.calculateEventProperties(e3, i4.event.properties);
        return i4.event.properties = Object.assign({}, r2, i4.event.properties), i4;
      };
      return { name: "PostHog JS", type: "enrichment", version: "1.0.0", isLoaded: () => true, load: () => Promise.resolve(), track: (t4) => i3(t4, t4.event.event), page: (t4) => i3(t4, "$pageview"), identify: (t4) => i3(t4, "$identify"), screen: (t4) => i3(t4, "$screen") };
    })(t2)).then(() => {
      i2();
    });
  });
}
var ps = "posthog-js";
function gs(t2, i2) {
  var { organization: e2, projectId: r2, prefix: s2, severityAllowList: n2 = ["error"] } = void 0 === i2 ? {} : i2;
  return (i3) => {
    var o2, a2, l2, u2, h2;
    if (!("*" === n2 || n2.includes(i3.level)) || !t2.__loaded) return i3;
    i3.tags || (i3.tags = {});
    var d2 = t2.requestRouter.endpointFor("ui", "/project/" + t2.config.token + "/person/" + t2.get_distinct_id());
    i3.tags["PostHog Person URL"] = d2, t2.sessionRecordingStarted() && (i3.tags["PostHog Recording URL"] = t2.get_session_replay_url({ withTimestamp: true }));
    var v2 = (null == (o2 = i3.exception) ? void 0 : o2.values) || [], c2 = v2.map((t3) => B$1({}, t3, { stacktrace: t3.stacktrace ? B$1({}, t3.stacktrace, { type: "raw", frames: (t3.stacktrace.frames || []).map((t4) => B$1({}, t4, { platform: "web:javascript" })) }) : void 0 })), f2 = { $exception_message: (null == (a2 = v2[0]) ? void 0 : a2.value) || i3.message, $exception_type: null == (l2 = v2[0]) ? void 0 : l2.type, $exception_personURL: d2, $exception_level: i3.level, $exception_list: c2, $sentry_event_id: i3.event_id, $sentry_exception: i3.exception, $sentry_exception_message: (null == (u2 = v2[0]) ? void 0 : u2.value) || i3.message, $sentry_exception_type: null == (h2 = v2[0]) ? void 0 : h2.type, $sentry_tags: i3.tags };
    return e2 && r2 && (f2.$sentry_url = (s2 || "https://sentry.io/organizations/") + e2 + "/issues/?project=" + r2 + "&query=" + i3.event_id), t2.exceptions.sendExceptionEvent(f2), i3;
  };
}
class _s {
  constructor(t2, i2, e2, r2, s2) {
    this.name = ps, this.setupOnce = function(n2) {
      n2(gs(t2, { organization: i2, projectId: e2, prefix: r2, severityAllowList: s2 }));
    };
  }
}
var ms = null != t && t.location ? xi(t.location.hash, "__posthog") || xi(location.hash, "state") : null, bs = "_postHogToolbarParams", ys = z("[Toolbar]"), ws = function(t2) {
  return t2[t2.UNINITIALIZED = 0] = "UNINITIALIZED", t2[t2.LOADING = 1] = "LOADING", t2[t2.LOADED = 2] = "LOADED", t2;
}(ws || {});
class Ss {
  constructor(t2) {
    this.instance = t2;
  }
  Hi(t2) {
    v.ph_toolbar_state = t2;
  }
  Wi() {
    var t2;
    return null !== (t2 = v.ph_toolbar_state) && void 0 !== t2 ? t2 : ws.UNINITIALIZED;
  }
  maybeLoadToolbar(i2, e2, r2) {
    if (void 0 === i2 && (i2 = void 0), void 0 === e2 && (e2 = void 0), void 0 === r2 && (r2 = void 0), !t || !o) return false;
    i2 = null != i2 ? i2 : t.location, r2 = null != r2 ? r2 : t.history;
    try {
      if (!e2) {
        try {
          t.localStorage.setItem("test", "test"), t.localStorage.removeItem("test");
        } catch (t2) {
          return false;
        }
        e2 = null == t ? void 0 : t.localStorage;
      }
      var s2, n2 = ms || xi(i2.hash, "__posthog") || xi(i2.hash, "state"), a2 = n2 ? X$2(() => JSON.parse(atob(decodeURIComponent(n2)))) || X$2(() => JSON.parse(decodeURIComponent(n2))) : null;
      return a2 && "ph_authorize" === a2.action ? ((s2 = a2).source = "url", s2 && Object.keys(s2).length > 0 && (a2.desiredHash ? i2.hash = a2.desiredHash : r2 ? r2.replaceState(r2.state, "", i2.pathname + i2.search) : i2.hash = "")) : ((s2 = JSON.parse(e2.getItem(bs) || "{}")).source = "localstorage", delete s2.userIntent), !(!s2.token || this.instance.config.token !== s2.token) && (this.loadToolbar(s2), true);
    } catch (t2) {
      return false;
    }
  }
  Gi(t2) {
    var i2 = v.ph_load_toolbar || v.ph_load_editor;
    !F$1(i2) && E(i2) ? i2(t2, this.instance) : ys.warn("No toolbar load function found");
  }
  loadToolbar(i2) {
    var e2 = !(null == o || !o.getElementById(qt));
    if (!t || e2) return false;
    var r2 = "custom" === this.instance.requestRouter.region && this.instance.config.advanced_disable_toolbar_metrics, s2 = B$1({ token: this.instance.config.token }, i2, { apiURL: this.instance.requestRouter.endpointFor("ui") }, r2 ? { instrument: false } : {});
    if (t.localStorage.setItem(bs, JSON.stringify(B$1({}, s2, { source: void 0 }))), this.Wi() === ws.LOADED) this.Gi(s2);
    else if (this.Wi() === ws.UNINITIALIZED) {
      var n2;
      this.Hi(ws.LOADING), null == (n2 = v.__PosthogExtensions__) || null == n2.loadExternalDependency || n2.loadExternalDependency(this.instance, "toolbar", (t2) => {
        if (t2) return ys.error("[Toolbar] Failed to load", t2), void this.Hi(ws.UNINITIALIZED);
        this.Hi(ws.LOADED), this.Gi(s2);
      }), st(t, "turbolinks:load", () => {
        this.Hi(ws.UNINITIALIZED), this.loadToolbar(s2);
      });
    }
    return true;
  }
  Ji(t2) {
    return this.loadToolbar(t2);
  }
  maybeLoadEditor(t2, i2, e2) {
    return void 0 === t2 && (t2 = void 0), void 0 === i2 && (i2 = void 0), void 0 === e2 && (e2 = void 0), this.maybeLoadToolbar(t2, i2, e2);
  }
}
var $s = z("[TracingHeaders]");
class ks {
  constructor(t2) {
    this.Vi = void 0, this.Ki = void 0, this.nt = () => {
      var t3, i2;
      R(this.Vi) && (null == (t3 = v.__PosthogExtensions__) || null == (t3 = t3.tracingHeadersPatchFns) || t3._patchXHR(this._instance.sessionManager));
      R(this.Ki) && (null == (i2 = v.__PosthogExtensions__) || null == (i2 = i2.tracingHeadersPatchFns) || i2._patchFetch(this._instance.sessionManager));
    }, this._instance = t2;
  }
  J(t2) {
    var i2, e2;
    null != (i2 = v.__PosthogExtensions__) && i2.tracingHeadersPatchFns && t2(), null == (e2 = v.__PosthogExtensions__) || null == e2.loadExternalDependency || e2.loadExternalDependency(this._instance, "tracing-headers", (i3) => {
      if (i3) return $s.error("failed to load script", i3);
      t2();
    });
  }
  startIfEnabledOrStop() {
    var t2, i2;
    this._instance.config.__add_tracing_headers ? this.J(this.nt) : (null == (t2 = this.Vi) || t2.call(this), null == (i2 = this.Ki) || i2.call(this), this.Vi = void 0, this.Ki = void 0);
  }
}
var xs = z("[Web Vitals]"), Es = 9e5;
class Is {
  constructor(t2) {
    var i2;
    this.Yi = false, this.i = false, this.C = { url: void 0, metrics: [], firstMetricTimestamp: void 0 }, this.Xi = () => {
      clearTimeout(this.Qi), 0 !== this.C.metrics.length && (this._instance.capture("$web_vitals", this.C.metrics.reduce((t3, i3) => B$1({}, t3, { ["$web_vitals_" + i3.name + "_event"]: B$1({}, i3), ["$web_vitals_" + i3.name + "_value"]: i3.value }), {})), this.C = { url: void 0, metrics: [], firstMetricTimestamp: void 0 });
    }, this.Zi = (t3) => {
      var i3, e2 = null == (i3 = this._instance.sessionManager) ? void 0 : i3.checkAndGetSessionAndWindowId(true);
      if (R(e2)) xs.error("Could not read session ID. Dropping metrics!");
      else {
        this.C = this.C || { url: void 0, metrics: [], firstMetricTimestamp: void 0 };
        var r2 = this.te();
        if (!R(r2)) if (F$1(null == t3 ? void 0 : t3.name) || F$1(null == t3 ? void 0 : t3.value)) xs.error("Invalid metric received", t3);
        else if (this.ie && t3.value >= this.ie) xs.error("Ignoring metric with value >= " + this.ie, t3);
        else this.C.url !== r2 && (this.Xi(), this.Qi = setTimeout(this.Xi, this.flushToCaptureTimeoutMs)), R(this.C.url) && (this.C.url = r2), this.C.firstMetricTimestamp = R(this.C.firstMetricTimestamp) ? Date.now() : this.C.firstMetricTimestamp, t3.attribution && t3.attribution.interactionTargetElement && (t3.attribution.interactionTargetElement = void 0), this.C.metrics.push(B$1({}, t3, { $current_url: r2, $session_id: e2.sessionId, $window_id: e2.windowId, timestamp: Date.now() })), this.C.metrics.length === this.allowedMetrics.length && this.Xi();
      }
    }, this.nt = () => {
      var t3, i3, e2, r2, s2 = v.__PosthogExtensions__;
      R(s2) || R(s2.postHogWebVitalsCallbacks) || ({ onLCP: t3, onCLS: i3, onFCP: e2, onINP: r2 } = s2.postHogWebVitalsCallbacks), t3 && i3 && e2 && r2 ? (this.allowedMetrics.indexOf("LCP") > -1 && t3(this.Zi.bind(this)), this.allowedMetrics.indexOf("CLS") > -1 && i3(this.Zi.bind(this)), this.allowedMetrics.indexOf("FCP") > -1 && e2(this.Zi.bind(this)), this.allowedMetrics.indexOf("INP") > -1 && r2(this.Zi.bind(this)), this.i = true) : xs.error("web vitals callbacks not loaded - not starting");
    }, this._instance = t2, this.Yi = !(null == (i2 = this._instance.persistence) || !i2.props[vt]), this.startIfEnabled();
  }
  get allowedMetrics() {
    var t2, i2, e2 = I$1(this._instance.config.capture_performance) ? null == (t2 = this._instance.config.capture_performance) ? void 0 : t2.web_vitals_allowed_metrics : void 0;
    return R(e2) ? (null == (i2 = this._instance.persistence) ? void 0 : i2.props[ft]) || ["CLS", "FCP", "INP", "LCP"] : e2;
  }
  get flushToCaptureTimeoutMs() {
    return (I$1(this._instance.config.capture_performance) ? this._instance.config.capture_performance.web_vitals_delayed_flush_ms : void 0) || 5e3;
  }
  get ie() {
    var t2 = I$1(this._instance.config.capture_performance) && O(this._instance.config.capture_performance.__web_vitals_max_value) ? this._instance.config.capture_performance.__web_vitals_max_value : Es;
    return 0 < t2 && t2 <= 6e4 ? Es : t2;
  }
  get isEnabled() {
    var t2 = null == a ? void 0 : a.protocol;
    if ("http:" !== t2 && "https:" !== t2) return xs.info("Web Vitals are disabled on non-http/https protocols"), false;
    var i2 = I$1(this._instance.config.capture_performance) ? this._instance.config.capture_performance.web_vitals : A(this._instance.config.capture_performance) ? this._instance.config.capture_performance : void 0;
    return A(i2) ? i2 : this.Yi;
  }
  startIfEnabled() {
    this.isEnabled && !this.i && (xs.info("enabled, starting..."), this.J(this.nt));
  }
  onRemoteConfig(t2) {
    var i2 = I$1(t2.capturePerformance) && !!t2.capturePerformance.web_vitals, e2 = I$1(t2.capturePerformance) ? t2.capturePerformance.web_vitals_allowed_metrics : void 0;
    this._instance.persistence && (this._instance.persistence.register({ [vt]: i2 }), this._instance.persistence.register({ [ft]: e2 })), this.Yi = i2, this.startIfEnabled();
  }
  J(t2) {
    var i2, e2;
    null != (i2 = v.__PosthogExtensions__) && i2.postHogWebVitalsCallbacks && t2(), null == (e2 = v.__PosthogExtensions__) || null == e2.loadExternalDependency || e2.loadExternalDependency(this._instance, "web-vitals", (i3) => {
      i3 ? xs.error("failed to load script", i3) : t2();
    });
  }
  te() {
    var i2 = t ? t.location.href : void 0;
    return i2 || xs.error("Could not determine current URL"), i2;
  }
}
var Ps = z("[Heatmaps]");
function Rs(t2) {
  return I$1(t2) && "clientX" in t2 && "clientY" in t2 && O(t2.clientX) && O(t2.clientY);
}
class Ts {
  constructor(t2) {
    var i2;
    this.rageclicks = new bi(), this.Yi = false, this.i = false, this.ee = null, this.instance = t2, this.Yi = !(null == (i2 = this.instance.persistence) || !i2.props[ut]);
  }
  get flushIntervalMilliseconds() {
    var t2 = 5e3;
    return I$1(this.instance.config.capture_heatmaps) && this.instance.config.capture_heatmaps.flush_interval_milliseconds && (t2 = this.instance.config.capture_heatmaps.flush_interval_milliseconds), t2;
  }
  get isEnabled() {
    return R(this.instance.config.capture_heatmaps) ? R(this.instance.config.enable_heatmaps) ? this.Yi : this.instance.config.enable_heatmaps : false !== this.instance.config.capture_heatmaps;
  }
  startIfEnabled() {
    if (this.isEnabled) {
      if (this.i) return;
      Ps.info("starting..."), this.re(), this.ee = setInterval(this.se.bind(this), this.flushIntervalMilliseconds);
    } else {
      var t2, i2;
      clearInterval(null !== (t2 = this.ee) && void 0 !== t2 ? t2 : void 0), null == (i2 = this.ne) || i2.stop(), this.getAndClearBuffer();
    }
  }
  onRemoteConfig(t2) {
    var i2 = !!t2.heatmaps;
    this.instance.persistence && this.instance.persistence.register({ [ut]: i2 }), this.Yi = i2, this.startIfEnabled();
  }
  getAndClearBuffer() {
    var t2 = this.C;
    return this.C = void 0, t2;
  }
  oe(t2) {
    this.ae(t2.originalEvent, "deadclick");
  }
  re() {
    t && o && (st(t, "beforeunload", this.se.bind(this)), st(o, "click", (i2) => this.ae(i2 || (null == t ? void 0 : t.event)), { capture: true }), st(o, "mousemove", (i2) => this.le(i2 || (null == t ? void 0 : t.event)), { capture: true }), this.ne = new re$1(this.instance, ie$1, this.oe.bind(this)), this.ne.startIfEnabled(), this.i = true);
  }
  ue(i2, e2) {
    var r2 = this.instance.scrollManager.scrollY(), s2 = this.instance.scrollManager.scrollX(), n2 = this.instance.scrollManager.scrollElement(), o2 = function(i3, e3, r3) {
      for (var s3 = i3; s3 && Gt(s3) && !Jt(s3, "body"); ) {
        if (s3 === r3) return false;
        if (m(e3, null == t ? void 0 : t.getComputedStyle(s3).position)) return true;
        s3 = ri(s3);
      }
      return false;
    }(ii(i2), ["fixed", "sticky"], n2);
    return { x: i2.clientX + (o2 ? 0 : s2), y: i2.clientY + (o2 ? 0 : r2), target_fixed: o2, type: e2 };
  }
  ae(t2, i2) {
    var e2;
    if (void 0 === i2 && (i2 = "click"), !Wt(t2.target) && Rs(t2)) {
      var r2 = this.ue(t2, i2);
      null != (e2 = this.rageclicks) && e2.isRageClick(t2.clientX, t2.clientY, (/* @__PURE__ */ new Date()).getTime()) && this.he(B$1({}, r2, { type: "rageclick" })), this.he(r2);
    }
  }
  le(t2) {
    !Wt(t2.target) && Rs(t2) && (clearTimeout(this.de), this.de = setTimeout(() => {
      this.he(this.ue(t2, "mousemove"));
    }, 500));
  }
  he(i2) {
    if (t) {
      var e2 = t.location.href;
      this.C = this.C || {}, this.C[e2] || (this.C[e2] = []), this.C[e2].push(i2);
    }
  }
  se() {
    this.C && !P(this.C) && this.instance.capture("$$heatmap", { $heatmap_data: this.getAndClearBuffer() });
  }
}
class Ms {
  constructor(t2) {
    this._instance = t2;
  }
  doPageView(i2, e2) {
    var r2, s2 = this.ve(i2, e2);
    return this.ce = { pathname: null !== (r2 = null == t ? void 0 : t.location.pathname) && void 0 !== r2 ? r2 : "", pageViewId: e2, timestamp: i2 }, this._instance.scrollManager.resetContext(), s2;
  }
  doPageLeave(t2) {
    var i2;
    return this.ve(t2, null == (i2 = this.ce) ? void 0 : i2.pageViewId);
  }
  doEvent() {
    var t2;
    return { $pageview_id: null == (t2 = this.ce) ? void 0 : t2.pageViewId };
  }
  ve(t2, i2) {
    var e2 = this.ce;
    if (!e2) return { $pageview_id: i2 };
    var r2 = { $pageview_id: i2, $prev_pageview_id: e2.pageViewId }, s2 = this._instance.scrollManager.getContext();
    if (s2 && !this._instance.config.disable_scroll_properties) {
      var { maxScrollHeight: n2, lastScrollY: o2, maxScrollY: a2, maxContentHeight: l2, lastContentY: u2, maxContentY: h2 } = s2;
      if (!(R(n2) || R(o2) || R(a2) || R(l2) || R(u2) || R(h2))) {
        n2 = Math.ceil(n2), o2 = Math.ceil(o2), a2 = Math.ceil(a2), l2 = Math.ceil(l2), u2 = Math.ceil(u2), h2 = Math.ceil(h2);
        var d2 = n2 <= 1 ? 1 : se$1(o2 / n2, 0, 1), v2 = n2 <= 1 ? 1 : se$1(a2 / n2, 0, 1), c2 = l2 <= 1 ? 1 : se$1(u2 / l2, 0, 1), f2 = l2 <= 1 ? 1 : se$1(h2 / l2, 0, 1);
        r2 = V(r2, { $prev_pageview_last_scroll: o2, $prev_pageview_last_scroll_percentage: d2, $prev_pageview_max_scroll: a2, $prev_pageview_max_scroll_percentage: v2, $prev_pageview_last_content: u2, $prev_pageview_last_content_percentage: c2, $prev_pageview_max_content: h2, $prev_pageview_max_content_percentage: f2 });
      }
    }
    return e2.pathname && (r2.$prev_pageview_pathname = e2.pathname), e2.timestamp && (r2.$prev_pageview_duration = (t2.getTime() - e2.timestamp.getTime()) / 1e3), r2;
  }
}
var Cs = function(t2) {
  var i2, e2, r2, s2, n2 = "";
  for (i2 = e2 = 0, r2 = (t2 = (t2 + "").replace(/\r\n/g, "\n").replace(/\r/g, "\n")).length, s2 = 0; s2 < r2; s2++) {
    var o2 = t2.charCodeAt(s2), a2 = null;
    o2 < 128 ? e2++ : a2 = o2 > 127 && o2 < 2048 ? String.fromCharCode(o2 >> 6 | 192, 63 & o2 | 128) : String.fromCharCode(o2 >> 12 | 224, o2 >> 6 & 63 | 128, 63 & o2 | 128), C(a2) || (e2 > i2 && (n2 += t2.substring(i2, e2)), n2 += a2, i2 = e2 = s2 + 1);
  }
  return e2 > i2 && (n2 += t2.substring(i2, t2.length)), n2;
}, Fs = !!u || !!l, Os = "text/plain", As = (t2, i2) => {
  var [e2, r2] = t2.split("?"), s2 = B$1({}, i2);
  null == r2 || r2.split("&").forEach((t3) => {
    var [i3] = t3.split("=");
    delete s2[i3];
  });
  var n2 = Si(s2);
  return e2 + "?" + (n2 = n2 ? (r2 ? r2 + "&" : "") + n2 : r2);
}, Ds = (t2, i2) => JSON.stringify(t2, (t3, i3) => "bigint" == typeof i3 ? i3.toString() : i3, i2), Ls = (t2) => {
  var { data: i2, compression: e2 } = t2;
  if (i2) {
    if (e2 === g.GZipJS) {
      var r2 = Dr(Lr(Ds(i2)), { mtime: 0 }), s2 = new Blob([r2], { type: Os });
      return { contentType: Os, body: s2, estimatedSize: s2.size };
    }
    if (e2 === g.Base64) {
      var n2 = function(t3) {
        var i3, e3, r3, s3, n3, o3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", a3 = 0, l2 = 0, u2 = "", h2 = [];
        if (!t3) return t3;
        t3 = Cs(t3);
        do {
          i3 = (n3 = t3.charCodeAt(a3++) << 16 | t3.charCodeAt(a3++) << 8 | t3.charCodeAt(a3++)) >> 18 & 63, e3 = n3 >> 12 & 63, r3 = n3 >> 6 & 63, s3 = 63 & n3, h2[l2++] = o3.charAt(i3) + o3.charAt(e3) + o3.charAt(r3) + o3.charAt(s3);
        } while (a3 < t3.length);
        switch (u2 = h2.join(""), t3.length % 3) {
          case 1:
            u2 = u2.slice(0, -2) + "==";
            break;
          case 2:
            u2 = u2.slice(0, -1) + "=";
        }
        return u2;
      }(Ds(i2)), o2 = ((t3) => "data=" + encodeURIComponent("string" == typeof t3 ? t3 : Ds(t3)))(n2);
      return { contentType: "application/x-www-form-urlencoded", body: o2, estimatedSize: new Blob([o2]).size };
    }
    var a2 = Ds(i2);
    return { contentType: "application/json", body: a2, estimatedSize: new Blob([a2]).size };
  }
}, js = [];
l && js.push({ transport: "fetch", method: (t2) => {
  var i2, e2, { contentType: r2, body: s2, estimatedSize: n2 } = null !== (i2 = Ls(t2)) && void 0 !== i2 ? i2 : {}, o2 = new Headers();
  J(t2.headers, function(t3, i3) {
    o2.append(i3, t3);
  }), r2 && o2.append("Content-Type", r2);
  var a2 = t2.url, u2 = null;
  if (h) {
    var d2 = new h();
    u2 = { signal: d2.signal, timeout: setTimeout(() => d2.abort(), t2.timeout) };
  }
  l(a2, B$1({ method: (null == t2 ? void 0 : t2.method) || "GET", headers: o2, keepalive: "POST" === t2.method && (n2 || 0) < 52428.8, body: s2, signal: null == (e2 = u2) ? void 0 : e2.signal }, t2.fetchOptions)).then((i3) => i3.text().then((e3) => {
    var r3 = { statusCode: i3.status, text: e3 };
    if (200 === i3.status) try {
      r3.json = JSON.parse(e3);
    } catch (t3) {
      N.error(t3);
    }
    null == t2.callback || t2.callback(r3);
  })).catch((i3) => {
    N.error(i3), null == t2.callback || t2.callback({ statusCode: 0, text: i3 });
  }).finally(() => u2 ? clearTimeout(u2.timeout) : null);
} }), u && js.push({ transport: "XHR", method: (t2) => {
  var i2, e2 = new u();
  e2.open(t2.method || "GET", t2.url, true);
  var { contentType: r2, body: s2 } = null !== (i2 = Ls(t2)) && void 0 !== i2 ? i2 : {};
  J(t2.headers, function(t3, i3) {
    e2.setRequestHeader(i3, t3);
  }), r2 && e2.setRequestHeader("Content-Type", r2), t2.timeout && (e2.timeout = t2.timeout), e2.withCredentials = true, e2.onreadystatechange = () => {
    if (4 === e2.readyState) {
      var i3 = { statusCode: e2.status, text: e2.responseText };
      if (200 === e2.status) try {
        i3.json = JSON.parse(e2.responseText);
      } catch (t3) {
      }
      null == t2.callback || t2.callback(i3);
    }
  }, e2.send(s2);
} }), null != n && n.sendBeacon && js.push({ transport: "sendBeacon", method: (t2) => {
  var i2 = As(t2.url, { beacon: "1" });
  try {
    var e2, { contentType: r2, body: s2 } = null !== (e2 = Ls(t2)) && void 0 !== e2 ? e2 : {}, o2 = "string" == typeof s2 ? new Blob([s2], { type: r2 }) : s2;
    n.sendBeacon(i2, o2);
  } catch (t3) {
  }
} });
var Ns = function(t2, i2) {
  if (!function(t3) {
    try {
      new RegExp(t3);
    } catch (t4) {
      return false;
    }
    return true;
  }(i2)) return false;
  try {
    return new RegExp(i2).test(t2);
  } catch (t3) {
    return false;
  }
};
function zs(t2, i2, e2) {
  return Ds({ distinct_id: t2, userPropertiesToSet: i2, userPropertiesToSetOnce: e2 });
}
var Us = { exact: (t2, i2) => i2.some((i3) => t2.some((t3) => i3 === t3)), is_not: (t2, i2) => i2.every((i3) => t2.every((t3) => i3 !== t3)), regex: (t2, i2) => i2.some((i3) => t2.some((t3) => Ns(i3, t3))), not_regex: (t2, i2) => i2.every((i3) => t2.every((t3) => !Ns(i3, t3))), icontains: (t2, i2) => i2.map(qs).some((i3) => t2.map(qs).some((t3) => i3.includes(t3))), not_icontains: (t2, i2) => i2.map(qs).every((i3) => t2.map(qs).every((t3) => !i3.includes(t3))) }, qs = (t2) => t2.toLowerCase(), Bs = z("[Error tracking]");
class Hs {
  constructor(t2) {
    var i2, e2;
    this.fe = [], this._instance = t2, this.fe = null !== (i2 = null == (e2 = this._instance.persistence) ? void 0 : e2.get_property(dt)) && void 0 !== i2 ? i2 : [];
  }
  onRemoteConfig(t2) {
    var i2, e2, r2 = null !== (i2 = null == (e2 = t2.errorTracking) ? void 0 : e2.suppressionRules) && void 0 !== i2 ? i2 : [];
    this.fe = r2, this._instance.persistence && this._instance.persistence.register({ [dt]: this.fe });
  }
  sendExceptionEvent(t2) {
    this.pe(t2) ? Bs.info("Skipping exception capture because a suppression rule matched") : this._instance.capture("$exception", t2, { _noTruncate: true, _batchKey: "exceptionEvent" });
  }
  pe(t2) {
    var i2 = t2.$exception_list;
    if (!i2 || !x(i2) || 0 === i2.length) return false;
    var e2 = i2.reduce((t3, i3) => {
      var { type: e3, value: r2 } = i3;
      return T(e3) && e3.length > 0 && t3.$exception_types.push(e3), T(r2) && r2.length > 0 && t3.$exception_values.push(r2), t3;
    }, { $exception_types: [], $exception_values: [] });
    return this.fe.some((t3) => {
      var i3 = t3.values.map((t4) => {
        var i4, r2 = Us[t4.operator], s2 = x(t4.value) ? t4.value : [t4.value], n2 = null !== (i4 = e2[t4.key]) && void 0 !== i4 ? i4 : [];
        return s2.length > 0 && r2(s2, n2);
      });
      return "OR" === t3.type ? i3.some(Boolean) : i3.every(Boolean);
    });
  }
}
var Ws = "Mobile", Gs = "iOS", Js = "Android", Vs = "Tablet", Ks = Js + " " + Vs, Ys = "iPad", Xs = "Apple", Qs = Xs + " Watch", Zs = "Safari", tn = "BlackBerry", en = "Samsung", rn = en + "Browser", sn = en + " Internet", nn = "Chrome", on = nn + " OS", an = nn + " " + Gs, ln = "Internet Explorer", un = ln + " " + Ws, hn = "Opera", dn = hn + " Mini", vn = "Edge", cn = "Microsoft " + vn, fn = "Firefox", pn = fn + " " + Gs, gn = "Nintendo", _n = "PlayStation", mn = "Xbox", bn = Js + " " + Ws, yn = Ws + " " + Zs, wn = "Windows", Sn = wn + " Phone", $n = "Nokia", kn = "Ouya", xn = "Generic", En = xn + " " + Ws.toLowerCase(), In = xn + " " + Vs.toLowerCase(), Pn = "Konqueror", Rn = "(\\d+(\\.\\d+)?)", Tn = new RegExp("Version/" + Rn), Mn = new RegExp(mn, "i"), Cn = new RegExp(_n + " \\w+", "i"), Fn = new RegExp(gn + " \\w+", "i"), On = new RegExp(tn + "|PlayBook|BB10", "i"), An = { "NT3.51": "NT 3.11", "NT4.0": "NT 4.0", "5.0": "2000", 5.1: "XP", 5.2: "XP", "6.0": "Vista", 6.1: "7", 6.2: "8", 6.3: "8.1", 6.4: "10", "10.0": "10" };
var Dn = (t2, i2) => i2 && m(i2, Xs) || function(t3) {
  return m(t3, Zs) && !m(t3, nn) && !m(t3, Js);
}(t2), Ln = function(t2, i2) {
  return i2 = i2 || "", m(t2, " OPR/") && m(t2, "Mini") ? dn : m(t2, " OPR/") ? hn : On.test(t2) ? tn : m(t2, "IE" + Ws) || m(t2, "WPDesktop") ? un : m(t2, rn) ? sn : m(t2, vn) || m(t2, "Edg/") ? cn : m(t2, "FBIOS") ? "Facebook " + Ws : m(t2, "UCWEB") || m(t2, "UCBrowser") ? "UC Browser" : m(t2, "CriOS") ? an : m(t2, "CrMo") || m(t2, nn) ? nn : m(t2, Js) && m(t2, Zs) ? bn : m(t2, "FxiOS") ? pn : m(t2.toLowerCase(), Pn.toLowerCase()) ? Pn : Dn(t2, i2) ? m(t2, Ws) ? yn : Zs : m(t2, fn) ? fn : m(t2, "MSIE") || m(t2, "Trident/") ? ln : m(t2, "Gecko") ? fn : "";
}, jn = { [un]: [new RegExp("rv:" + Rn)], [cn]: [new RegExp(vn + "?\\/" + Rn)], [nn]: [new RegExp("(" + nn + "|CrMo)\\/" + Rn)], [an]: [new RegExp("CriOS\\/" + Rn)], "UC Browser": [new RegExp("(UCBrowser|UCWEB)\\/" + Rn)], [Zs]: [Tn], [yn]: [Tn], [hn]: [new RegExp("(Opera|OPR)\\/" + Rn)], [fn]: [new RegExp(fn + "\\/" + Rn)], [pn]: [new RegExp("FxiOS\\/" + Rn)], [Pn]: [new RegExp("Konqueror[:/]?" + Rn, "i")], [tn]: [new RegExp(tn + " " + Rn), Tn], [bn]: [new RegExp("android\\s" + Rn, "i")], [sn]: [new RegExp(rn + "\\/" + Rn)], [ln]: [new RegExp("(rv:|MSIE )" + Rn)], Mozilla: [new RegExp("rv:" + Rn)] }, Nn = function(t2, i2) {
  var e2 = Ln(t2, i2), r2 = jn[e2];
  if (R(r2)) return null;
  for (var s2 = 0; s2 < r2.length; s2++) {
    var n2 = r2[s2], o2 = t2.match(n2);
    if (o2) return parseFloat(o2[o2.length - 2]);
  }
  return null;
}, zn = [[new RegExp(mn + "; " + mn + " (.*?)[);]", "i"), (t2) => [mn, t2 && t2[1] || ""]], [new RegExp(gn, "i"), [gn, ""]], [new RegExp(_n, "i"), [_n, ""]], [On, [tn, ""]], [new RegExp(wn, "i"), (t2, i2) => {
  if (/Phone/.test(i2) || /WPDesktop/.test(i2)) return [Sn, ""];
  if (new RegExp(Ws).test(i2) && !/IEMobile\b/.test(i2)) return [wn + " " + Ws, ""];
  var e2 = /Windows NT ([0-9.]+)/i.exec(i2);
  if (e2 && e2[1]) {
    var r2 = e2[1], s2 = An[r2] || "";
    return /arm/i.test(i2) && (s2 = "RT"), [wn, s2];
  }
  return [wn, ""];
}], [/((iPhone|iPad|iPod).*?OS (\d+)_(\d+)_?(\d+)?|iPhone)/, (t2) => {
  if (t2 && t2[3]) {
    var i2 = [t2[3], t2[4], t2[5] || "0"];
    return [Gs, i2.join(".")];
  }
  return [Gs, ""];
}], [/(watch.*\/(\d+\.\d+\.\d+)|watch os,(\d+\.\d+),)/i, (t2) => {
  var i2 = "";
  return t2 && t2.length >= 3 && (i2 = R(t2[2]) ? t2[3] : t2[2]), ["watchOS", i2];
}], [new RegExp("(" + Js + " (\\d+)\\.(\\d+)\\.?(\\d+)?|" + Js + ")", "i"), (t2) => {
  if (t2 && t2[2]) {
    var i2 = [t2[2], t2[3], t2[4] || "0"];
    return [Js, i2.join(".")];
  }
  return [Js, ""];
}], [/Mac OS X (\d+)[_.](\d+)[_.]?(\d+)?/i, (t2) => {
  var i2 = ["Mac OS X", ""];
  if (t2 && t2[1]) {
    var e2 = [t2[1], t2[2], t2[3] || "0"];
    i2[1] = e2.join(".");
  }
  return i2;
}], [/Mac/i, ["Mac OS X", ""]], [/CrOS/, [on, ""]], [/Linux|debian/i, ["Linux", ""]]], Un = function(t2) {
  return Fn.test(t2) ? gn : Cn.test(t2) ? _n : Mn.test(t2) ? mn : new RegExp(kn, "i").test(t2) ? kn : new RegExp("(" + Sn + "|WPDesktop)", "i").test(t2) ? Sn : /iPad/.test(t2) ? Ys : /iPod/.test(t2) ? "iPod Touch" : /iPhone/.test(t2) ? "iPhone" : /(watch)(?: ?os[,/]|\d,\d\/)[\d.]+/i.test(t2) ? Qs : On.test(t2) ? tn : /(kobo)\s(ereader|touch)/i.test(t2) ? "Kobo" : new RegExp($n, "i").test(t2) ? $n : /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i.test(t2) || /(kf[a-z]+)( bui|\)).+silk\//i.test(t2) ? "Kindle Fire" : /(Android|ZTE)/i.test(t2) ? !new RegExp(Ws).test(t2) || /(9138B|TB782B|Nexus [97]|pixel c|HUAWEISHT|BTV|noble nook|smart ultra 6)/i.test(t2) ? /pixel[\daxl ]{1,6}/i.test(t2) && !/pixel c/i.test(t2) || /(huaweimed-al00|tah-|APA|SM-G92|i980|zte|U304AA)/i.test(t2) || /lmy47v/i.test(t2) && !/QTAQZ3/i.test(t2) ? Js : Ks : Js : new RegExp("(pda|" + Ws + ")", "i").test(t2) ? En : new RegExp(Vs, "i").test(t2) && !new RegExp(Vs + " pc", "i").test(t2) ? In : "";
}, qn = "https?://(.*)", Bn = ["gclid", "gclsrc", "dclid", "gbraid", "wbraid", "fbclid", "msclkid", "twclid", "li_fat_id", "igshid", "ttclid", "rdt_cid", "epik", "qclid", "sccid", "irclid", "_kx"], Hn = K(["utm_source", "utm_medium", "utm_campaign", "utm_content", "utm_term", "gad_source", "mc_cid"], Bn), Wn = "<masked>";
function Gn(t2, i2, e2) {
  if (!o) return {};
  var r2 = i2 ? K([], Bn, e2 || []) : [];
  return Jn(ki(o.URL, r2, Wn), t2);
}
function Jn(t2, i2) {
  var e2 = Hn.concat(i2 || []), r2 = {};
  return J(e2, function(i3) {
    var e3 = $i(t2, i3);
    r2[i3] = e3 || null;
  }), r2;
}
function Vn(t2) {
  var i2 = function(t3) {
    return t3 ? 0 === t3.search(qn + "google.([^/?]*)") ? "google" : 0 === t3.search(qn + "bing.com") ? "bing" : 0 === t3.search(qn + "yahoo.com") ? "yahoo" : 0 === t3.search(qn + "duckduckgo.com") ? "duckduckgo" : null : null;
  }(t2), e2 = "yahoo" != i2 ? "q" : "p", r2 = {};
  if (!C(i2)) {
    r2.$search_engine = i2;
    var s2 = o ? $i(o.referrer, e2) : "";
    s2.length && (r2.ph_keyword = s2);
  }
  return r2;
}
function Kn() {
  return navigator.language || navigator.userLanguage;
}
function Yn() {
  return (null == o ? void 0 : o.referrer) || "$direct";
}
function Xn(t2, i2) {
  var e2 = t2 ? K([], Bn, i2 || []) : [], r2 = null == a ? void 0 : a.href.substring(0, 1e3);
  return { r: Yn().substring(0, 1e3), u: r2 ? ki(r2, e2, Wn) : void 0 };
}
function Qn(t2) {
  var i2, { r: e2, u: r2 } = t2, s2 = { $referrer: e2, $referring_domain: null == e2 ? void 0 : "$direct" == e2 ? "$direct" : null == (i2 = wi(e2)) ? void 0 : i2.host };
  if (r2) {
    s2.$current_url = r2;
    var n2 = wi(r2);
    s2.$host = null == n2 ? void 0 : n2.host, s2.$pathname = null == n2 ? void 0 : n2.pathname;
    var o2 = Jn(r2);
    V(s2, o2);
  }
  if (e2) {
    var a2 = Vn(e2);
    V(s2, a2);
  }
  return s2;
}
function Zn() {
  try {
    return Intl.DateTimeFormat().resolvedOptions().timeZone;
  } catch (t2) {
    return;
  }
}
function to() {
  try {
    return (/* @__PURE__ */ new Date()).getTimezoneOffset();
  } catch (t2) {
    return;
  }
}
function io(i2, e2) {
  if (!d) return {};
  var r2, s2, n2, o2 = i2 ? K([], Bn, e2 || []) : [], [l2, u2] = function(t2) {
    for (var i3 = 0; i3 < zn.length; i3++) {
      var [e3, r3] = zn[i3], s3 = e3.exec(t2), n3 = s3 && (E(r3) ? r3(s3, t2) : r3);
      if (n3) return n3;
    }
    return ["", ""];
  }(d);
  return V(Z({ $os: l2, $os_version: u2, $browser: Ln(d, navigator.vendor), $device: Un(d), $device_type: (s2 = d, n2 = Un(s2), n2 === Ys || n2 === Ks || "Kobo" === n2 || "Kindle Fire" === n2 || n2 === In ? Vs : n2 === gn || n2 === mn || n2 === _n || n2 === kn ? "Console" : n2 === Qs ? "Wearable" : n2 ? Ws : "Desktop"), $timezone: Zn(), $timezone_offset: to() }), { $current_url: ki(null == a ? void 0 : a.href, o2, Wn), $host: null == a ? void 0 : a.host, $pathname: null == a ? void 0 : a.pathname, $raw_user_agent: d.length > 1e3 ? d.substring(0, 997) + "..." : d, $browser_version: Nn(d, navigator.vendor), $browser_language: Kn(), $browser_language_prefix: (r2 = Kn(), "string" == typeof r2 ? r2.split("-")[0] : void 0), $screen_height: null == t ? void 0 : t.screen.height, $screen_width: null == t ? void 0 : t.screen.width, $viewport_height: null == t ? void 0 : t.innerHeight, $viewport_width: null == t ? void 0 : t.innerWidth, $lib: "web", $lib_version: c.LIB_VERSION, $insert_id: Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10), $time: Date.now() / 1e3 });
}
var eo = z("[FeatureFlags]"), ro = "$active_feature_flags", so = "$override_feature_flags", no = "$feature_flag_payloads", oo = "$override_feature_flag_payloads", ao = "$feature_flag_request_id", lo = (t2) => {
  var i2 = {};
  for (var [e2, r2] of Y(t2 || {})) r2 && (i2[e2] = r2);
  return i2;
}, uo = (t2) => {
  var i2 = t2.flags;
  return i2 ? (t2.featureFlags = Object.fromEntries(Object.keys(i2).map((t3) => {
    var e2;
    return [t3, null !== (e2 = i2[t3].variant) && void 0 !== e2 ? e2 : i2[t3].enabled];
  })), t2.featureFlagPayloads = Object.fromEntries(Object.keys(i2).filter((t3) => i2[t3].enabled).filter((t3) => {
    var e2;
    return null == (e2 = i2[t3].metadata) ? void 0 : e2.payload;
  }).map((t3) => {
    var e2;
    return [t3, null == (e2 = i2[t3].metadata) ? void 0 : e2.payload];
  }))) : eo.warn("Using an older version of the feature flags endpoint. Please upgrade your PostHog server to the latest version"), t2;
}, ho = function(t2) {
  return t2.FeatureFlags = "feature_flags", t2.Recordings = "recordings", t2;
}({});
var vo = /* @__PURE__ */ new Set(["7c6f7b45", "66c1f69c", "2727f65a", "f3287528", "8cc9a311", "eb9f671b", "c0e1c6f9", "057989ec", "723f4019", "7b102104", "563359d3", "bad973ea", "f6f2c4f4", "59454a61", "89ad1076", "4edd0da1", "26c52e72", "a970bd2e", "89cf4454", "16e2b4e7", "fba0e7b6", "301c8488", "bc65d69e", "fe66a3c5", "37926ca6", "52a196df", "d32a7577", "42c4c9ef", "6883bd5a", "04809ff7", "e59430a8", "61be3dd8", "7fa5500b", "bf027177", "8cfdba9b", "96f6df5f", "569798e9", "0ebc61a5", "1b5d7b92", "17ebb0a4", "f97ea965", "85cc817b", "3044dfc1", "0c3fe5c3", "b1f95fa3", "8a6342e8", "72365c68", "12d34ad9", "733853ec", "3beeb69a", "0645bb64", "32de7f98", "5dcbee21", "3fe85053", "ad960278", "9466e5dd", "7ca97b2d", "2ee2a65c", "28fde5f2", "85c52f49", "0ad823f4", "f11b6cc9", "aacf8af9", "ab3e62b3", "3a85ff15", "8a67d3c4", "f5e91ef1", "4b873698", "c5dae949", "5b643d76", "9599c892", "34377448", "2189e408", "3be9ad53", "1a14ce7c", "2a164ded", "8d53ea86", "53bdb37d", "bfc3f590", "8df38ede", "bdb81e49", "38fde5c0", "8d707e6d", "73cbc496", "f9d8a5ef", "d3a9f8c4", "a980d8cd", "5bcfe086", "e4818f68", "4f11fb39", "a13c6ae3", "150c7fbb", "98f3d658", "f84f7377", "1924dd9c", "1f6b63b3", "24748755", "7c0f717c", "8a87f11b", "49f57f22", "3c9e9234", "3772f65b", "dff631b6", "cd609d40", "f853c7f7", "952db5ee", "c5aa8a79", "2d21b6fd", "79b7164c", "4110e26c", "a7d3b43f", "84e1b8f6", "75cc0998", "07f78e33", "10ca9b1a", "ce441b18", "01eb8256", "c0ac4b67", "8e8e5216", "db7943dd", "fa133a95", "498a4508", "21bbda67", "7dbfed69", "be3ec24c", "fc80b8e2"]);
class co {
  constructor(t2) {
    this.ge = false, this._e = false, this.me = false, this.be = false, this.ye = false, this.we = false, this.Se = false, this._instance = t2, this.featureFlagEventHandlers = [];
  }
  flags() {
    if (this._instance.config.__preview_remote_config) this.we = true;
    else {
      var t2 = !this.$e && (this._instance.config.advanced_disable_feature_flags || this._instance.config.advanced_disable_feature_flags_on_first_load);
      this.ke({ disableFlags: t2 });
    }
  }
  get hasLoadedFlags() {
    return this._e;
  }
  getFlags() {
    return Object.keys(this.getFlagVariants());
  }
  getFlagsWithDetails() {
    var t2 = this._instance.get_property(Rt), i2 = this._instance.get_property(so), e2 = this._instance.get_property(oo);
    if (!e2 && !i2) return t2 || {};
    var r2 = V({}, t2 || {}), s2 = [.../* @__PURE__ */ new Set([...Object.keys(e2 || {}), ...Object.keys(i2 || {})])];
    for (var n2 of s2) {
      var o2, a2, l2 = r2[n2], u2 = null == i2 ? void 0 : i2[n2], h2 = R(u2) ? null !== (o2 = null == l2 ? void 0 : l2.enabled) && void 0 !== o2 && o2 : !!u2, d2 = R(u2) ? l2.variant : "string" == typeof u2 ? u2 : void 0, v2 = null == e2 ? void 0 : e2[n2], c2 = B$1({}, l2, { enabled: h2, variant: h2 ? null != d2 ? d2 : null == l2 ? void 0 : l2.variant : void 0 });
      if (h2 !== (null == l2 ? void 0 : l2.enabled) && (c2.original_enabled = null == l2 ? void 0 : l2.enabled), d2 !== (null == l2 ? void 0 : l2.variant) && (c2.original_variant = null == l2 ? void 0 : l2.variant), v2) c2.metadata = B$1({}, null == l2 ? void 0 : l2.metadata, { payload: v2, original_payload: null == l2 || null == (a2 = l2.metadata) ? void 0 : a2.payload });
      r2[n2] = c2;
    }
    return this.ge || (eo.warn(" Overriding feature flag details!", { flagDetails: t2, overriddenPayloads: e2, finalDetails: r2 }), this.ge = true), r2;
  }
  getFlagVariants() {
    var t2 = this._instance.get_property(It), i2 = this._instance.get_property(so);
    if (!i2) return t2 || {};
    for (var e2 = V({}, t2), r2 = Object.keys(i2), s2 = 0; s2 < r2.length; s2++) e2[r2[s2]] = i2[r2[s2]];
    return this.ge || (eo.warn(" Overriding feature flags!", { enabledFlags: t2, overriddenFlags: i2, finalFlags: e2 }), this.ge = true), e2;
  }
  getFlagPayloads() {
    var t2 = this._instance.get_property(no), i2 = this._instance.get_property(oo);
    if (!i2) return t2 || {};
    for (var e2 = V({}, t2 || {}), r2 = Object.keys(i2), s2 = 0; s2 < r2.length; s2++) e2[r2[s2]] = i2[r2[s2]];
    return this.ge || (eo.warn(" Overriding feature flag payloads!", { flagPayloads: t2, overriddenPayloads: i2, finalPayloads: e2 }), this.ge = true), e2;
  }
  reloadFeatureFlags() {
    this.be || this._instance.config.advanced_disable_feature_flags || this.$e || (this.$e = setTimeout(() => {
      this.ke();
    }, 5));
  }
  xe() {
    clearTimeout(this.$e), this.$e = void 0;
  }
  ensureFlagsLoaded() {
    this._e || this.me || this.$e || this.reloadFeatureFlags();
  }
  setAnonymousDistinctId(t2) {
    this.$anon_distinct_id = t2;
  }
  setReloadingPaused(t2) {
    this.be = t2;
  }
  ke(t2) {
    var i2;
    if (this.xe(), !this._instance.I()) if (this.me) this.ye = true;
    else {
      var e2 = { token: this._instance.config.token, distinct_id: this._instance.get_distinct_id(), groups: this._instance.getGroups(), $anon_distinct_id: this.$anon_distinct_id, person_properties: B$1({}, (null == (i2 = this._instance.persistence) ? void 0 : i2.get_initial_props()) || {}, this._instance.get_property(Tt) || {}), group_properties: this._instance.get_property(Mt) };
      (null != t2 && t2.disableFlags || this._instance.config.advanced_disable_feature_flags) && (e2.disable_flags = true);
      var r2 = this._instance.config.__preview_flags_v2 && this._instance.config.__preview_remote_config, s2 = function(t3) {
        var i3 = function(t4) {
          for (var i4 = 2166136261, e3 = 0; e3 < t4.length; e3++) i4 ^= t4.charCodeAt(e3), i4 += (i4 << 1) + (i4 << 4) + (i4 << 7) + (i4 << 8) + (i4 << 24);
          return ("00000000" + (i4 >>> 0).toString(16)).slice(-8);
        }(t3);
        return null == vo ? void 0 : vo.has(i3);
      }(this._instance.config.token) ? "/decide?v=4" : r2 ? "/flags/?v=2" : "/flags/?v=2&config=true", n2 = this._instance.config.advanced_only_evaluate_survey_feature_flags ? "&only_evaluate_survey_feature_flags=true" : "", o2 = this._instance.requestRouter.endpointFor("api", s2 + n2);
      r2 && (e2.timezone = Zn()), this.me = true, this._instance.Ee({ method: "POST", url: o2, data: e2, compression: this._instance.config.disable_compression ? void 0 : g.Base64, timeout: this._instance.config.feature_flag_request_timeout_ms, callback: (t3) => {
        var i3, r3, s3 = true;
        (200 === t3.statusCode && (this.ye || (this.$anon_distinct_id = void 0), s3 = false), this.me = false, this.we) || (this.we = true, this._instance.Ie(null !== (r3 = t3.json) && void 0 !== r3 ? r3 : {}));
        if (!e2.disable_flags || this.ye) if (this.Se = !s3, t3.json && null != (i3 = t3.json.quotaLimited) && i3.includes(ho.FeatureFlags)) eo.warn("You have hit your feature flags quota limit, and will not be able to load feature flags until the quota is reset.  Please visit https://posthog.com/docs/billing/limits-alerts to learn more.");
        else {
          var n3;
          if (!e2.disable_flags) this.receivedFeatureFlags(null !== (n3 = t3.json) && void 0 !== n3 ? n3 : {}, s3);
          this.ye && (this.ye = false, this.ke());
        }
      } });
    }
  }
  getFeatureFlag(t2, i2) {
    if (void 0 === i2 && (i2 = {}), this._e || this.getFlags() && this.getFlags().length > 0) {
      var e2 = this.getFlagVariants()[t2], r2 = "" + e2, s2 = this._instance.get_property(ao) || void 0, n2 = this._instance.get_property(Ot) || {};
      if ((i2.send_event || !("send_event" in i2)) && (!(t2 in n2) || !n2[t2].includes(r2))) {
        var o2, a2, l2, u2, h2, d2, v2, c2, f2;
        x(n2[t2]) ? n2[t2].push(r2) : n2[t2] = [r2], null == (o2 = this._instance.persistence) || o2.register({ [Ot]: n2 });
        var p2 = this.getFeatureFlagDetails(t2), g2 = { $feature_flag: t2, $feature_flag_response: e2, $feature_flag_payload: this.getFeatureFlagPayload(t2) || null, $feature_flag_request_id: s2, $feature_flag_bootstrapped_response: (null == (a2 = this._instance.config.bootstrap) || null == (a2 = a2.featureFlags) ? void 0 : a2[t2]) || null, $feature_flag_bootstrapped_payload: (null == (l2 = this._instance.config.bootstrap) || null == (l2 = l2.featureFlagPayloads) ? void 0 : l2[t2]) || null, $used_bootstrap_value: !this.Se };
        R(null == p2 || null == (u2 = p2.metadata) ? void 0 : u2.version) || (g2.$feature_flag_version = p2.metadata.version);
        var _2, m2 = null !== (h2 = null == p2 || null == (d2 = p2.reason) ? void 0 : d2.description) && void 0 !== h2 ? h2 : null == p2 || null == (v2 = p2.reason) ? void 0 : v2.code;
        if (m2 && (g2.$feature_flag_reason = m2), null != p2 && null != (c2 = p2.metadata) && c2.id && (g2.$feature_flag_id = p2.metadata.id), R(null == p2 ? void 0 : p2.original_variant) && R(null == p2 ? void 0 : p2.original_enabled) || (g2.$feature_flag_original_response = R(p2.original_variant) ? p2.original_enabled : p2.original_variant), null != p2 && null != (f2 = p2.metadata) && f2.original_payload) g2.$feature_flag_original_payload = null == p2 || null == (_2 = p2.metadata) ? void 0 : _2.original_payload;
        this._instance.capture("$feature_flag_called", g2);
      }
      return e2;
    }
    eo.warn('getFeatureFlag for key "' + t2 + `" failed. Feature flags didn't load in time.`);
  }
  getFeatureFlagDetails(t2) {
    return this.getFlagsWithDetails()[t2];
  }
  getFeatureFlagPayload(t2) {
    return this.getFlagPayloads()[t2];
  }
  getRemoteConfigPayload(t2, i2) {
    var e2 = this._instance.config.token;
    this._instance.Ee({ method: "POST", url: this._instance.requestRouter.endpointFor("api", "/flags/?v=2&config=true"), data: { distinct_id: this._instance.get_distinct_id(), token: e2 }, compression: this._instance.config.disable_compression ? void 0 : g.Base64, timeout: this._instance.config.feature_flag_request_timeout_ms, callback: (e3) => {
      var r2, s2 = null == (r2 = e3.json) ? void 0 : r2.featureFlagPayloads;
      i2((null == s2 ? void 0 : s2[t2]) || void 0);
    } });
  }
  isFeatureEnabled(t2, i2) {
    if (void 0 === i2 && (i2 = {}), this._e || this.getFlags() && this.getFlags().length > 0) return !!this.getFeatureFlag(t2, i2);
    eo.warn('isFeatureEnabled for key "' + t2 + `" failed. Feature flags didn't load in time.`);
  }
  addFeatureFlagsHandler(t2) {
    this.featureFlagEventHandlers.push(t2);
  }
  removeFeatureFlagsHandler(t2) {
    this.featureFlagEventHandlers = this.featureFlagEventHandlers.filter((i2) => i2 !== t2);
  }
  receivedFeatureFlags(t2, i2) {
    if (this._instance.persistence) {
      this._e = true;
      var e2 = this.getFlagVariants(), r2 = this.getFlagPayloads(), s2 = this.getFlagsWithDetails();
      !function(t3, i3, e3, r3, s3) {
        void 0 === e3 && (e3 = {}), void 0 === r3 && (r3 = {}), void 0 === s3 && (s3 = {});
        var n2 = uo(t3), o2 = n2.flags, a2 = n2.featureFlags, l2 = n2.featureFlagPayloads;
        if (a2) {
          var u2 = t3.requestId;
          if (x(a2)) {
            eo.warn("v1 of the feature flags endpoint is deprecated. Please use the latest version.");
            var h2 = {};
            if (a2) for (var d2 = 0; d2 < a2.length; d2++) h2[a2[d2]] = true;
            i3 && i3.register({ [ro]: a2, [It]: h2 });
          } else {
            var v2 = a2, c2 = l2, f2 = o2;
            t3.errorsWhileComputingFlags && (v2 = B$1({}, e3, v2), c2 = B$1({}, r3, c2), f2 = B$1({}, s3, f2)), i3 && i3.register(B$1({ [ro]: Object.keys(lo(v2)), [It]: v2 || {}, [no]: c2 || {}, [Rt]: f2 || {} }, u2 ? { [ao]: u2 } : {}));
          }
        }
      }(t2, this._instance.persistence, e2, r2, s2), this.Pe(i2);
    }
  }
  override(t2, i2) {
    void 0 === i2 && (i2 = false), eo.warn("override is deprecated. Please use overrideFeatureFlags instead."), this.overrideFeatureFlags({ flags: t2, suppressWarning: i2 });
  }
  overrideFeatureFlags(t2) {
    if (!this._instance.__loaded || !this._instance.persistence) return eo.uninitializedWarning("posthog.featureFlags.overrideFeatureFlags");
    if (false === t2) return this._instance.persistence.unregister(so), this._instance.persistence.unregister(oo), void this.Pe();
    if (t2 && "object" == typeof t2 && ("flags" in t2 || "payloads" in t2)) {
      var i2, e2 = t2;
      if (this.ge = Boolean(null !== (i2 = e2.suppressWarning) && void 0 !== i2 && i2), "flags" in e2) {
        if (false === e2.flags) this._instance.persistence.unregister(so);
        else if (e2.flags) if (x(e2.flags)) {
          for (var r2 = {}, s2 = 0; s2 < e2.flags.length; s2++) r2[e2.flags[s2]] = true;
          this._instance.persistence.register({ [so]: r2 });
        } else this._instance.persistence.register({ [so]: e2.flags });
      }
      return "payloads" in e2 && (false === e2.payloads ? this._instance.persistence.unregister(oo) : e2.payloads && this._instance.persistence.register({ [oo]: e2.payloads })), void this.Pe();
    }
    this.Pe();
  }
  onFeatureFlags(t2) {
    if (this.addFeatureFlagsHandler(t2), this._e) {
      var { flags: i2, flagVariants: e2 } = this.Re();
      t2(i2, e2);
    }
    return () => this.removeFeatureFlagsHandler(t2);
  }
  updateEarlyAccessFeatureEnrollment(t2, i2) {
    var e2, r2 = (this._instance.get_property(Pt) || []).find((i3) => i3.flagKey === t2), s2 = { ["$feature_enrollment/" + t2]: i2 }, n2 = { $feature_flag: t2, $feature_enrollment: i2, $set: s2 };
    r2 && (n2.$early_access_feature_name = r2.name), this._instance.capture("$feature_enrollment_update", n2), this.setPersonPropertiesForFlags(s2, false);
    var o2 = B$1({}, this.getFlagVariants(), { [t2]: i2 });
    null == (e2 = this._instance.persistence) || e2.register({ [ro]: Object.keys(lo(o2)), [It]: o2 }), this.Pe();
  }
  getEarlyAccessFeatures(t2, i2, e2) {
    void 0 === i2 && (i2 = false);
    var r2 = this._instance.get_property(Pt), s2 = e2 ? "&" + e2.map((t3) => "stage=" + t3).join("&") : "";
    if (r2 && !i2) return t2(r2);
    this._instance.Ee({ url: this._instance.requestRouter.endpointFor("api", "/api/early_access_features/?token=" + this._instance.config.token + s2), method: "GET", callback: (i3) => {
      var e3;
      if (i3.json) {
        var r3 = i3.json.earlyAccessFeatures;
        return null == (e3 = this._instance.persistence) || e3.register({ [Pt]: r3 }), t2(r3);
      }
    } });
  }
  Re() {
    var t2 = this.getFlags(), i2 = this.getFlagVariants();
    return { flags: t2.filter((t3) => i2[t3]), flagVariants: Object.keys(i2).filter((t3) => i2[t3]).reduce((t3, e2) => (t3[e2] = i2[e2], t3), {}) };
  }
  Pe(t2) {
    var { flags: i2, flagVariants: e2 } = this.Re();
    this.featureFlagEventHandlers.forEach((r2) => r2(i2, e2, { errorsLoading: t2 }));
  }
  setPersonPropertiesForFlags(t2, i2) {
    void 0 === i2 && (i2 = true);
    var e2 = this._instance.get_property(Tt) || {};
    this._instance.register({ [Tt]: B$1({}, e2, t2) }), i2 && this._instance.reloadFeatureFlags();
  }
  resetPersonPropertiesForFlags() {
    this._instance.unregister(Tt);
  }
  setGroupPropertiesForFlags(t2, i2) {
    void 0 === i2 && (i2 = true);
    var e2 = this._instance.get_property(Mt) || {};
    0 !== Object.keys(e2).length && Object.keys(e2).forEach((i3) => {
      e2[i3] = B$1({}, e2[i3], t2[i3]), delete t2[i3];
    }), this._instance.register({ [Mt]: B$1({}, e2, t2) }), i2 && this._instance.reloadFeatureFlags();
  }
  resetGroupPropertiesForFlags(t2) {
    if (t2) {
      var i2 = this._instance.get_property(Mt) || {};
      this._instance.register({ [Mt]: B$1({}, i2, { [t2]: {} }) });
    } else this._instance.unregister(Mt);
  }
}
var fo = ["cookie", "localstorage", "localstorage+cookie", "sessionstorage", "memory"];
class po {
  constructor(t2) {
    this.S = t2, this.props = {}, this.Te = false, this.Me = ((t3) => {
      var i2 = "";
      return t3.token && (i2 = t3.token.replace(/\+/g, "PL").replace(/\//g, "SL").replace(/=/g, "EQ")), t3.persistence_name ? "ph_" + t3.persistence_name : "ph_" + i2 + "_posthog";
    })(t2), this.B = this.Ce(t2), this.load(), t2.debug && N.info("Persistence loaded", t2.persistence, B$1({}, this.props)), this.update_config(t2, t2), this.save();
  }
  Ce(t2) {
    -1 === fo.indexOf(t2.persistence.toLowerCase()) && (N.critical("Unknown persistence type " + t2.persistence + "; falling back to localStorage+cookie"), t2.persistence = "localStorage+cookie");
    var i2 = t2.persistence.toLowerCase();
    return "localstorage" === i2 && Wi.O() ? Wi : "localstorage+cookie" === i2 && Ji.O() ? Ji : "sessionstorage" === i2 && Xi.O() ? Xi : "memory" === i2 ? Ki : "cookie" === i2 ? Bi : Ji.O() ? Ji : Bi;
  }
  properties() {
    var t2 = {};
    return J(this.props, function(i2, e2) {
      if (e2 === It && I$1(i2)) for (var r2 = Object.keys(i2), n2 = 0; n2 < r2.length; n2++) t2["$feature/" + r2[n2]] = i2[r2[n2]];
      else a2 = e2, l2 = false, (C(o2 = Ht) ? l2 : s && o2.indexOf === s ? -1 != o2.indexOf(a2) : (J(o2, function(t3) {
        if (l2 || (l2 = t3 === a2)) return W$1;
      }), l2)) || (t2[e2] = i2);
      var o2, a2, l2;
    }), t2;
  }
  load() {
    if (!this.Fe) {
      var t2 = this.B.L(this.Me);
      t2 && (this.props = V({}, t2));
    }
  }
  save() {
    this.Fe || this.B.j(this.Me, this.props, this.Oe, this.Ae, this.De, this.S.debug);
  }
  remove() {
    this.B.N(this.Me, false), this.B.N(this.Me, true);
  }
  clear() {
    this.remove(), this.props = {};
  }
  register_once(t2, i2, e2) {
    if (I$1(t2)) {
      R(i2) && (i2 = "None"), this.Oe = R(e2) ? this.Le : e2;
      var r2 = false;
      if (J(t2, (t3, e3) => {
        this.props.hasOwnProperty(e3) && this.props[e3] !== i2 || (this.props[e3] = t3, r2 = true);
      }), r2) return this.save(), true;
    }
    return false;
  }
  register(t2, i2) {
    if (I$1(t2)) {
      this.Oe = R(i2) ? this.Le : i2;
      var e2 = false;
      if (J(t2, (i3, r2) => {
        t2.hasOwnProperty(r2) && this.props[r2] !== i3 && (this.props[r2] = i3, e2 = true);
      }), e2) return this.save(), true;
    }
    return false;
  }
  unregister(t2) {
    t2 in this.props && (delete this.props[t2], this.save());
  }
  update_campaign_params() {
    if (!this.Te) {
      var t2 = Gn(this.S.custom_campaign_params, this.S.mask_personal_data_properties, this.S.custom_personal_data_properties);
      P(Z(t2)) || this.register(t2), this.Te = true;
    }
  }
  update_search_keyword() {
    var t2;
    this.register((t2 = null == o ? void 0 : o.referrer) ? Vn(t2) : {});
  }
  update_referrer_info() {
    var t2;
    this.register_once({ $referrer: Yn(), $referring_domain: null != o && o.referrer && (null == (t2 = wi(o.referrer)) ? void 0 : t2.host) || "$direct" }, void 0);
  }
  set_initial_person_info() {
    this.props[jt] || this.props[Nt] || this.register_once({ [zt]: Xn(this.S.mask_personal_data_properties, this.S.custom_personal_data_properties) }, void 0);
  }
  get_initial_props() {
    var t2 = {};
    J([Nt, jt], (i3) => {
      var e3 = this.props[i3];
      e3 && J(e3, function(i4, e4) {
        t2["$initial_" + y(e4)] = i4;
      });
    });
    var i2, e2, r2 = this.props[zt];
    if (r2) {
      var s2 = (i2 = Qn(r2), e2 = {}, J(i2, function(t3, i3) {
        e2["$initial_" + y(i3)] = t3;
      }), e2);
      V(t2, s2);
    }
    return t2;
  }
  safe_merge(t2) {
    return J(this.props, function(i2, e2) {
      e2 in t2 || (t2[e2] = i2);
    }), t2;
  }
  update_config(t2, i2) {
    if (this.Le = this.Oe = t2.cookie_expiration, this.set_disabled(t2.disable_persistence), this.set_cross_subdomain(t2.cross_subdomain_cookie), this.set_secure(t2.secure_cookie), t2.persistence !== i2.persistence) {
      var e2 = this.Ce(t2), r2 = this.props;
      this.clear(), this.B = e2, this.props = r2, this.save();
    }
  }
  set_disabled(t2) {
    this.Fe = t2, this.Fe ? this.remove() : this.save();
  }
  set_cross_subdomain(t2) {
    t2 !== this.Ae && (this.Ae = t2, this.remove(), this.save());
  }
  set_secure(t2) {
    t2 !== this.De && (this.De = t2, this.remove(), this.save());
  }
  set_event_timer(t2, i2) {
    var e2 = this.props[at] || {};
    e2[t2] = i2, this.props[at] = e2, this.save();
  }
  remove_event_timer(t2) {
    var i2 = (this.props[at] || {})[t2];
    return R(i2) || (delete this.props[at][t2], this.save()), i2;
  }
  get_property(t2) {
    return this.props[t2];
  }
  set_property(t2, i2) {
    this.props[t2] = i2, this.save();
  }
}
class go {
  constructor() {
    this.je = {}, this.je = {};
  }
  on(t2, i2) {
    return this.je[t2] || (this.je[t2] = []), this.je[t2].push(i2), () => {
      this.je[t2] = this.je[t2].filter((t3) => t3 !== i2);
    };
  }
  emit(t2, i2) {
    for (var e2 of this.je[t2] || []) e2(i2);
    for (var r2 of this.je["*"] || []) r2(t2, i2);
  }
}
class _o {
  constructor(t2) {
    this.Ne = new go(), this.ze = (t3, i2) => this.Ue(t3, i2) && this.qe(t3, i2) && this.Be(t3, i2), this.Ue = (t3, i2) => null == i2 || !i2.event || (null == t3 ? void 0 : t3.event) === (null == i2 ? void 0 : i2.event), this._instance = t2, this.He = /* @__PURE__ */ new Set(), this.We = /* @__PURE__ */ new Set();
  }
  init() {
    var t2;
    if (!R(null == (t2 = this._instance) ? void 0 : t2.Ge)) {
      var i2;
      null == (i2 = this._instance) || i2.Ge((t3, i3) => {
        this.on(t3, i3);
      });
    }
  }
  register(t2) {
    var i2, e2;
    if (!R(null == (i2 = this._instance) ? void 0 : i2.Ge) && (t2.forEach((t3) => {
      var i3, e3;
      null == (i3 = this.We) || i3.add(t3), null == (e3 = t3.steps) || e3.forEach((t4) => {
        var i4;
        null == (i4 = this.He) || i4.add((null == t4 ? void 0 : t4.event) || "");
      });
    }), null != (e2 = this._instance) && e2.autocapture)) {
      var r2, s2 = /* @__PURE__ */ new Set();
      t2.forEach((t3) => {
        var i3;
        null == (i3 = t3.steps) || i3.forEach((t4) => {
          null != t4 && t4.selector && s2.add(null == t4 ? void 0 : t4.selector);
        });
      }), null == (r2 = this._instance) || r2.autocapture.setElementSelectors(s2);
    }
  }
  on(t2, i2) {
    var e2;
    null != i2 && 0 != t2.length && (this.He.has(t2) || this.He.has(null == i2 ? void 0 : i2.event)) && this.We && (null == (e2 = this.We) ? void 0 : e2.size) > 0 && this.We.forEach((t3) => {
      this.Je(i2, t3) && this.Ne.emit("actionCaptured", t3.name);
    });
  }
  Ve(t2) {
    this.onAction("actionCaptured", (i2) => t2(i2));
  }
  Je(t2, i2) {
    if (null == (null == i2 ? void 0 : i2.steps)) return false;
    for (var e2 of i2.steps) if (this.ze(t2, e2)) return true;
    return false;
  }
  onAction(t2, i2) {
    return this.Ne.on(t2, i2);
  }
  qe(t2, i2) {
    if (null != i2 && i2.url) {
      var e2, r2 = null == t2 || null == (e2 = t2.properties) ? void 0 : e2.$current_url;
      if (!r2 || "string" != typeof r2) return false;
      if (!_o.Ke(r2, null == i2 ? void 0 : i2.url, (null == i2 ? void 0 : i2.url_matching) || "contains")) return false;
    }
    return true;
  }
  static Ke(i2, e2, r2) {
    switch (r2) {
      case "regex":
        return !!t && Ns(i2, e2);
      case "exact":
        return e2 === i2;
      case "contains":
        var s2 = _o.Ye(e2).replace(/_/g, ".").replace(/%/g, ".*");
        return Ns(i2, s2);
      default:
        return false;
    }
  }
  static Ye(t2) {
    return t2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  }
  Be(t2, i2) {
    if ((null != i2 && i2.href || null != i2 && i2.tag_name || null != i2 && i2.text) && !this.Xe(t2).some((t3) => !(null != i2 && i2.href && !_o.Ke(t3.href || "", null == i2 ? void 0 : i2.href, (null == i2 ? void 0 : i2.href_matching) || "exact")) && ((null == i2 || !i2.tag_name || t3.tag_name === (null == i2 ? void 0 : i2.tag_name)) && !(null != i2 && i2.text && !_o.Ke(t3.text || "", null == i2 ? void 0 : i2.text, (null == i2 ? void 0 : i2.text_matching) || "exact") && !_o.Ke(t3.$el_text || "", null == i2 ? void 0 : i2.text, (null == i2 ? void 0 : i2.text_matching) || "exact"))))) return false;
    if (null != i2 && i2.selector) {
      var e2, r2 = null == t2 || null == (e2 = t2.properties) ? void 0 : e2.$element_selectors;
      if (!r2) return false;
      if (!r2.includes(null == i2 ? void 0 : i2.selector)) return false;
    }
    return true;
  }
  Xe(t2) {
    return null == (null == t2 ? void 0 : t2.properties.$elements) ? [] : null == t2 ? void 0 : t2.properties.$elements;
  }
}
var mo = z("[Surveys]");
var bo = "seenSurvey_", yo = (t2, i2) => {
  var e2 = "$survey_" + i2 + "/" + t2.id;
  return t2.current_iteration && t2.current_iteration > 0 && (e2 = "$survey_" + i2 + "/" + t2.id + "/" + t2.current_iteration), e2;
};
class wo {
  constructor(t2) {
    this._instance = t2, this.Qe = /* @__PURE__ */ new Map(), this.Ze = /* @__PURE__ */ new Map();
  }
  register(t2) {
    var i2;
    R(null == (i2 = this._instance) ? void 0 : i2.Ge) || (this.tr(t2), this.ir(t2));
  }
  ir(t2) {
    var i2 = t2.filter((t3) => {
      var i3, e2;
      return (null == (i3 = t3.conditions) ? void 0 : i3.actions) && (null == (e2 = t3.conditions) || null == (e2 = e2.actions) || null == (e2 = e2.values) ? void 0 : e2.length) > 0;
    });
    if (0 !== i2.length) {
      if (null == this.er) {
        this.er = new _o(this._instance), this.er.init();
        this.er.Ve((t3) => {
          this.onAction(t3);
        });
      }
      i2.forEach((t3) => {
        var i3, e2, r2, s2, n2;
        t3.conditions && null != (i3 = t3.conditions) && i3.actions && null != (e2 = t3.conditions) && null != (e2 = e2.actions) && e2.values && (null == (r2 = t3.conditions) || null == (r2 = r2.actions) || null == (r2 = r2.values) ? void 0 : r2.length) > 0 && (null == (s2 = this.er) || s2.register(t3.conditions.actions.values), null == (n2 = t3.conditions) || null == (n2 = n2.actions) || null == (n2 = n2.values) || n2.forEach((i4) => {
          if (i4 && i4.name) {
            var e3 = this.Ze.get(i4.name);
            e3 && e3.push(t3.id), this.Ze.set(i4.name, e3 || [t3.id]);
          }
        }));
      });
    }
  }
  tr(t2) {
    var i2;
    if (0 !== t2.filter((t3) => {
      var i3, e2;
      return (null == (i3 = t3.conditions) ? void 0 : i3.events) && (null == (e2 = t3.conditions) || null == (e2 = e2.events) || null == (e2 = e2.values) ? void 0 : e2.length) > 0;
    }).length) {
      null == (i2 = this._instance) || i2.Ge((t3, i3) => {
        this.onEvent(t3, i3);
      }), t2.forEach((t3) => {
        var i3;
        null == (i3 = t3.conditions) || null == (i3 = i3.events) || null == (i3 = i3.values) || i3.forEach((i4) => {
          if (i4 && i4.name) {
            var e2 = this.Qe.get(i4.name);
            e2 && e2.push(t3.id), this.Qe.set(i4.name, e2 || [t3.id]);
          }
        });
      });
    }
  }
  onEvent(t2, i2) {
    var e2, r2 = (null == (e2 = this._instance) || null == (e2 = e2.persistence) ? void 0 : e2.props[Ft]) || [];
    if ("survey shown" === t2 && i2 && r2.length > 0) {
      var s2;
      mo.info("survey event matched, removing survey from activated surveys", { event: t2, eventPayload: i2, existingActivatedSurveys: r2 });
      var n2 = null == i2 || null == (s2 = i2.properties) ? void 0 : s2.$survey_id;
      if (n2) {
        var o2 = r2.indexOf(n2);
        o2 >= 0 && (r2.splice(o2, 1), this.rr(r2));
      }
    } else this.Qe.has(t2) && (mo.info("survey event matched, updating activated surveys", { event: t2, surveys: this.Qe.get(t2) }), this.rr(r2.concat(this.Qe.get(t2) || [])));
  }
  onAction(t2) {
    var i2, e2 = (null == (i2 = this._instance) || null == (i2 = i2.persistence) ? void 0 : i2.props[Ft]) || [];
    this.Ze.has(t2) && this.rr(e2.concat(this.Ze.get(t2) || []));
  }
  rr(t2) {
    var i2;
    null == (i2 = this._instance) || null == (i2 = i2.persistence) || i2.register({ [Ft]: [...new Set(t2)] });
  }
  getSurveys() {
    var t2, i2 = null == (t2 = this._instance) || null == (t2 = t2.persistence) ? void 0 : t2.props[Ft];
    return i2 || [];
  }
  getEventToSurveys() {
    return this.Qe;
  }
  sr() {
    return this.er;
  }
}
class So {
  constructor(t2) {
    this.nr = null, this.ar = false, this.lr = false, this.ur = [], this._instance = t2, this._surveyEventReceiver = null;
  }
  onRemoteConfig(t2) {
    var i2 = t2.surveys;
    if (F$1(i2)) return mo.warn("Flags not loaded yet. Not loading surveys.");
    var e2 = x(i2);
    this.hr = e2 ? i2.length > 0 : i2, mo.info("flags response received, hasSurveys: " + this.hr), this.hr && this.loadIfEnabled();
  }
  reset() {
    localStorage.removeItem("lastSeenSurveyDate");
    for (var t2 = [], i2 = 0; i2 < localStorage.length; i2++) {
      var e2 = localStorage.key(i2);
      (null != e2 && e2.startsWith(bo) || null != e2 && e2.startsWith("inProgressSurvey_")) && t2.push(e2);
    }
    t2.forEach((t3) => localStorage.removeItem(t3));
  }
  loadIfEnabled() {
    if (!this.nr) if (this.lr) mo.info("Already initializing surveys, skipping...");
    else if (this._instance.config.disable_surveys) mo.info("Disabled. Not loading surveys.");
    else if (this.hr) {
      var t2 = null == v ? void 0 : v.__PosthogExtensions__;
      if (t2) {
        this.lr = true;
        try {
          var i2 = t2.generateSurveys;
          if (i2) return void this.dr(i2);
          var e2 = t2.loadExternalDependency;
          if (!e2) return void this.vr("PostHog loadExternalDependency extension not found.");
          e2(this._instance, "surveys", (i3) => {
            i3 || !t2.generateSurveys ? this.vr("Could not load surveys script", i3) : this.dr(t2.generateSurveys);
          });
        } catch (t3) {
          throw this.vr("Error initializing surveys", t3), t3;
        } finally {
          this.lr = false;
        }
      } else mo.error("PostHog Extensions not found.");
    } else mo.info("No surveys to load.");
  }
  dr(t2) {
    this.nr = t2(this._instance), this._surveyEventReceiver = new wo(this._instance), mo.info("Surveys loaded successfully"), this.cr({ isLoaded: true });
  }
  vr(t2, i2) {
    mo.error(t2, i2), this.cr({ isLoaded: false, error: t2 });
  }
  onSurveysLoaded(t2) {
    return this.ur.push(t2), this.nr && this.cr({ isLoaded: true }), () => {
      this.ur = this.ur.filter((i2) => i2 !== t2);
    };
  }
  getSurveys(t2, i2) {
    if (void 0 === i2 && (i2 = false), this._instance.config.disable_surveys) return mo.info("Disabled. Not loading surveys."), t2([]);
    var e2 = this._instance.get_property(Ct);
    if (e2 && !i2) return t2(e2, { isLoaded: true });
    if (this.ar) return t2([], { isLoaded: false, error: "Surveys are already being loaded" });
    try {
      this.ar = true, this._instance.Ee({ url: this._instance.requestRouter.endpointFor("api", "/api/surveys/?token=" + this._instance.config.token), method: "GET", timeout: this._instance.config.surveys_request_timeout_ms, callback: (i3) => {
        var e3;
        this.ar = false;
        var r2 = i3.statusCode;
        if (200 !== r2 || !i3.json) {
          var s2 = "Surveys API could not be loaded, status: " + r2;
          return mo.error(s2), t2([], { isLoaded: false, error: s2 });
        }
        var n2, o2 = i3.json.surveys || [], a2 = o2.filter((t3) => function(t4) {
          return !(!t4.start_date || t4.end_date);
        }(t3) && (function(t4) {
          var i4;
          return !(null == (i4 = t4.conditions) || null == (i4 = i4.events) || null == (i4 = i4.values) || !i4.length);
        }(t3) || function(t4) {
          var i4;
          return !(null == (i4 = t4.conditions) || null == (i4 = i4.actions) || null == (i4 = i4.values) || !i4.length);
        }(t3)));
        a2.length > 0 && (null == (n2 = this._surveyEventReceiver) || n2.register(a2));
        return null == (e3 = this._instance.persistence) || e3.register({ [Ct]: o2 }), t2(o2, { isLoaded: true });
      } });
    } catch (t3) {
      throw this.ar = false, t3;
    }
  }
  cr(t2) {
    for (var i2 of this.ur) try {
      t2.isLoaded ? this.getSurveys(i2) : i2([], t2);
    } catch (t3) {
      mo.error("Error in survey callback", t3);
    }
  }
  getActiveMatchingSurveys(t2, i2) {
    if (void 0 === i2 && (i2 = false), !F$1(this.nr)) return this.nr.getActiveMatchingSurveys(t2, i2);
    mo.warn("init was not called");
  }
  pr(t2) {
    var i2 = null;
    return this.getSurveys((e2) => {
      var r2;
      i2 = null !== (r2 = e2.find((i3) => i3.id === t2)) && void 0 !== r2 ? r2 : null;
    }), i2;
  }
  gr(t2) {
    if (F$1(this.nr)) return { eligible: false, reason: "SDK is not enabled or survey functionality is not yet loaded" };
    var i2 = "string" == typeof t2 ? this.pr(t2) : t2;
    return i2 ? this.nr.checkSurveyEligibility(i2) : { eligible: false, reason: "Survey not found" };
  }
  canRenderSurvey(t2) {
    if (F$1(this.nr)) return mo.warn("init was not called"), { visible: false, disabledReason: "SDK is not enabled or survey functionality is not yet loaded" };
    var i2 = this.gr(t2);
    return { visible: i2.eligible, disabledReason: i2.reason };
  }
  canRenderSurveyAsync(t2, i2) {
    return F$1(this.nr) ? (mo.warn("init was not called"), Promise.resolve({ visible: false, disabledReason: "SDK is not enabled or survey functionality is not yet loaded" })) : new Promise((e2) => {
      this.getSurveys((i3) => {
        var r2, s2 = null !== (r2 = i3.find((i4) => i4.id === t2)) && void 0 !== r2 ? r2 : null;
        if (s2) {
          var n2 = this.gr(s2);
          e2({ visible: n2.eligible, disabledReason: n2.reason });
        } else e2({ visible: false, disabledReason: "Survey not found" });
      }, i2);
    });
  }
  renderSurvey(t2, i2) {
    if (F$1(this.nr)) mo.warn("init was not called");
    else {
      var e2 = this.pr(t2), r2 = null == o ? void 0 : o.querySelector(i2);
      e2 ? r2 ? this.nr.renderSurvey(e2, r2) : mo.warn("Survey element not found") : mo.warn("Survey not found");
    }
  }
}
(function(t2) {
  return t2.Button = "button", t2.Tab = "tab", t2.Selector = "selector", t2;
})({});
(function(t2) {
  return t2.TopLeft = "top_left", t2.TopRight = "top_right", t2.TopCenter = "top_center", t2.MiddleLeft = "middle_left", t2.MiddleRight = "middle_right", t2.MiddleCenter = "middle_center", t2.Left = "left", t2.Center = "center", t2.Right = "right", t2.NextToTrigger = "next_to_trigger", t2;
})({});
(function(t2) {
  return t2.Popover = "popover", t2.API = "api", t2.Widget = "widget", t2;
})({});
(function(t2) {
  return t2.Open = "open", t2.MultipleChoice = "multiple_choice", t2.SingleChoice = "single_choice", t2.Rating = "rating", t2.Link = "link", t2;
})({});
(function(t2) {
  return t2.NextQuestion = "next_question", t2.End = "end", t2.ResponseBased = "response_based", t2.SpecificQuestion = "specific_question", t2;
})({});
(function(t2) {
  return t2.Once = "once", t2.Recurring = "recurring", t2.Always = "always", t2;
})({});
var Ro = function(t2) {
  return t2.SHOWN = "survey shown", t2.DISMISSED = "survey dismissed", t2.SENT = "survey sent", t2;
}({}), To = function(t2) {
  return t2.SURVEY_ID = "$survey_id", t2.SURVEY_NAME = "$survey_name", t2.SURVEY_RESPONSE = "$survey_response", t2.SURVEY_ITERATION = "$survey_iteration", t2.SURVEY_ITERATION_START_DATE = "$survey_iteration_start_date", t2.SURVEY_PARTIALLY_COMPLETED = "$survey_partially_completed", t2.SURVEY_SUBMISSION_ID = "$survey_submission_id", t2.SURVEY_QUESTIONS = "$survey_questions", t2.SURVEY_COMPLETED = "$survey_completed", t2;
}({}), Mo = z("[RateLimiter]");
class Co {
  constructor(t2) {
    var i2, e2;
    this.serverLimits = {}, this.lastEventRateLimited = false, this.checkForLimiting = (t3) => {
      var i3 = t3.text;
      if (i3 && i3.length) try {
        (JSON.parse(i3).quota_limited || []).forEach((t4) => {
          Mo.info((t4 || "events") + " is quota limited."), this.serverLimits[t4] = (/* @__PURE__ */ new Date()).getTime() + 6e4;
        });
      } catch (t4) {
        return void Mo.warn('could not rate limit - continuing. Error: "' + (null == t4 ? void 0 : t4.message) + '"', { text: i3 });
      }
    }, this.instance = t2, this.captureEventsPerSecond = (null == (i2 = t2.config.rate_limiting) ? void 0 : i2.events_per_second) || 10, this.captureEventsBurstLimit = Math.max((null == (e2 = t2.config.rate_limiting) ? void 0 : e2.events_burst_limit) || 10 * this.captureEventsPerSecond, this.captureEventsPerSecond), this.lastEventRateLimited = this.clientRateLimitContext(true).isRateLimited;
  }
  clientRateLimitContext(t2) {
    var i2, e2, r2;
    void 0 === t2 && (t2 = false);
    var s2 = (/* @__PURE__ */ new Date()).getTime(), n2 = null !== (i2 = null == (e2 = this.instance.persistence) ? void 0 : e2.get_property(Lt)) && void 0 !== i2 ? i2 : { tokens: this.captureEventsBurstLimit, last: s2 };
    n2.tokens += (s2 - n2.last) / 1e3 * this.captureEventsPerSecond, n2.last = s2, n2.tokens > this.captureEventsBurstLimit && (n2.tokens = this.captureEventsBurstLimit);
    var o2 = n2.tokens < 1;
    return o2 || t2 || (n2.tokens = Math.max(0, n2.tokens - 1)), !o2 || this.lastEventRateLimited || t2 || this.instance.capture("$$client_ingestion_warning", { $$client_ingestion_warning_message: "posthog-js client rate limited. Config is set to " + this.captureEventsPerSecond + " events per second and " + this.captureEventsBurstLimit + " events burst limit." }, { skip_client_rate_limiting: true }), this.lastEventRateLimited = o2, null == (r2 = this.instance.persistence) || r2.set_property(Lt, n2), { isRateLimited: o2, remainingTokens: n2.tokens };
  }
  isServerRateLimited(t2) {
    var i2 = this.serverLimits[t2 || "events"] || false;
    return false !== i2 && (/* @__PURE__ */ new Date()).getTime() < i2;
  }
}
var Fo = z("[RemoteConfig]");
class Oo {
  constructor(t2) {
    this._instance = t2;
  }
  get remoteConfig() {
    var t2;
    return null == (t2 = v._POSTHOG_REMOTE_CONFIG) || null == (t2 = t2[this._instance.config.token]) ? void 0 : t2.config;
  }
  _r(t2) {
    var i2, e2;
    null != (i2 = v.__PosthogExtensions__) && i2.loadExternalDependency ? null == (e2 = v.__PosthogExtensions__) || null == e2.loadExternalDependency || e2.loadExternalDependency(this._instance, "remote-config", () => t2(this.remoteConfig)) : (Fo.error("PostHog Extensions not found. Cannot load remote config."), t2());
  }
  mr(t2) {
    this._instance.Ee({ method: "GET", url: this._instance.requestRouter.endpointFor("assets", "/array/" + this._instance.config.token + "/config"), callback: (i2) => {
      t2(i2.json);
    } });
  }
  load() {
    try {
      if (this.remoteConfig) return Fo.info("Using preloaded remote config", this.remoteConfig), void this.Ie(this.remoteConfig);
      if (this._instance.I()) return void Fo.warn("Remote config is disabled. Falling back to local config.");
      this._r((t2) => {
        if (!t2) return Fo.info("No config found after loading remote JS config. Falling back to JSON."), void this.mr((t3) => {
          this.Ie(t3);
        });
        this.Ie(t2);
      });
    } catch (t2) {
      Fo.error("Error loading remote config", t2);
    }
  }
  Ie(t2) {
    t2 ? this._instance.config.__preview_remote_config ? (this._instance.Ie(t2), false !== t2.hasFeatureFlags && this._instance.featureFlags.ensureFlagsLoaded()) : Fo.info("__preview_remote_config is disabled. Logging config instead", t2) : Fo.error("Failed to fetch remote config from PostHog.");
  }
}
var Ao = 3e3;
class Do {
  constructor(t2, i2) {
    this.br = true, this.yr = [], this.wr = se$1((null == i2 ? void 0 : i2.flush_interval_ms) || Ao, 250, 5e3, "flush interval", Ao), this.Sr = t2;
  }
  enqueue(t2) {
    this.yr.push(t2), this.$r || this.kr();
  }
  unload() {
    this.Er();
    var t2 = this.yr.length > 0 ? this.Ir() : {}, i2 = Object.values(t2);
    [...i2.filter((t3) => 0 === t3.url.indexOf("/e")), ...i2.filter((t3) => 0 !== t3.url.indexOf("/e"))].map((t3) => {
      this.Sr(B$1({}, t3, { transport: "sendBeacon" }));
    });
  }
  enable() {
    this.br = false, this.kr();
  }
  kr() {
    var t2 = this;
    this.br || (this.$r = setTimeout(() => {
      if (this.Er(), this.yr.length > 0) {
        var i2 = this.Ir(), e2 = function() {
          var e3 = i2[r2], s2 = (/* @__PURE__ */ new Date()).getTime();
          e3.data && x(e3.data) && J(e3.data, (t3) => {
            t3.offset = Math.abs(t3.timestamp - s2), delete t3.timestamp;
          }), t2.Sr(e3);
        };
        for (var r2 in i2) e2();
      }
    }, this.wr));
  }
  Er() {
    clearTimeout(this.$r), this.$r = void 0;
  }
  Ir() {
    var t2 = {};
    return J(this.yr, (i2) => {
      var e2, r2 = i2, s2 = (r2 ? r2.batchKey : null) || r2.url;
      R(t2[s2]) && (t2[s2] = B$1({}, r2, { data: [] })), null == (e2 = t2[s2].data) || e2.push(r2.data);
    }), this.yr = [], t2;
  }
}
var Lo = ["retriesPerformedSoFar"];
class jo {
  constructor(i2) {
    this.Pr = false, this.Rr = 3e3, this.yr = [], this._instance = i2, this.yr = [], this.Tr = true, !R(t) && "onLine" in t.navigator && (this.Tr = t.navigator.onLine, st(t, "online", () => {
      this.Tr = true, this.se();
    }), st(t, "offline", () => {
      this.Tr = false;
    }));
  }
  get length() {
    return this.yr.length;
  }
  retriableRequest(t2) {
    var { retriesPerformedSoFar: i2 } = t2, e2 = H(t2, Lo);
    O(i2) && i2 > 0 && (e2.url = As(e2.url, { retry_count: i2 })), this._instance.Ee(B$1({}, e2, { callback: (t3) => {
      200 !== t3.statusCode && (t3.statusCode < 400 || t3.statusCode >= 500) && (null != i2 ? i2 : 0) < 10 ? this.Mr(B$1({ retriesPerformedSoFar: i2 }, e2)) : null == e2.callback || e2.callback(t3);
    } }));
  }
  Mr(t2) {
    var i2 = t2.retriesPerformedSoFar || 0;
    t2.retriesPerformedSoFar = i2 + 1;
    var e2 = function(t3) {
      var i3 = 3e3 * Math.pow(2, t3), e3 = i3 / 2, r3 = Math.min(18e5, i3), s3 = (Math.random() - 0.5) * (r3 - e3);
      return Math.ceil(r3 + s3);
    }(i2), r2 = Date.now() + e2;
    this.yr.push({ retryAt: r2, requestOptions: t2 });
    var s2 = "Enqueued failed request for retry in " + e2;
    navigator.onLine || (s2 += " (Browser is offline)"), N.warn(s2), this.Pr || (this.Pr = true, this.Cr());
  }
  Cr() {
    this.Fr && clearTimeout(this.Fr), this.Fr = setTimeout(() => {
      this.Tr && this.yr.length > 0 && this.se(), this.Cr();
    }, this.Rr);
  }
  se() {
    var t2 = Date.now(), i2 = [], e2 = this.yr.filter((e3) => e3.retryAt < t2 || (i2.push(e3), false));
    if (this.yr = i2, e2.length > 0) for (var { requestOptions: r2 } of e2) this.retriableRequest(r2);
  }
  unload() {
    for (var { requestOptions: t2 } of (this.Fr && (clearTimeout(this.Fr), this.Fr = void 0), this.yr)) try {
      this._instance.Ee(B$1({}, t2, { transport: "sendBeacon" }));
    } catch (t3) {
      N.error(t3);
    }
    this.yr = [];
  }
}
class No {
  constructor(t2) {
    this.Or = () => {
      var t3, i2, e2, r2;
      this.Ar || (this.Ar = {});
      var s2 = this.scrollElement(), n2 = this.scrollY(), o2 = s2 ? Math.max(0, s2.scrollHeight - s2.clientHeight) : 0, a2 = n2 + ((null == s2 ? void 0 : s2.clientHeight) || 0), l2 = (null == s2 ? void 0 : s2.scrollHeight) || 0;
      this.Ar.lastScrollY = Math.ceil(n2), this.Ar.maxScrollY = Math.max(n2, null !== (t3 = this.Ar.maxScrollY) && void 0 !== t3 ? t3 : 0), this.Ar.maxScrollHeight = Math.max(o2, null !== (i2 = this.Ar.maxScrollHeight) && void 0 !== i2 ? i2 : 0), this.Ar.lastContentY = a2, this.Ar.maxContentY = Math.max(a2, null !== (e2 = this.Ar.maxContentY) && void 0 !== e2 ? e2 : 0), this.Ar.maxContentHeight = Math.max(l2, null !== (r2 = this.Ar.maxContentHeight) && void 0 !== r2 ? r2 : 0);
    }, this._instance = t2;
  }
  getContext() {
    return this.Ar;
  }
  resetContext() {
    var t2 = this.Ar;
    return setTimeout(this.Or, 0), t2;
  }
  startMeasuringScrollPosition() {
    st(t, "scroll", this.Or, { capture: true }), st(t, "scrollend", this.Or, { capture: true }), st(t, "resize", this.Or);
  }
  scrollElement() {
    if (!this._instance.config.scroll_root_selector) return null == t ? void 0 : t.document.documentElement;
    var i2 = x(this._instance.config.scroll_root_selector) ? this._instance.config.scroll_root_selector : [this._instance.config.scroll_root_selector];
    for (var e2 of i2) {
      var r2 = null == t ? void 0 : t.document.querySelector(e2);
      if (r2) return r2;
    }
  }
  scrollY() {
    if (this._instance.config.scroll_root_selector) {
      var i2 = this.scrollElement();
      return i2 && i2.scrollTop || 0;
    }
    return t && (t.scrollY || t.pageYOffset || t.document.documentElement.scrollTop) || 0;
  }
  scrollX() {
    if (this._instance.config.scroll_root_selector) {
      var i2 = this.scrollElement();
      return i2 && i2.scrollLeft || 0;
    }
    return t && (t.scrollX || t.pageXOffset || t.document.documentElement.scrollLeft) || 0;
  }
}
var zo = (t2) => Xn(null == t2 ? void 0 : t2.config.mask_personal_data_properties, null == t2 ? void 0 : t2.config.custom_personal_data_properties);
class Uo {
  constructor(t2, i2, e2, r2) {
    this.Dr = (t3) => {
      var i3 = this.Lr();
      if (!i3 || i3.sessionId !== t3) {
        var e3 = { sessionId: t3, props: this.jr(this._instance) };
        this.Nr.register({ [Dt]: e3 });
      }
    }, this._instance = t2, this.zr = i2, this.Nr = e2, this.jr = r2 || zo, this.zr.onSessionId(this.Dr);
  }
  Lr() {
    return this.Nr.props[Dt];
  }
  getSetOnceProps() {
    var t2, i2 = null == (t2 = this.Lr()) ? void 0 : t2.props;
    return i2 ? "r" in i2 ? Qn(i2) : { $referring_domain: i2.referringDomain, $pathname: i2.initialPathName, utm_source: i2.utm_source, utm_campaign: i2.utm_campaign, utm_medium: i2.utm_medium, utm_content: i2.utm_content, utm_term: i2.utm_term } : {};
  }
  getSessionProps() {
    var t2 = {};
    return J(Z(this.getSetOnceProps()), (i2, e2) => {
      "$current_url" === e2 && (e2 = "url"), t2["$session_entry_" + y(e2)] = i2;
    }), t2;
  }
}
var qo = z("[SessionId]");
class Bo {
  constructor(t2, i2, e2) {
    var r2;
    if (this.Ur = [], !t2.persistence) throw new Error("SessionIdManager requires a PostHogPersistence instance");
    if (t2.config.__preview_experimental_cookieless_mode) throw new Error("SessionIdManager cannot be used with __preview_experimental_cookieless_mode");
    this.S = t2.config, this.Nr = t2.persistence, this.fi = void 0, this.Ct = void 0, this._sessionStartTimestamp = null, this._sessionActivityTimestamp = null, this.qr = i2 || ji, this.Br = e2 || ji;
    var s2 = this.S.persistence_name || this.S.token, n2 = this.S.session_idle_timeout_seconds || 1800;
    if (this._sessionTimeoutMs = 1e3 * se$1(n2, 60, 36e3, "session_idle_timeout_seconds", 1800), t2.register({ $configured_session_timeout_ms: this._sessionTimeoutMs }), this.Hr(), this.Wr = "ph_" + s2 + "_window_id", this.Gr = "ph_" + s2 + "_primary_window_exists", this.Jr()) {
      var o2 = Xi.L(this.Wr), a2 = Xi.L(this.Gr);
      o2 && !a2 ? this.fi = o2 : Xi.N(this.Wr), Xi.j(this.Gr, true);
    }
    if (null != (r2 = this.S.bootstrap) && r2.sessionID) try {
      var l2 = ((t3) => {
        var i3 = t3.replace(/-/g, "");
        if (32 !== i3.length) throw new Error("Not a valid UUID");
        if ("7" !== i3[12]) throw new Error("Not a UUIDv7");
        return parseInt(i3.substring(0, 12), 16);
      })(this.S.bootstrap.sessionID);
      this.Vr(this.S.bootstrap.sessionID, (/* @__PURE__ */ new Date()).getTime(), l2);
    } catch (t3) {
      qo.error("Invalid sessionID in bootstrap", t3);
    }
    this.Kr();
  }
  get sessionTimeoutMs() {
    return this._sessionTimeoutMs;
  }
  onSessionId(t2) {
    return R(this.Ur) && (this.Ur = []), this.Ur.push(t2), this.Ct && t2(this.Ct, this.fi), () => {
      this.Ur = this.Ur.filter((i2) => i2 !== t2);
    };
  }
  Jr() {
    return "memory" !== this.S.persistence && !this.Nr.Fe && Xi.O();
  }
  Yr(t2) {
    t2 !== this.fi && (this.fi = t2, this.Jr() && Xi.j(this.Wr, t2));
  }
  Xr() {
    return this.fi ? this.fi : this.Jr() ? Xi.L(this.Wr) : null;
  }
  Vr(t2, i2, e2) {
    t2 === this.Ct && i2 === this._sessionActivityTimestamp && e2 === this._sessionStartTimestamp || (this._sessionStartTimestamp = e2, this._sessionActivityTimestamp = i2, this.Ct = t2, this.Nr.register({ [$t]: [i2, t2, e2] }));
  }
  Qr() {
    if (this.Ct && this._sessionActivityTimestamp && this._sessionStartTimestamp) return [this._sessionActivityTimestamp, this.Ct, this._sessionStartTimestamp];
    var t2 = this.Nr.props[$t];
    return x(t2) && 2 === t2.length && t2.push(t2[0]), t2 || [0, null, 0];
  }
  resetSessionId() {
    this.Vr(null, null, null);
  }
  Kr() {
    st(t, "beforeunload", () => {
      this.Jr() && Xi.N(this.Gr);
    }, { capture: false });
  }
  checkAndGetSessionAndWindowId(t2, i2) {
    if (void 0 === t2 && (t2 = false), void 0 === i2 && (i2 = null), this.S.__preview_experimental_cookieless_mode) throw new Error("checkAndGetSessionAndWindowId should not be called in __preview_experimental_cookieless_mode");
    var e2 = i2 || (/* @__PURE__ */ new Date()).getTime(), [r2, s2, n2] = this.Qr(), o2 = this.Xr(), a2 = O(n2) && n2 > 0 && Math.abs(e2 - n2) > 864e5, l2 = false, u2 = !s2, h2 = !t2 && Math.abs(e2 - r2) > this.sessionTimeoutMs;
    u2 || h2 || a2 ? (s2 = this.qr(), o2 = this.Br(), qo.info("new session ID generated", { sessionId: s2, windowId: o2, changeReason: { noSessionId: u2, activityTimeout: h2, sessionPastMaximumLength: a2 } }), n2 = e2, l2 = true) : o2 || (o2 = this.Br(), l2 = true);
    var d2 = 0 === r2 || !t2 || a2 ? e2 : r2, v2 = 0 === n2 ? (/* @__PURE__ */ new Date()).getTime() : n2;
    return this.Yr(o2), this.Vr(s2, d2, v2), t2 || this.Hr(), l2 && this.Ur.forEach((t3) => t3(s2, o2, l2 ? { noSessionId: u2, activityTimeout: h2, sessionPastMaximumLength: a2 } : void 0)), { sessionId: s2, windowId: o2, sessionStartTimestamp: v2, changeReason: l2 ? { noSessionId: u2, activityTimeout: h2, sessionPastMaximumLength: a2 } : void 0, lastActivityTimestamp: r2 };
  }
  Hr() {
    clearTimeout(this.Zr), this.Zr = setTimeout(() => {
      this.resetSessionId();
    }, 1.1 * this.sessionTimeoutMs);
  }
}
var Ho = ["$set_once", "$set"], Wo = z("[SiteApps]");
class Go {
  constructor(t2) {
    this._instance = t2, this.ts = [], this.apps = {};
  }
  get isEnabled() {
    return !!this._instance.config.opt_in_site_apps;
  }
  es(t2, i2) {
    if (i2) {
      var e2 = this.globalsForEvent(i2);
      this.ts.push(e2), this.ts.length > 1e3 && (this.ts = this.ts.slice(10));
    }
  }
  get siteAppLoaders() {
    var t2;
    return null == (t2 = v._POSTHOG_REMOTE_CONFIG) || null == (t2 = t2[this._instance.config.token]) ? void 0 : t2.siteApps;
  }
  init() {
    if (this.isEnabled) {
      var t2 = this._instance.Ge(this.es.bind(this));
      this.rs = () => {
        t2(), this.ts = [], this.rs = void 0;
      };
    }
  }
  globalsForEvent(t2) {
    var i2, e2, r2, s2, n2, o2, a2;
    if (!t2) throw new Error("Event payload is required");
    var l2 = {}, u2 = this._instance.get_property("$groups") || [], h2 = this._instance.get_property("$stored_group_properties") || {};
    for (var [d2, v2] of Object.entries(h2)) l2[d2] = { id: u2[d2], type: d2, properties: v2 };
    var { $set_once: c2, $set: f2 } = t2;
    return { event: B$1({}, H(t2, Ho), { properties: B$1({}, t2.properties, f2 ? { $set: B$1({}, null !== (i2 = null == (e2 = t2.properties) ? void 0 : e2.$set) && void 0 !== i2 ? i2 : {}, f2) } : {}, c2 ? { $set_once: B$1({}, null !== (r2 = null == (s2 = t2.properties) ? void 0 : s2.$set_once) && void 0 !== r2 ? r2 : {}, c2) } : {}), elements_chain: null !== (n2 = null == (o2 = t2.properties) ? void 0 : o2.$elements_chain) && void 0 !== n2 ? n2 : "", distinct_id: null == (a2 = t2.properties) ? void 0 : a2.distinct_id }), person: { properties: this._instance.get_property("$stored_person_properties") }, groups: l2 };
  }
  setupSiteApp(t2) {
    var i2 = this.apps[t2.id], e2 = () => {
      var e3;
      (!i2.errored && this.ts.length && (Wo.info("Processing " + this.ts.length + " events for site app with id " + t2.id), this.ts.forEach((t3) => null == i2.processEvent ? void 0 : i2.processEvent(t3)), i2.processedBuffer = true), Object.values(this.apps).every((t3) => t3.processedBuffer || t3.errored)) && (null == (e3 = this.rs) || e3.call(this));
    }, r2 = false, s2 = (s3) => {
      i2.errored = !s3, i2.loaded = true, Wo.info("Site app with id " + t2.id + " " + (s3 ? "loaded" : "errored")), r2 && e2();
    };
    try {
      var { processEvent: n2 } = t2.init({ posthog: this._instance, callback: (t3) => {
        s2(t3);
      } });
      n2 && (i2.processEvent = n2), r2 = true;
    } catch (i3) {
      Wo.error("Error while initializing PostHog app with config id " + t2.id, i3), s2(false);
    }
    if (r2 && i2.loaded) try {
      e2();
    } catch (e3) {
      Wo.error("Error while processing buffered events PostHog app with config id " + t2.id, e3), i2.errored = true;
    }
  }
  ss() {
    var t2 = this.siteAppLoaders || [];
    for (var i2 of t2) this.apps[i2.id] = { id: i2.id, loaded: false, errored: false, processedBuffer: false };
    for (var e2 of t2) this.setupSiteApp(e2);
  }
  ns(t2) {
    if (0 !== Object.keys(this.apps).length) {
      var i2 = this.globalsForEvent(t2);
      for (var e2 of Object.values(this.apps)) try {
        null == e2.processEvent || e2.processEvent(i2);
      } catch (i3) {
        Wo.error("Error while processing event " + t2.event + " for site app " + e2.id, i3);
      }
    }
  }
  onRemoteConfig(t2) {
    var i2, e2, r2, s2 = this;
    if (null != (i2 = this.siteAppLoaders) && i2.length) return this.isEnabled ? (this.ss(), void this._instance.on("eventCaptured", (t3) => this.ns(t3))) : void Wo.error('PostHog site apps are disabled. Enable the "opt_in_site_apps" config to proceed.');
    if (null == (e2 = this.rs) || e2.call(this), null != (r2 = t2.siteApps) && r2.length) if (this.isEnabled) {
      var n2 = function(t3) {
        var i3;
        v["__$$ph_site_app_" + t3] = s2._instance, null == (i3 = v.__PosthogExtensions__) || null == i3.loadSiteApp || i3.loadSiteApp(s2._instance, a2, (i4) => {
          if (i4) return Wo.error("Error while initializing PostHog app with config id " + t3, i4);
        });
      };
      for (var { id: o2, url: a2 } of t2.siteApps) n2(o2);
    } else Wo.error('PostHog site apps are disabled. Enable the "opt_in_site_apps" config to proceed.');
  }
}
var Jo = ["amazonbot", "amazonproductbot", "app.hypefactors.com", "applebot", "archive.org_bot", "awariobot", "backlinksextendedbot", "baiduspider", "bingbot", "bingpreview", "chrome-lighthouse", "dataforseobot", "deepscan", "duckduckbot", "facebookexternal", "facebookcatalog", "http://yandex.com/bots", "hubspot", "ia_archiver", "leikibot", "linkedinbot", "meta-externalagent", "mj12bot", "msnbot", "nessus", "petalbot", "pinterest", "prerender", "rogerbot", "screaming frog", "sebot-wa", "sitebulb", "slackbot", "slurp", "trendictionbot", "turnitin", "twitterbot", "vercelbot", "yahoo! slurp", "yandexbot", "zoombot", "bot.htm", "bot.php", "(bot;", "bot/", "crawler", "ahrefsbot", "ahrefssiteaudit", "semrushbot", "siteauditbot", "splitsignalbot", "gptbot", "oai-searchbot", "chatgpt-user", "perplexitybot", "better uptime bot", "sentryuptimebot", "uptimerobot", "headlesschrome", "cypress", "google-hoteladsverifier", "adsbot-google", "apis-google", "duplexweb-google", "feedfetcher-google", "google favicon", "google web preview", "google-read-aloud", "googlebot", "googleother", "google-cloudvertexbot", "googleweblight", "mediapartners-google", "storebot-google", "google-inspectiontool", "bytespider"], Vo = function(t2, i2) {
  if (!t2) return false;
  var e2 = t2.toLowerCase();
  return Jo.concat(i2 || []).some((t3) => {
    var i3 = t3.toLowerCase();
    return -1 !== e2.indexOf(i3);
  });
}, Ko = function(t2, i2) {
  if (!t2) return false;
  var e2 = t2.userAgent;
  if (e2 && Vo(e2, i2)) return true;
  try {
    var r2 = null == t2 ? void 0 : t2.userAgentData;
    if (null != r2 && r2.brands && r2.brands.some((t3) => Vo(null == t3 ? void 0 : t3.brand, i2))) return true;
  } catch (t3) {
  }
  return !!t2.webdriver;
}, Yo = function(t2) {
  return t2.US = "us", t2.EU = "eu", t2.CUSTOM = "custom", t2;
}({}), Xo = "i.posthog.com";
class Qo {
  constructor(t2) {
    this.os = {}, this.instance = t2;
  }
  get apiHost() {
    var t2 = this.instance.config.api_host.trim().replace(/\/$/, "");
    return "https://app.posthog.com" === t2 ? "https://us.i.posthog.com" : t2;
  }
  get uiHost() {
    var t2, i2 = null == (t2 = this.instance.config.ui_host) ? void 0 : t2.replace(/\/$/, "");
    return i2 || (i2 = this.apiHost.replace("." + Xo, ".posthog.com")), "https://app.posthog.com" === i2 ? "https://us.posthog.com" : i2;
  }
  get region() {
    return this.os[this.apiHost] || (/https:\/\/(app|us|us-assets)(\.i)?\.posthog\.com/i.test(this.apiHost) ? this.os[this.apiHost] = Yo.US : /https:\/\/(eu|eu-assets)(\.i)?\.posthog\.com/i.test(this.apiHost) ? this.os[this.apiHost] = Yo.EU : this.os[this.apiHost] = Yo.CUSTOM), this.os[this.apiHost];
  }
  endpointFor(t2, i2) {
    if (void 0 === i2 && (i2 = ""), i2 && (i2 = "/" === i2[0] ? i2 : "/" + i2), "ui" === t2) return this.uiHost + i2;
    if (this.region === Yo.CUSTOM) return this.apiHost + i2;
    var e2 = Xo + i2;
    switch (t2) {
      case "assets":
        return "https://" + this.region + "-assets." + e2;
      case "api":
        return "https://" + this.region + "." + e2;
    }
  }
}
var Zo = { icontains: (i2, e2) => !!t && e2.href.toLowerCase().indexOf(i2.toLowerCase()) > -1, not_icontains: (i2, e2) => !!t && -1 === e2.href.toLowerCase().indexOf(i2.toLowerCase()), regex: (i2, e2) => !!t && Ns(e2.href, i2), not_regex: (i2, e2) => !!t && !Ns(e2.href, i2), exact: (t2, i2) => i2.href === t2, is_not: (t2, i2) => i2.href !== t2 };
class ta {
  constructor(t2) {
    var i2 = this;
    this.getWebExperimentsAndEvaluateDisplayLogic = function(t3) {
      void 0 === t3 && (t3 = false), i2.getWebExperiments((t4) => {
        ta.ls("retrieved web experiments from the server"), i2.us = /* @__PURE__ */ new Map(), t4.forEach((t5) => {
          if (t5.feature_flag_key) {
            var e2;
            if (i2.us) ta.ls("setting flag key ", t5.feature_flag_key, " to web experiment ", t5), null == (e2 = i2.us) || e2.set(t5.feature_flag_key, t5);
            var r2 = i2._instance.getFeatureFlag(t5.feature_flag_key);
            T(r2) && t5.variants[r2] && i2.hs(t5.name, r2, t5.variants[r2].transforms);
          } else if (t5.variants) for (var s2 in t5.variants) {
            var n2 = t5.variants[s2];
            ta.ds(n2) && i2.hs(t5.name, s2, n2.transforms);
          }
        });
      }, t3);
    }, this._instance = t2, this._instance.onFeatureFlags((t3) => {
      this.onFeatureFlags(t3);
    });
  }
  onFeatureFlags(t2) {
    if (this._is_bot()) ta.ls("Refusing to render web experiment since the viewer is a likely bot");
    else if (!this._instance.config.disable_web_experiments) {
      if (F$1(this.us)) return this.us = /* @__PURE__ */ new Map(), this.loadIfEnabled(), void this.previewWebExperiment();
      ta.ls("applying feature flags", t2), t2.forEach((t3) => {
        var i2;
        if (this.us && null != (i2 = this.us) && i2.has(t3)) {
          var e2, r2 = this._instance.getFeatureFlag(t3), s2 = null == (e2 = this.us) ? void 0 : e2.get(t3);
          r2 && null != s2 && s2.variants[r2] && this.hs(s2.name, r2, s2.variants[r2].transforms);
        }
      });
    }
  }
  previewWebExperiment() {
    var t2 = ta.getWindowLocation();
    if (null != t2 && t2.search) {
      var i2 = $i(null == t2 ? void 0 : t2.search, "__experiment_id"), e2 = $i(null == t2 ? void 0 : t2.search, "__experiment_variant");
      i2 && e2 && (ta.ls("previewing web experiments " + i2 + " && " + e2), this.getWebExperiments((t3) => {
        this.vs(parseInt(i2), e2, t3);
      }, false, true));
    }
  }
  loadIfEnabled() {
    this._instance.config.disable_web_experiments || this.getWebExperimentsAndEvaluateDisplayLogic();
  }
  getWebExperiments(t2, i2, e2) {
    if (this._instance.config.disable_web_experiments && !e2) return t2([]);
    var r2 = this._instance.get_property("$web_experiments");
    if (r2 && !i2) return t2(r2);
    this._instance.Ee({ url: this._instance.requestRouter.endpointFor("api", "/api/web_experiments/?token=" + this._instance.config.token), method: "GET", callback: (i3) => {
      if (200 !== i3.statusCode || !i3.json) return t2([]);
      var e3 = i3.json.experiments || [];
      return t2(e3);
    } });
  }
  vs(t2, i2, e2) {
    var r2 = e2.filter((i3) => i3.id === t2);
    r2 && r2.length > 0 && (ta.ls("Previewing web experiment [" + r2[0].name + "] with variant [" + i2 + "]"), this.hs(r2[0].name, i2, r2[0].variants[i2].transforms));
  }
  static ds(t2) {
    return !F$1(t2.conditions) && (ta.cs(t2) && ta.fs(t2));
  }
  static cs(t2) {
    var i2;
    if (F$1(t2.conditions) || F$1(null == (i2 = t2.conditions) ? void 0 : i2.url)) return true;
    var e2, r2, s2, n2 = ta.getWindowLocation();
    return !!n2 && (null == (e2 = t2.conditions) || !e2.url || Zo[null !== (r2 = null == (s2 = t2.conditions) ? void 0 : s2.urlMatchType) && void 0 !== r2 ? r2 : "icontains"](t2.conditions.url, n2));
  }
  static getWindowLocation() {
    return null == t ? void 0 : t.location;
  }
  static fs(t2) {
    var i2;
    if (F$1(t2.conditions) || F$1(null == (i2 = t2.conditions) ? void 0 : i2.utm)) return true;
    var e2 = Gn();
    if (e2.utm_source) {
      var r2, s2, n2, o2, a2, l2, u2, h2, d2 = null == (r2 = t2.conditions) || null == (r2 = r2.utm) || !r2.utm_campaign || (null == (s2 = t2.conditions) || null == (s2 = s2.utm) ? void 0 : s2.utm_campaign) == e2.utm_campaign, v2 = null == (n2 = t2.conditions) || null == (n2 = n2.utm) || !n2.utm_source || (null == (o2 = t2.conditions) || null == (o2 = o2.utm) ? void 0 : o2.utm_source) == e2.utm_source, c2 = null == (a2 = t2.conditions) || null == (a2 = a2.utm) || !a2.utm_medium || (null == (l2 = t2.conditions) || null == (l2 = l2.utm) ? void 0 : l2.utm_medium) == e2.utm_medium, f2 = null == (u2 = t2.conditions) || null == (u2 = u2.utm) || !u2.utm_term || (null == (h2 = t2.conditions) || null == (h2 = h2.utm) ? void 0 : h2.utm_term) == e2.utm_term;
      return d2 && c2 && f2 && v2;
    }
    return false;
  }
  static ls(t2) {
    for (var i2 = arguments.length, e2 = new Array(i2 > 1 ? i2 - 1 : 0), r2 = 1; r2 < i2; r2++) e2[r2 - 1] = arguments[r2];
    N.info("[WebExperiments] " + t2, e2);
  }
  hs(t2, i2, e2) {
    this._is_bot() ? ta.ls("Refusing to render web experiment since the viewer is a likely bot") : "control" !== i2 ? e2.forEach((e3) => {
      if (e3.selector) {
        var r2;
        ta.ls("applying transform of variant " + i2 + " for experiment " + t2 + " ", e3);
        var s2 = null == (r2 = document) ? void 0 : r2.querySelectorAll(e3.selector);
        null == s2 || s2.forEach((t3) => {
          var i3 = t3;
          e3.html && (i3.innerHTML = e3.html), e3.css && i3.setAttribute("style", e3.css);
        });
      }
    }) : ta.ls("Control variants leave the page unmodified.");
  }
  _is_bot() {
    return n && this._instance ? Ko(n, this._instance.config.custom_blocked_useragents) : void 0;
  }
}
var ia = {}, ea = () => {
}, ra = "posthog", sa = !Fs && -1 === (null == d ? void 0 : d.indexOf("MSIE")) && -1 === (null == d ? void 0 : d.indexOf("Mozilla")), na = (i2) => {
  var e2;
  return { api_host: "https://us.i.posthog.com", ui_host: null, token: "", autocapture: true, rageclick: true, cross_subdomain_cookie: et(null == o ? void 0 : o.location), persistence: "localStorage+cookie", persistence_name: "", loaded: ea, save_campaign_params: true, custom_campaign_params: [], custom_blocked_useragents: [], save_referrer: true, capture_pageview: "2025-05-24" !== i2 || "history_change", capture_pageleave: "if_capture_pageview", defaults: null != i2 ? i2 : "unset", debug: a && T(null == a ? void 0 : a.search) && -1 !== a.search.indexOf("__posthog_debug=true") || false, cookie_expiration: 365, upgrade: false, disable_session_recording: false, disable_persistence: false, disable_web_experiments: true, disable_surveys: false, disable_external_dependency_loading: false, enable_recording_console_log: void 0, secure_cookie: "https:" === (null == t || null == (e2 = t.location) ? void 0 : e2.protocol), ip: true, opt_out_capturing_by_default: false, opt_out_persistence_by_default: false, opt_out_useragent_filter: false, opt_out_capturing_persistence_type: "localStorage", opt_out_capturing_cookie_prefix: null, opt_in_site_apps: false, property_denylist: [], respect_dnt: false, sanitize_properties: null, request_headers: {}, request_batching: true, properties_string_max_length: 65535, session_recording: {}, mask_all_element_attributes: false, mask_all_text: false, mask_personal_data_properties: false, custom_personal_data_properties: [], advanced_disable_flags: false, advanced_disable_decide: false, advanced_disable_feature_flags: false, advanced_disable_feature_flags_on_first_load: false, advanced_only_evaluate_survey_feature_flags: false, advanced_disable_toolbar_metrics: false, feature_flag_request_timeout_ms: 3e3, surveys_request_timeout_ms: 1e4, on_request_error: (t2) => {
    var i3 = "Bad HTTP status: " + t2.statusCode + " " + t2.text;
    N.error(i3);
  }, get_device_id: (t2) => t2, capture_performance: void 0, name: "posthog", bootstrap: {}, disable_compression: false, session_idle_timeout_seconds: 1800, person_profiles: "identified_only", before_send: void 0, request_queue_config: { flush_interval_ms: Ao }, error_tracking: {}, _onCapture: ea };
}, oa = (t2) => {
  var i2 = {};
  R(t2.process_person) || (i2.person_profiles = t2.process_person), R(t2.xhr_headers) || (i2.request_headers = t2.xhr_headers), R(t2.cookie_name) || (i2.persistence_name = t2.cookie_name), R(t2.disable_cookie) || (i2.disable_persistence = t2.disable_cookie), R(t2.store_google) || (i2.save_campaign_params = t2.store_google), R(t2.verbose) || (i2.debug = t2.verbose);
  var e2 = V({}, i2, t2);
  return x(t2.property_blacklist) && (R(t2.property_denylist) ? e2.property_denylist = t2.property_blacklist : x(t2.property_denylist) ? e2.property_denylist = [...t2.property_blacklist, ...t2.property_denylist] : N.error("Invalid value for property_denylist config: " + t2.property_denylist)), e2;
};
class aa {
  constructor() {
    this.__forceAllowLocalhost = false;
  }
  get ps() {
    return this.__forceAllowLocalhost;
  }
  set ps(t2) {
    N.error("WebPerformanceObserver is deprecated and has no impact on network capture. Use `_forceAllowLocalhostNetworkCapture` on `posthog.sessionRecording`"), this.__forceAllowLocalhost = t2;
  }
}
class la {
  get decideEndpointWasHit() {
    var t2, i2;
    return null !== (t2 = null == (i2 = this.featureFlags) ? void 0 : i2.hasLoadedFlags) && void 0 !== t2 && t2;
  }
  get flagsEndpointWasHit() {
    var t2, i2;
    return null !== (t2 = null == (i2 = this.featureFlags) ? void 0 : i2.hasLoadedFlags) && void 0 !== t2 && t2;
  }
  constructor() {
    this.webPerformance = new aa(), this.gs = false, this.version = c.LIB_VERSION, this._s = new go(), this._calculate_event_properties = this.calculateEventProperties.bind(this), this.config = na(), this.SentryIntegration = _s, this.sentryIntegration = (t2) => function(t3, i2) {
      var e2 = gs(t3, i2);
      return { name: ps, processEvent: (t4) => e2(t4) };
    }(this, t2), this.__request_queue = [], this.__loaded = false, this.analyticsDefaultEndpoint = "/e/", this.bs = false, this.ys = null, this.ws = null, this.Ss = null, this.featureFlags = new co(this), this.toolbar = new Ss(this), this.scrollManager = new No(this), this.pageViewManager = new Ms(this), this.surveys = new So(this), this.experiments = new ta(this), this.exceptions = new Hs(this), this.rateLimiter = new Co(this), this.requestRouter = new Qo(this), this.consent = new Zi(this), this.people = { set: (t2, i2, e2) => {
      var r2 = T(t2) ? { [t2]: i2 } : t2;
      this.setPersonProperties(r2), null == e2 || e2({});
    }, set_once: (t2, i2, e2) => {
      var r2 = T(t2) ? { [t2]: i2 } : t2;
      this.setPersonProperties(void 0, r2), null == e2 || e2({});
    } }, this.on("eventCaptured", (t2) => N.info('send "' + (null == t2 ? void 0 : t2.event) + '"', t2));
  }
  init(t2, i2, e2) {
    if (e2 && e2 !== ra) {
      var r2, s2 = null !== (r2 = ia[e2]) && void 0 !== r2 ? r2 : new la();
      return s2._init(t2, i2, e2), ia[e2] = s2, ia[ra][e2] = s2, s2;
    }
    return this._init(t2, i2, e2);
  }
  _init(i2, e2, r2) {
    var s2, n2;
    if (void 0 === e2 && (e2 = {}), R(i2) || M(i2)) return N.critical("PostHog was initialized without a token. This likely indicates a misconfiguration. Please check the first argument passed to posthog.init()"), this;
    if (this.__loaded) return N.warn("You have already initialized PostHog! Re-initializing is a no-op"), this;
    this.__loaded = true, this.config = {}, this.$s = e2, this.ks = [], e2.person_profiles && (this.ws = e2.person_profiles), this.set_config(V({}, na(e2.defaults), oa(e2), { name: r2, token: i2 })), this.config.on_xhr_error && N.error("on_xhr_error is deprecated. Use on_request_error instead"), this.compression = e2.disable_compression ? void 0 : g.GZipJS, this.persistence = new po(this.config), this.sessionPersistence = "sessionStorage" === this.config.persistence || "memory" === this.config.persistence ? this.persistence : new po(B$1({}, this.config, { persistence: "sessionStorage" }));
    var o2 = B$1({}, this.persistence.props), a2 = B$1({}, this.sessionPersistence.props);
    if (this.register({ $initialization_time: (/* @__PURE__ */ new Date()).toISOString() }), this.xs = new Do((t2) => this.Es(t2), this.config.request_queue_config), this.Is = new jo(this), this.__request_queue = [], this.config.__preview_experimental_cookieless_mode || (this.sessionManager = new Bo(this), this.sessionPropsManager = new Uo(this, this.sessionManager, this.persistence)), new ks(this).startIfEnabledOrStop(), this.siteApps = new Go(this), null == (s2 = this.siteApps) || s2.init(), this.config.__preview_experimental_cookieless_mode || (this.sessionRecording = new vs(this), this.sessionRecording.startIfEnabledOrStop()), this.config.disable_scroll_properties || this.scrollManager.startMeasuringScrollPosition(), this.autocapture = new Mi(this), this.autocapture.startIfEnabled(), this.surveys.loadIfEnabled(), this.heatmaps = new Ts(this), this.heatmaps.startIfEnabled(), this.webVitalsAutocapture = new Is(this), this.exceptionObserver = new ae$1(this), this.exceptionObserver.startIfEnabled(), this.deadClicksAutocapture = new re$1(this, ee), this.deadClicksAutocapture.startIfEnabled(), this.historyAutocapture = new Ne(this), this.historyAutocapture.startIfEnabled(), c.DEBUG = c.DEBUG || this.config.debug, c.DEBUG && N.info("Starting in debug mode", { this: this, config: e2, thisC: B$1({}, this.config), p: o2, s: a2 }), this.Ps(), void 0 !== (null == (n2 = e2.bootstrap) ? void 0 : n2.distinctID)) {
      var l2, u2, h2 = this.config.get_device_id(ji()), d2 = null != (l2 = e2.bootstrap) && l2.isIdentifiedID ? h2 : e2.bootstrap.distinctID;
      this.persistence.set_property(At, null != (u2 = e2.bootstrap) && u2.isIdentifiedID ? "identified" : "anonymous"), this.register({ distinct_id: e2.bootstrap.distinctID, $device_id: d2 });
    }
    if (this.Rs()) {
      var v2, f2, p2 = Object.keys((null == (v2 = e2.bootstrap) ? void 0 : v2.featureFlags) || {}).filter((t2) => {
        var i3;
        return !(null == (i3 = e2.bootstrap) || null == (i3 = i3.featureFlags) || !i3[t2]);
      }).reduce((t2, i3) => {
        var r3;
        return t2[i3] = (null == (r3 = e2.bootstrap) || null == (r3 = r3.featureFlags) ? void 0 : r3[i3]) || false, t2;
      }, {}), _2 = Object.keys((null == (f2 = e2.bootstrap) ? void 0 : f2.featureFlagPayloads) || {}).filter((t2) => p2[t2]).reduce((t2, i3) => {
        var r3, s3;
        null != (r3 = e2.bootstrap) && null != (r3 = r3.featureFlagPayloads) && r3[i3] && (t2[i3] = null == (s3 = e2.bootstrap) || null == (s3 = s3.featureFlagPayloads) ? void 0 : s3[i3]);
        return t2;
      }, {});
      this.featureFlags.receivedFeatureFlags({ featureFlags: p2, featureFlagPayloads: _2 });
    }
    if (this.config.__preview_experimental_cookieless_mode) this.register_once({ distinct_id: Bt, $device_id: null }, "");
    else if (!this.get_distinct_id()) {
      var m2 = this.config.get_device_id(ji());
      this.register_once({ distinct_id: m2, $device_id: m2 }, ""), this.persistence.set_property(At, "anonymous");
    }
    return st(t, "onpagehide" in self ? "pagehide" : "unload", this._handle_unload.bind(this), { passive: false }), this.toolbar.maybeLoadToolbar(), e2.segment ? fs(this, () => this.Ts()) : this.Ts(), E(this.config._onCapture) && this.config._onCapture !== ea && (N.warn("onCapture is deprecated. Please use `before_send` instead"), this.on("eventCaptured", (t2) => this.config._onCapture(t2.event, t2))), this;
  }
  Ie(t2) {
    var i2, e2, r2, s2, n2, a2, l2, u2;
    if (!o || !o.body) return N.info("document not ready yet, trying again in 500 milliseconds..."), void setTimeout(() => {
      this.Ie(t2);
    }, 500);
    this.compression = void 0, t2.supportedCompression && !this.config.disable_compression && (this.compression = m(t2.supportedCompression, g.GZipJS) ? g.GZipJS : m(t2.supportedCompression, g.Base64) ? g.Base64 : void 0), null != (i2 = t2.analytics) && i2.endpoint && (this.analyticsDefaultEndpoint = t2.analytics.endpoint), this.set_config({ person_profiles: this.ws ? this.ws : "identified_only" }), null == (e2 = this.siteApps) || e2.onRemoteConfig(t2), null == (r2 = this.sessionRecording) || r2.onRemoteConfig(t2), null == (s2 = this.autocapture) || s2.onRemoteConfig(t2), null == (n2 = this.heatmaps) || n2.onRemoteConfig(t2), this.surveys.onRemoteConfig(t2), null == (a2 = this.webVitalsAutocapture) || a2.onRemoteConfig(t2), null == (l2 = this.exceptionObserver) || l2.onRemoteConfig(t2), this.exceptions.onRemoteConfig(t2), null == (u2 = this.deadClicksAutocapture) || u2.onRemoteConfig(t2);
  }
  Ts() {
    try {
      this.config.loaded(this);
    } catch (t2) {
      N.critical("`loaded` function failed", t2);
    }
    this.Ms(), this.config.capture_pageview && setTimeout(() => {
      this.consent.isOptedIn() && this.Cs();
    }, 1), new Oo(this).load(), this.featureFlags.flags();
  }
  Ms() {
    var t2;
    this.has_opted_out_capturing() || this.config.request_batching && (null == (t2 = this.xs) || t2.enable());
  }
  _dom_loaded() {
    this.has_opted_out_capturing() || G$1(this.__request_queue, (t2) => this.Es(t2)), this.__request_queue = [], this.Ms();
  }
  _handle_unload() {
    var t2, i2;
    this.config.request_batching ? (this.Fs() && this.capture("$pageleave"), null == (t2 = this.xs) || t2.unload(), null == (i2 = this.Is) || i2.unload()) : this.Fs() && this.capture("$pageleave", null, { transport: "sendBeacon" });
  }
  Ee(t2) {
    this.__loaded && (sa ? this.__request_queue.push(t2) : this.rateLimiter.isServerRateLimited(t2.batchKey) || (t2.transport = t2.transport || this.config.api_transport, t2.url = As(t2.url, { ip: this.config.ip ? 1 : 0 }), t2.headers = B$1({}, this.config.request_headers), t2.compression = "best-available" === t2.compression ? this.compression : t2.compression, t2.fetchOptions = t2.fetchOptions || this.config.fetch_options, ((t3) => {
      var i2, e2, r2, s2 = B$1({}, t3);
      s2.timeout = s2.timeout || 6e4, s2.url = As(s2.url, { _: (/* @__PURE__ */ new Date()).getTime().toString(), ver: c.LIB_VERSION, compression: s2.compression });
      var n2 = null !== (i2 = s2.transport) && void 0 !== i2 ? i2 : "fetch", o2 = null !== (e2 = null == (r2 = rt(js, (t4) => t4.transport === n2)) ? void 0 : r2.method) && void 0 !== e2 ? e2 : js[0].method;
      if (!o2) throw new Error("No available transport method");
      o2(s2);
    })(B$1({}, t2, { callback: (i2) => {
      var e2, r2;
      (this.rateLimiter.checkForLimiting(i2), i2.statusCode >= 400) && (null == (e2 = (r2 = this.config).on_request_error) || e2.call(r2, i2));
      null == t2.callback || t2.callback(i2);
    } }))));
  }
  Es(t2) {
    this.Is ? this.Is.retriableRequest(t2) : this.Ee(t2);
  }
  _execute_array(t2) {
    var i2, e2 = [], r2 = [], s2 = [];
    G$1(t2, (t3) => {
      t3 && (i2 = t3[0], x(i2) ? s2.push(t3) : E(t3) ? t3.call(this) : x(t3) && "alias" === i2 ? e2.push(t3) : x(t3) && -1 !== i2.indexOf("capture") && E(this[i2]) ? s2.push(t3) : r2.push(t3));
    });
    var n2 = function(t3, i3) {
      G$1(t3, function(t4) {
        if (x(t4[0])) {
          var e3 = i3;
          J(t4, function(t5) {
            e3 = e3[t5[0]].apply(e3, t5.slice(1));
          });
        } else this[t4[0]].apply(this, t4.slice(1));
      }, i3);
    };
    n2(e2, this), n2(r2, this), n2(s2, this);
  }
  Rs() {
    var t2, i2;
    return (null == (t2 = this.config.bootstrap) ? void 0 : t2.featureFlags) && Object.keys(null == (i2 = this.config.bootstrap) ? void 0 : i2.featureFlags).length > 0 || false;
  }
  push(t2) {
    this._execute_array([t2]);
  }
  capture(t2, i2, e2) {
    var r2;
    if (this.__loaded && this.persistence && this.sessionPersistence && this.xs) {
      if (!this.consent.isOptedOut()) if (!R(t2) && T(t2)) {
        if (this.config.opt_out_useragent_filter || !this._is_bot()) {
          var s2 = null != e2 && e2.skip_client_rate_limiting ? void 0 : this.rateLimiter.clientRateLimitContext();
          if (null == s2 || !s2.isRateLimited) {
            null != i2 && i2.$current_url && !T(null == i2 ? void 0 : i2.$current_url) && (N.error("Invalid `$current_url` property provided to `posthog.capture`. Input must be a string. Ignoring provided value."), null == i2 || delete i2.$current_url), this.sessionPersistence.update_search_keyword(), this.config.save_campaign_params && this.sessionPersistence.update_campaign_params(), this.config.save_referrer && this.sessionPersistence.update_referrer_info(), (this.config.save_campaign_params || this.config.save_referrer) && this.persistence.set_initial_person_info();
            var n2 = /* @__PURE__ */ new Date(), o2 = (null == e2 ? void 0 : e2.timestamp) || n2, a2 = ji(), l2 = { uuid: a2, event: t2, properties: this.calculateEventProperties(t2, i2 || {}, o2, a2) };
            s2 && (l2.properties.$lib_rate_limit_remaining_tokens = s2.remainingTokens), (null == e2 ? void 0 : e2.$set) && (l2.$set = null == e2 ? void 0 : e2.$set);
            var u2, h2, d2 = this.Os(null == e2 ? void 0 : e2.$set_once);
            if (d2 && (l2.$set_once = d2), (l2 = tt(l2, null != e2 && e2._noTruncate ? null : this.config.properties_string_max_length)).timestamp = o2, R(null == e2 ? void 0 : e2.timestamp) || (l2.properties.$event_time_override_provided = true, l2.properties.$event_time_override_system_time = n2), t2 === Ro.DISMISSED || t2 === Ro.SENT) {
              var v2 = null == i2 ? void 0 : i2[To.SURVEY_ID], c2 = null == i2 ? void 0 : i2[To.SURVEY_ITERATION];
              localStorage.setItem((h2 = "" + bo + (u2 = { id: v2, current_iteration: c2 }).id, u2.current_iteration && u2.current_iteration > 0 && (h2 = "" + bo + u2.id + "_" + u2.current_iteration), h2), "true"), l2.$set = B$1({}, l2.$set, { [yo({ id: v2, current_iteration: c2 }, t2 === Ro.SENT ? "responded" : "dismissed")]: true });
            }
            var f2 = B$1({}, l2.properties.$set, l2.$set);
            if (P(f2) || this.setPersonPropertiesForFlags(f2), !F$1(this.config.before_send)) {
              var p2 = this.As(l2);
              if (!p2) return;
              l2 = p2;
            }
            this._s.emit("eventCaptured", l2);
            var g2 = { method: "POST", url: null !== (r2 = null == e2 ? void 0 : e2._url) && void 0 !== r2 ? r2 : this.requestRouter.endpointFor("api", this.analyticsDefaultEndpoint), data: l2, compression: "best-available", batchKey: null == e2 ? void 0 : e2._batchKey };
            return !this.config.request_batching || e2 && (null == e2 || !e2._batchKey) || null != e2 && e2.send_instantly ? this.Es(g2) : this.xs.enqueue(g2), l2;
          }
          N.critical("This capture call is ignored due to client rate limiting.");
        }
      } else N.error("No event name provided to posthog.capture");
    } else N.uninitializedWarning("posthog.capture");
  }
  Ge(t2) {
    return this.on("eventCaptured", (i2) => t2(i2.event, i2));
  }
  calculateEventProperties(t2, i2, e2, r2, s2) {
    if (e2 = e2 || /* @__PURE__ */ new Date(), !this.persistence || !this.sessionPersistence) return i2;
    var n2 = s2 ? void 0 : this.persistence.remove_event_timer(t2), a2 = B$1({}, i2);
    if (a2.token = this.config.token, a2.$config_defaults = this.config.defaults, this.config.__preview_experimental_cookieless_mode && (a2.$cookieless_mode = true), "$snapshot" === t2) {
      var l2 = B$1({}, this.persistence.properties(), this.sessionPersistence.properties());
      return a2.distinct_id = l2.distinct_id, (!T(a2.distinct_id) && !O(a2.distinct_id) || M(a2.distinct_id)) && N.error("Invalid distinct_id for replay event. This indicates a bug in your implementation"), a2;
    }
    var u2, h2 = io(this.config.mask_personal_data_properties, this.config.custom_personal_data_properties);
    if (this.sessionManager) {
      var { sessionId: v2, windowId: c2 } = this.sessionManager.checkAndGetSessionAndWindowId(s2, e2.getTime());
      a2.$session_id = v2, a2.$window_id = c2;
    }
    this.sessionPropsManager && V(a2, this.sessionPropsManager.getSessionProps());
    try {
      var f2;
      this.sessionRecording && V(a2, this.sessionRecording.sdkDebugProperties), a2.$sdk_debug_retry_queue_size = null == (f2 = this.Is) ? void 0 : f2.length;
    } catch (t3) {
      a2.$sdk_debug_error_capturing_properties = String(t3);
    }
    if (this.requestRouter.region === Yo.CUSTOM && (a2.$lib_custom_api_host = this.config.api_host), u2 = "$pageview" !== t2 || s2 ? "$pageleave" !== t2 || s2 ? this.pageViewManager.doEvent() : this.pageViewManager.doPageLeave(e2) : this.pageViewManager.doPageView(e2, r2), a2 = V(a2, u2), "$pageview" === t2 && o && (a2.title = o.title), !R(n2)) {
      var p2 = e2.getTime() - n2;
      a2.$duration = parseFloat((p2 / 1e3).toFixed(3));
    }
    d && this.config.opt_out_useragent_filter && (a2.$browser_type = this._is_bot() ? "bot" : "browser"), (a2 = V({}, h2, this.persistence.properties(), this.sessionPersistence.properties(), a2)).$is_identified = this._isIdentified(), x(this.config.property_denylist) ? J(this.config.property_denylist, function(t3) {
      delete a2[t3];
    }) : N.error("Invalid value for property_denylist config: " + this.config.property_denylist + " or property_blacklist config: " + this.config.property_blacklist);
    var g2 = this.config.sanitize_properties;
    g2 && (N.error("sanitize_properties is deprecated. Use before_send instead"), a2 = g2(a2, t2));
    var _2 = this.Ds();
    return a2.$process_person_profile = _2, _2 && !s2 && this.Ls("_calculate_event_properties"), a2;
  }
  Os(t2) {
    var i2;
    if (!this.persistence || !this.Ds()) return t2;
    if (this.gs) return t2;
    var e2 = this.persistence.get_initial_props(), r2 = null == (i2 = this.sessionPropsManager) ? void 0 : i2.getSetOnceProps(), s2 = V({}, e2, r2 || {}, t2 || {}), n2 = this.config.sanitize_properties;
    return n2 && (N.error("sanitize_properties is deprecated. Use before_send instead"), s2 = n2(s2, "$set_once")), this.gs = true, P(s2) ? void 0 : s2;
  }
  register(t2, i2) {
    var e2;
    null == (e2 = this.persistence) || e2.register(t2, i2);
  }
  register_once(t2, i2, e2) {
    var r2;
    null == (r2 = this.persistence) || r2.register_once(t2, i2, e2);
  }
  register_for_session(t2) {
    var i2;
    null == (i2 = this.sessionPersistence) || i2.register(t2);
  }
  unregister(t2) {
    var i2;
    null == (i2 = this.persistence) || i2.unregister(t2);
  }
  unregister_for_session(t2) {
    var i2;
    null == (i2 = this.sessionPersistence) || i2.unregister(t2);
  }
  js(t2, i2) {
    this.register({ [t2]: i2 });
  }
  getFeatureFlag(t2, i2) {
    return this.featureFlags.getFeatureFlag(t2, i2);
  }
  getFeatureFlagPayload(t2) {
    var i2 = this.featureFlags.getFeatureFlagPayload(t2);
    try {
      return JSON.parse(i2);
    } catch (t3) {
      return i2;
    }
  }
  isFeatureEnabled(t2, i2) {
    return this.featureFlags.isFeatureEnabled(t2, i2);
  }
  reloadFeatureFlags() {
    this.featureFlags.reloadFeatureFlags();
  }
  updateEarlyAccessFeatureEnrollment(t2, i2) {
    this.featureFlags.updateEarlyAccessFeatureEnrollment(t2, i2);
  }
  getEarlyAccessFeatures(t2, i2, e2) {
    return void 0 === i2 && (i2 = false), this.featureFlags.getEarlyAccessFeatures(t2, i2, e2);
  }
  on(t2, i2) {
    return this._s.on(t2, i2);
  }
  onFeatureFlags(t2) {
    return this.featureFlags.onFeatureFlags(t2);
  }
  onSurveysLoaded(t2) {
    return this.surveys.onSurveysLoaded(t2);
  }
  onSessionId(t2) {
    var i2, e2;
    return null !== (i2 = null == (e2 = this.sessionManager) ? void 0 : e2.onSessionId(t2)) && void 0 !== i2 ? i2 : () => {
    };
  }
  getSurveys(t2, i2) {
    void 0 === i2 && (i2 = false), this.surveys.getSurveys(t2, i2);
  }
  getActiveMatchingSurveys(t2, i2) {
    void 0 === i2 && (i2 = false), this.surveys.getActiveMatchingSurveys(t2, i2);
  }
  renderSurvey(t2, i2) {
    this.surveys.renderSurvey(t2, i2);
  }
  canRenderSurvey(t2) {
    return this.surveys.canRenderSurvey(t2);
  }
  canRenderSurveyAsync(t2, i2) {
    return void 0 === i2 && (i2 = false), this.surveys.canRenderSurveyAsync(t2, i2);
  }
  identify(t2, i2, e2) {
    if (!this.__loaded || !this.persistence) return N.uninitializedWarning("posthog.identify");
    if (O(t2) && (t2 = t2.toString(), N.warn("The first argument to posthog.identify was a number, but it should be a string. It has been converted to a string.")), t2) if (["distinct_id", "distinctid"].includes(t2.toLowerCase())) N.critical('The string "' + t2 + '" was set in posthog.identify which indicates an error. This ID should be unique to the user and not a hardcoded string.');
    else if (t2 !== Bt) {
      if (this.Ls("posthog.identify")) {
        var r2 = this.get_distinct_id();
        if (this.register({ $user_id: t2 }), !this.get_property("$device_id")) {
          var s2 = r2;
          this.register_once({ $had_persisted_distinct_id: true, $device_id: s2 }, "");
        }
        t2 !== r2 && t2 !== this.get_property(ot) && (this.unregister(ot), this.register({ distinct_id: t2 }));
        var n2 = "anonymous" === (this.persistence.get_property(At) || "anonymous");
        t2 !== r2 && n2 ? (this.persistence.set_property(At, "identified"), this.setPersonPropertiesForFlags(B$1({}, e2 || {}, i2 || {}), false), this.capture("$identify", { distinct_id: t2, $anon_distinct_id: r2 }, { $set: i2 || {}, $set_once: e2 || {} }), this.Ss = zs(t2, i2, e2), this.featureFlags.setAnonymousDistinctId(r2)) : (i2 || e2) && this.setPersonProperties(i2, e2), t2 !== r2 && (this.reloadFeatureFlags(), this.unregister(Ot));
      }
    } else N.critical('The string "' + Bt + '" was set in posthog.identify which indicates an error. This ID is only used as a sentinel value.');
    else N.error("Unique user id has not been set in posthog.identify");
  }
  setPersonProperties(t2, i2) {
    if ((t2 || i2) && this.Ls("posthog.setPersonProperties")) {
      var e2 = zs(this.get_distinct_id(), t2, i2);
      this.Ss !== e2 ? (this.setPersonPropertiesForFlags(B$1({}, i2 || {}, t2 || {})), this.capture("$set", { $set: t2 || {}, $set_once: i2 || {} }), this.Ss = e2) : N.info("A duplicate setPersonProperties call was made with the same properties. It has been ignored.");
    }
  }
  group(t2, i2, e2) {
    if (t2 && i2) {
      if (this.Ls("posthog.group")) {
        var r2 = this.getGroups();
        r2[t2] !== i2 && this.resetGroupPropertiesForFlags(t2), this.register({ $groups: B$1({}, r2, { [t2]: i2 }) }), e2 && (this.capture("$groupidentify", { $group_type: t2, $group_key: i2, $group_set: e2 }), this.setGroupPropertiesForFlags({ [t2]: e2 })), r2[t2] === i2 || e2 || this.reloadFeatureFlags();
      }
    } else N.error("posthog.group requires a group type and group key");
  }
  resetGroups() {
    this.register({ $groups: {} }), this.resetGroupPropertiesForFlags(), this.reloadFeatureFlags();
  }
  setPersonPropertiesForFlags(t2, i2) {
    void 0 === i2 && (i2 = true), this.featureFlags.setPersonPropertiesForFlags(t2, i2);
  }
  resetPersonPropertiesForFlags() {
    this.featureFlags.resetPersonPropertiesForFlags();
  }
  setGroupPropertiesForFlags(t2, i2) {
    void 0 === i2 && (i2 = true), this.Ls("posthog.setGroupPropertiesForFlags") && this.featureFlags.setGroupPropertiesForFlags(t2, i2);
  }
  resetGroupPropertiesForFlags(t2) {
    this.featureFlags.resetGroupPropertiesForFlags(t2);
  }
  reset(t2) {
    var i2, e2, r2, s2;
    if (N.info("reset"), !this.__loaded) return N.uninitializedWarning("posthog.reset");
    var n2 = this.get_property("$device_id");
    if (this.consent.reset(), null == (i2 = this.persistence) || i2.clear(), null == (e2 = this.sessionPersistence) || e2.clear(), this.surveys.reset(), null == (r2 = this.persistence) || r2.set_property(At, "anonymous"), null == (s2 = this.sessionManager) || s2.resetSessionId(), this.Ss = null, this.config.__preview_experimental_cookieless_mode) this.register_once({ distinct_id: Bt, $device_id: null }, "");
    else {
      var o2 = this.config.get_device_id(ji());
      this.register_once({ distinct_id: o2, $device_id: t2 ? o2 : n2 }, "");
    }
    this.register({ $last_posthog_reset: (/* @__PURE__ */ new Date()).toISOString() }, 1);
  }
  get_distinct_id() {
    return this.get_property("distinct_id");
  }
  getGroups() {
    return this.get_property("$groups") || {};
  }
  get_session_id() {
    var t2, i2;
    return null !== (t2 = null == (i2 = this.sessionManager) ? void 0 : i2.checkAndGetSessionAndWindowId(true).sessionId) && void 0 !== t2 ? t2 : "";
  }
  get_session_replay_url(t2) {
    if (!this.sessionManager) return "";
    var { sessionId: i2, sessionStartTimestamp: e2 } = this.sessionManager.checkAndGetSessionAndWindowId(true), r2 = this.requestRouter.endpointFor("ui", "/project/" + this.config.token + "/replay/" + i2);
    if (null != t2 && t2.withTimestamp && e2) {
      var s2, n2 = null !== (s2 = t2.timestampLookBack) && void 0 !== s2 ? s2 : 10;
      if (!e2) return r2;
      r2 += "?t=" + Math.max(Math.floor(((/* @__PURE__ */ new Date()).getTime() - e2) / 1e3) - n2, 0);
    }
    return r2;
  }
  alias(t2, i2) {
    return t2 === this.get_property(nt) ? (N.critical("Attempting to create alias for existing People user - aborting."), -2) : this.Ls("posthog.alias") ? (R(i2) && (i2 = this.get_distinct_id()), t2 !== i2 ? (this.js(ot, t2), this.capture("$create_alias", { alias: t2, distinct_id: i2 })) : (N.warn("alias matches current distinct_id - skipping api call."), this.identify(t2), -1)) : void 0;
  }
  set_config(t2) {
    var i2, e2, r2, s2, n2 = B$1({}, this.config);
    I$1(t2) && (V(this.config, oa(t2)), null == (i2 = this.persistence) || i2.update_config(this.config, n2), this.sessionPersistence = "sessionStorage" === this.config.persistence || "memory" === this.config.persistence ? this.persistence : new po(B$1({}, this.config, { persistence: "sessionStorage" })), Wi.O() && "true" === Wi.D("ph_debug") && (this.config.debug = true), this.config.debug && (c.DEBUG = true, N.info("set_config", { config: t2, oldConfig: n2, newConfig: B$1({}, this.config) })), null == (e2 = this.sessionRecording) || e2.startIfEnabledOrStop(), null == (r2 = this.autocapture) || r2.startIfEnabled(), null == (s2 = this.heatmaps) || s2.startIfEnabled(), this.surveys.loadIfEnabled(), this.Ps());
  }
  startSessionRecording(t2) {
    var i2 = true === t2, e2 = { sampling: i2 || !(null == t2 || !t2.sampling), linked_flag: i2 || !(null == t2 || !t2.linked_flag), url_trigger: i2 || !(null == t2 || !t2.url_trigger), event_trigger: i2 || !(null == t2 || !t2.event_trigger) };
    if (Object.values(e2).some(Boolean)) {
      var r2, s2, n2, o2, a2;
      if (null == (r2 = this.sessionManager) || r2.checkAndGetSessionAndWindowId(), e2.sampling) null == (s2 = this.sessionRecording) || s2.overrideSampling();
      if (e2.linked_flag) null == (n2 = this.sessionRecording) || n2.overrideLinkedFlag();
      if (e2.url_trigger) null == (o2 = this.sessionRecording) || o2.overrideTrigger("url");
      if (e2.event_trigger) null == (a2 = this.sessionRecording) || a2.overrideTrigger("event");
    }
    this.set_config({ disable_session_recording: false });
  }
  stopSessionRecording() {
    this.set_config({ disable_session_recording: true });
  }
  sessionRecordingStarted() {
    var t2;
    return !(null == (t2 = this.sessionRecording) || !t2.started);
  }
  captureException(t2, i2) {
    var e2 = new Error("PostHog syntheticException");
    this.exceptions.sendExceptionEvent(B$1({}, Le(((t3) => t3 instanceof Error)(t2) ? { error: t2, event: t2.message } : { event: t2 }, { syntheticException: e2 }), i2));
  }
  loadToolbar(t2) {
    return this.toolbar.loadToolbar(t2);
  }
  get_property(t2) {
    var i2;
    return null == (i2 = this.persistence) ? void 0 : i2.props[t2];
  }
  getSessionProperty(t2) {
    var i2;
    return null == (i2 = this.sessionPersistence) ? void 0 : i2.props[t2];
  }
  toString() {
    var t2, i2 = null !== (t2 = this.config.name) && void 0 !== t2 ? t2 : ra;
    return i2 !== ra && (i2 = ra + "." + i2), i2;
  }
  _isIdentified() {
    var t2, i2;
    return "identified" === (null == (t2 = this.persistence) ? void 0 : t2.get_property(At)) || "identified" === (null == (i2 = this.sessionPersistence) ? void 0 : i2.get_property(At));
  }
  Ds() {
    var t2, i2;
    return !("never" === this.config.person_profiles || "identified_only" === this.config.person_profiles && !this._isIdentified() && P(this.getGroups()) && (null == (t2 = this.persistence) || null == (t2 = t2.props) || !t2[ot]) && (null == (i2 = this.persistence) || null == (i2 = i2.props) || !i2[Ut]));
  }
  Fs() {
    return true === this.config.capture_pageleave || "if_capture_pageview" === this.config.capture_pageleave && (true === this.config.capture_pageview || "history_change" === this.config.capture_pageview);
  }
  createPersonProfile() {
    this.Ds() || this.Ls("posthog.createPersonProfile") && this.setPersonProperties({}, {});
  }
  Ls(t2) {
    return "never" === this.config.person_profiles ? (N.error(t2 + ' was called, but process_person is set to "never". This call will be ignored.'), false) : (this.js(Ut, true), true);
  }
  Ps() {
    var t2, i2, e2, r2, s2 = this.consent.isOptedOut(), n2 = this.config.opt_out_persistence_by_default, o2 = this.config.disable_persistence || s2 && !!n2;
    (null == (t2 = this.persistence) ? void 0 : t2.Fe) !== o2 && (null == (e2 = this.persistence) || e2.set_disabled(o2));
    (null == (i2 = this.sessionPersistence) ? void 0 : i2.Fe) !== o2 && (null == (r2 = this.sessionPersistence) || r2.set_disabled(o2));
  }
  opt_in_capturing(t2) {
    var i2;
    (this.consent.optInOut(true), this.Ps(), R(null == t2 ? void 0 : t2.captureEventName) || null != t2 && t2.captureEventName) && this.capture(null !== (i2 = null == t2 ? void 0 : t2.captureEventName) && void 0 !== i2 ? i2 : "$opt_in", null == t2 ? void 0 : t2.captureProperties, { send_instantly: true });
    this.config.capture_pageview && this.Cs();
  }
  opt_out_capturing() {
    this.consent.optInOut(false), this.Ps();
  }
  has_opted_in_capturing() {
    return this.consent.isOptedIn();
  }
  has_opted_out_capturing() {
    return this.consent.isOptedOut();
  }
  clear_opt_in_out_capturing() {
    this.consent.reset(), this.Ps();
  }
  _is_bot() {
    return n ? Ko(n, this.config.custom_blocked_useragents) : void 0;
  }
  Cs() {
    o && ("visible" === o.visibilityState ? this.bs || (this.bs = true, this.capture("$pageview", { title: o.title }, { send_instantly: true }), this.ys && (o.removeEventListener("visibilitychange", this.ys), this.ys = null)) : this.ys || (this.ys = this.Cs.bind(this), st(o, "visibilitychange", this.ys)));
  }
  debug(i2) {
    false === i2 ? (null == t || t.console.log("You've disabled debug mode."), localStorage && localStorage.removeItem("ph_debug"), this.set_config({ debug: false })) : (null == t || t.console.log("You're now in debug mode. All calls to PostHog will be logged in your console.\nYou can disable this with `posthog.debug(false)`."), localStorage && localStorage.setItem("ph_debug", "true"), this.set_config({ debug: true }));
  }
  I() {
    var t2, i2, e2, r2, s2, n2, o2, a2 = this.$s || {};
    return "advanced_disable_flags" in a2 ? !!a2.advanced_disable_flags : false !== this.config.advanced_disable_flags ? !!this.config.advanced_disable_flags : true === this.config.advanced_disable_decide ? (N.warn("Config field 'advanced_disable_decide' is deprecated. Please use 'advanced_disable_flags' instead. The old field will be removed in a future major version."), true) : (e2 = "advanced_disable_decide", r2 = false, s2 = N, n2 = (i2 = "advanced_disable_flags") in (t2 = a2) && !R(t2[i2]), o2 = e2 in t2 && !R(t2[e2]), n2 ? t2[i2] : o2 ? (s2 && s2.warn("Config field '" + e2 + "' is deprecated. Please use '" + i2 + "' instead. The old field will be removed in a future major version."), t2[e2]) : r2);
  }
  As(t2) {
    if (F$1(this.config.before_send)) return t2;
    var i2 = x(this.config.before_send) ? this.config.before_send : [this.config.before_send], e2 = t2;
    for (var r2 of i2) {
      if (e2 = r2(e2), F$1(e2)) {
        var s2 = "Event '" + t2.event + "' was rejected in beforeSend function";
        return L(t2.event) ? N.warn(s2 + ". This can cause unexpected behavior.") : N.info(s2), null;
      }
      e2.properties && !P(e2.properties) || N.warn("Event '" + t2.event + "' has no properties after beforeSend function, this is likely an error.");
    }
    return e2;
  }
  getPageViewId() {
    var t2;
    return null == (t2 = this.pageViewManager.ce) ? void 0 : t2.pageViewId;
  }
  captureTraceFeedback(t2, i2) {
    this.capture("$ai_feedback", { $ai_trace_id: String(t2), $ai_feedback_text: i2 });
  }
  captureTraceMetric(t2, i2, e2) {
    this.capture("$ai_metric", { $ai_trace_id: String(t2), $ai_metric_name: i2, $ai_metric_value: String(e2) });
  }
}
!function(t2, i2) {
  for (var e2 = 0; e2 < i2.length; e2++) t2.prototype[i2[e2]] = Q(t2.prototype[i2[e2]]);
}(la, ["identify"]);
var ua, ha = (ua = ia[ra] = new la(), function() {
  function i2() {
    i2.done || (i2.done = true, sa = false, J(ia, function(t2) {
      t2._dom_loaded();
    }));
  }
  null != o && o.addEventListener ? "complete" === o.readyState ? i2() : st(o, "DOMContentLoaded", i2, { capture: false }) : t && N.error("Browser doesn't support `document.addEventListener` so PostHog couldn't be initialized");
}(), ua);
var PostHogContext = reactExports.createContext({ client: ha });
function isDeepEqual(obj1, obj2, visited) {
  if (visited === void 0) {
    visited = /* @__PURE__ */ new WeakMap();
  }
  if (obj1 === obj2) {
    return true;
  }
  if (typeof obj1 !== "object" || obj1 === null || typeof obj2 !== "object" || obj2 === null) {
    return false;
  }
  if (visited.has(obj1) && visited.get(obj1) === obj2) {
    return true;
  }
  visited.set(obj1, obj2);
  var keys1 = Object.keys(obj1);
  var keys2 = Object.keys(obj2);
  if (keys1.length !== keys2.length) {
    return false;
  }
  for (var _i2 = 0, keys1_1 = keys1; _i2 < keys1_1.length; _i2++) {
    var key = keys1_1[_i2];
    if (!keys2.includes(key)) {
      return false;
    }
    if (!isDeepEqual(obj1[key], obj2[key], visited)) {
      return false;
    }
  }
  return true;
}
function PostHogProvider(_a) {
  var children = _a.children, client = _a.client, apiKey = _a.apiKey, options = _a.options;
  var previousInitializationRef = reactExports.useRef(null);
  var posthog = reactExports.useMemo(function() {
    if (client) {
      if (apiKey) {
        console.warn("[PostHog.js] You have provided both `client` and `apiKey` to `PostHogProvider`. `apiKey` will be ignored in favour of `client`.");
      }
      if (options) {
        console.warn("[PostHog.js] You have provided both `client` and `options` to `PostHogProvider`. `options` will be ignored in favour of `client`.");
      }
      return client;
    }
    if (apiKey) {
      return ha;
    }
    console.warn("[PostHog.js] No `apiKey` or `client` were provided to `PostHogProvider`. Using default global `window.posthog` instance. You must initialize it manually. This is not recommended behavior.");
    return ha;
  }, [client, apiKey, JSON.stringify(options)]);
  reactExports.useEffect(function() {
    if (client) {
      return;
    }
    var previousInitialization = previousInitializationRef.current;
    if (!previousInitialization) {
      if (ha.__loaded) {
        console.warn("[PostHog.js] `posthog` was already loaded elsewhere. This may cause issues.");
      }
      ha.init(apiKey, options);
      previousInitializationRef.current = {
        apiKey,
        options: options !== null && options !== void 0 ? options : {}
      };
    } else {
      if (apiKey !== previousInitialization.apiKey) {
        console.warn("[PostHog.js] You have provided a different `apiKey` to `PostHogProvider` than the one that was already initialized. This is not supported by our provider and we'll keep using the previous key. If you need to toggle between API Keys you need to control the `client` yourself and pass it in as a prop rather than an `apiKey` prop.");
      }
      if (options && !isDeepEqual(options, previousInitialization.options)) {
        ha.set_config(options);
      }
      previousInitializationRef.current = {
        apiKey,
        options: options !== null && options !== void 0 ? options : {}
      };
    }
  }, [client, apiKey, JSON.stringify(options)]);
  return React3.createElement(PostHogContext.Provider, { value: { client: posthog } }, children);
}
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
};
var isFunction$1 = function(f2) {
  return typeof f2 === "function";
};
var INITIAL_STATE = {
  componentStack: null,
  error: null
};
var __POSTHOG_ERROR_MESSAGES = {
  INVALID_FALLBACK: "[PostHog.js][PostHogErrorBoundary] Invalid fallback prop, provide a valid React element or a function that returns a valid React element."
};
(function(_super) {
  __extends(PostHogErrorBoundary, _super);
  function PostHogErrorBoundary(props) {
    var _this = _super.call(this, props) || this;
    _this.state = INITIAL_STATE;
    return _this;
  }
  PostHogErrorBoundary.prototype.componentDidCatch = function(error, errorInfo) {
    var componentStack = errorInfo.componentStack;
    var additionalProperties = this.props.additionalProperties;
    this.setState({
      error,
      componentStack
    });
    var currentProperties;
    if (isFunction$1(additionalProperties)) {
      currentProperties = additionalProperties(error);
    } else if (typeof additionalProperties === "object") {
      currentProperties = additionalProperties;
    }
    var client = this.context.client;
    client.captureException(error, currentProperties);
  };
  PostHogErrorBoundary.prototype.render = function() {
    var _a = this.props, children = _a.children, fallback = _a.fallback;
    var state = this.state;
    if (state.componentStack == null) {
      return isFunction$1(children) ? children() : children;
    }
    var element = isFunction$1(fallback) ? React3.createElement(fallback, {
      error: state.error,
      componentStack: state.componentStack
    }) : fallback;
    if (React3.isValidElement(element)) {
      return element;
    }
    console.warn(__POSTHOG_ERROR_MESSAGES.INVALID_FALLBACK);
    return React3.createElement(React3.Fragment, null);
  };
  PostHogErrorBoundary.contextType = PostHogContext;
  return PostHogErrorBoundary;
})(React3.Component);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase().trim();
const createLucideIcon = (iconName, iconNode) => {
  const Component = reactExports.forwardRef(
    ({
      color: color2 = "currentColor",
      size = 24,
      strokeWidth = 2,
      absoluteStrokeWidth,
      className = "",
      children,
      ...rest
    }, ref2) => {
      return reactExports.createElement(
        "svg",
        {
          ref: ref2,
          ...defaultAttributes,
          width: size,
          height: size,
          stroke: color2,
          strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,
          className: ["lucide", `lucide-${toKebabCase(iconName)}`, className].join(" "),
          ...rest
        },
        [
          ...iconNode.map(([tag, attrs]) => reactExports.createElement(tag, attrs)),
          ...Array.isArray(children) ? children : [children]
        ]
      );
    }
  );
  Component.displayName = `${iconName}`;
  return Component;
};
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const AlertTriangle = createLucideIcon("AlertTriangle", [
  [
    "path",
    {
      d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z",
      key: "c3ski4"
    }
  ],
  ["path", { d: "M12 9v4", key: "juzpu7" }],
  ["path", { d: "M12 17h.01", key: "p32p05" }]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ArrowLeft = createLucideIcon("ArrowLeft", [
  ["path", { d: "m12 19-7-7 7-7", key: "1l729n" }],
  ["path", { d: "M19 12H5", key: "x3x0zl" }]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ArrowRight = createLucideIcon("ArrowRight", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "m12 5 7 7-7 7", key: "xquz4c" }]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Award = createLucideIcon("Award", [
  ["circle", { cx: "12", cy: "8", r: "6", key: "1vp47v" }],
  ["path", { d: "M15.477 12.89 17 22l-5-3-5 3 1.523-9.11", key: "em7aur" }]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const BarChart3 = createLucideIcon("BarChart3", [
  ["path", { d: "M3 3v18h18", key: "1s2lah" }],
  ["path", { d: "M18 17V9", key: "2bz60n" }],
  ["path", { d: "M13 17V5", key: "1frdt8" }],
  ["path", { d: "M8 17v-3", key: "17ska0" }]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Clock = createLucideIcon("Clock", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["polyline", { points: "12 6 12 12 16 14", key: "68esgv" }]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Cookie = createLucideIcon("Cookie", [
  ["path", { d: "M12 2a10 10 0 1 0 10 10 4 4 0 0 1-5-5 4 4 0 0 1-5-5", key: "laymnq" }],
  ["path", { d: "M8.5 8.5v.01", key: "ue8clq" }],
  ["path", { d: "M16 15.5v.01", key: "14dtrp" }],
  ["path", { d: "M12 12v.01", key: "u5ubse" }],
  ["path", { d: "M11 17v.01", key: "1hyl5a" }],
  ["path", { d: "M7 14v.01", key: "uct60s" }]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const CreditCard = createLucideIcon("CreditCard", [
  ["rect", { width: "20", height: "14", x: "2", y: "5", rx: "2", key: "ynyp8z" }],
  ["line", { x1: "2", x2: "22", y1: "10", y2: "10", key: "1b3vmo" }]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Crown = createLucideIcon("Crown", [
  ["path", { d: "m2 4 3 12h14l3-12-6 7-4-7-4 7-6-7zm3 16h14", key: "zkxr6b" }]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ExternalLink = createLucideIcon("ExternalLink", [
  ["path", { d: "M15 3h6v6", key: "1q9fwt" }],
  ["path", { d: "M10 14 21 3", key: "gplh6r" }],
  ["path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6", key: "a6xqqp" }]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Eye = createLucideIcon("Eye", [
  ["path", { d: "M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z", key: "rwhkz3" }],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Facebook = createLucideIcon("Facebook", [
  [
    "path",
    { d: "M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z", key: "1jg4f8" }
  ]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const FileText = createLucideIcon("FileText", [
  ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }],
  ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
  ["path", { d: "M10 9H8", key: "b1mrlr" }],
  ["path", { d: "M16 13H8", key: "t4e002" }],
  ["path", { d: "M16 17H8", key: "z1uh3a" }]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Heart = createLucideIcon("Heart", [
  [
    "path",
    {
      d: "M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z",
      key: "c3ymky"
    }
  ]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Image = createLucideIcon("Image", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2", key: "1m3agn" }],
  ["circle", { cx: "9", cy: "9", r: "2", key: "af1f0g" }],
  ["path", { d: "m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21", key: "1xmnt7" }]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Instagram = createLucideIcon("Instagram", [
  ["rect", { width: "20", height: "20", x: "2", y: "2", rx: "5", ry: "5", key: "2e1cvw" }],
  ["path", { d: "M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z", key: "9exkf1" }],
  ["line", { x1: "17.5", x2: "17.51", y1: "6.5", y2: "6.5", key: "r4j83e" }]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Lightbulb = createLucideIcon("Lightbulb", [
  [
    "path",
    {
      d: "M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .2 2.2 1.5 3.5.7.7 1.3 1.5 1.5 2.5",
      key: "1gvzjb"
    }
  ],
  ["path", { d: "M9 18h6", key: "x1upvd" }],
  ["path", { d: "M10 22h4", key: "ceow96" }]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Linkedin = createLucideIcon("Linkedin", [
  [
    "path",
    {
      d: "M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z",
      key: "c2jq9f"
    }
  ],
  ["rect", { width: "4", height: "12", x: "2", y: "9", key: "mk3on5" }],
  ["circle", { cx: "4", cy: "4", r: "2", key: "bt5ra8" }]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Lock = createLucideIcon("Lock", [
  ["rect", { width: "18", height: "11", x: "3", y: "11", rx: "2", ry: "2", key: "1w4ew1" }],
  ["path", { d: "M7 11V7a5 5 0 0 1 10 0v4", key: "fwvmzm" }]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Mail = createLucideIcon("Mail", [
  ["rect", { width: "20", height: "16", x: "2", y: "4", rx: "2", key: "18n3k1" }],
  ["path", { d: "m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7", key: "1ocrg3" }]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Menu = createLucideIcon("Menu", [
  ["line", { x1: "4", x2: "20", y1: "12", y2: "12", key: "1e0a9i" }],
  ["line", { x1: "4", x2: "20", y1: "6", y2: "6", key: "1owob3" }],
  ["line", { x1: "4", x2: "20", y1: "18", y2: "18", key: "yk5zj1" }]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Minus = createLucideIcon("Minus", [["path", { d: "M5 12h14", key: "1ays0h" }]]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Palette = createLucideIcon("Palette", [
  ["circle", { cx: "13.5", cy: "6.5", r: ".5", fill: "currentColor", key: "1okk4w" }],
  ["circle", { cx: "17.5", cy: "10.5", r: ".5", fill: "currentColor", key: "f64h9f" }],
  ["circle", { cx: "8.5", cy: "7.5", r: ".5", fill: "currentColor", key: "fotxhn" }],
  ["circle", { cx: "6.5", cy: "12.5", r: ".5", fill: "currentColor", key: "qy21gx" }],
  [
    "path",
    {
      d: "M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z",
      key: "12rzf8"
    }
  ]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Plus = createLucideIcon("Plus", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Printer = createLucideIcon("Printer", [
  ["polyline", { points: "6 9 6 2 18 2 18 9", key: "1306q4" }],
  [
    "path",
    {
      d: "M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2",
      key: "143wyd"
    }
  ],
  ["rect", { width: "12", height: "8", x: "6", y: "14", key: "5ipwut" }]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Scale = createLucideIcon("Scale", [
  ["path", { d: "m16 16 3-8 3 8c-.87.65-1.92 1-3 1s-2.13-.35-3-1Z", key: "7g6ntu" }],
  ["path", { d: "m2 16 3-8 3 8c-.87.65-1.92 1-3 1s-2.13-.35-3-1Z", key: "ijws7r" }],
  ["path", { d: "M7 21h10", key: "1b0cd5" }],
  ["path", { d: "M12 3v18", key: "108xh3" }],
  ["path", { d: "M3 7h2c2 0 5-1 7-2 2 1 5 2 7 2h2", key: "3gwbw2" }]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Settings$1 = createLucideIcon("Settings", [
  [
    "path",
    {
      d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z",
      key: "1qme2f"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Shield = createLucideIcon("Shield", [
  [
    "path",
    {
      d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
      key: "oel41y"
    }
  ]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Sparkles = createLucideIcon("Sparkles", [
  [
    "path",
    {
      d: "m12 3-1.912 5.813a2 2 0 0 1-1.275 1.275L3 12l5.813 1.912a2 2 0 0 1 1.275 1.275L12 21l1.912-5.813a2 2 0 0 1 1.275-1.275L21 12l-5.813-1.912a2 2 0 0 1-1.275-1.275L12 3Z",
      key: "17u4zn"
    }
  ],
  ["path", { d: "M5 3v4", key: "bklmnn" }],
  ["path", { d: "M19 17v4", key: "iiml17" }],
  ["path", { d: "M3 5h4", key: "nem4j1" }],
  ["path", { d: "M17 19h4", key: "lbex7p" }]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Star = createLucideIcon("Star", [
  [
    "polygon",
    {
      points: "12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2",
      key: "8f66p6"
    }
  ]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Upload = createLucideIcon("Upload", [
  ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }],
  ["polyline", { points: "17 8 12 3 7 8", key: "t8dd8p" }],
  ["line", { x1: "12", x2: "12", y1: "3", y2: "15", key: "widbto" }]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const UserCheck = createLucideIcon("UserCheck", [
  ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }],
  ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }],
  ["polyline", { points: "16 11 18 13 22 9", key: "1pwet4" }]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Users = createLucideIcon("Users", [
  ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }],
  ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }],
  ["path", { d: "M22 21v-2a4 4 0 0 0-3-3.87", key: "kshegd" }],
  ["path", { d: "M16 3.13a4 4 0 0 1 0 7.75", key: "1da9ce" }]
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const X$1 = createLucideIcon("X", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]);
const LanguageSelector = () => {
  const { language, setLanguage } = useLanguage();
  const location2 = useLocation();
  const navigate = useNavigate();
  const handleLanguageChange = (newLanguage) => {
    const currentPath = location2.pathname;
    if (newLanguage === "en") {
      if (currentPath.startsWith("/en")) {
        setLanguage("en");
        return;
      } else {
        const newPath = currentPath === "/" ? "/en" : `/en${currentPath}`;
        navigate(newPath);
      }
    } else {
      if (currentPath.startsWith("/en")) {
        const newPath = currentPath.replace("/en", "") || "/";
        navigate(newPath);
      } else {
        setLanguage("pt-BR");
        return;
      }
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "select",
    {
      value: language,
      onChange: (e2) => handleLanguageChange(e2.target.value),
      className: "bg-transparent text-gray-600 hover:text-primary-600 font-medium focus:outline-none cursor-pointer",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "pt-BR", children: "Português (BR)" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "en", children: "English" })
      ]
    }
  );
};
const Header = () => {
  const [isMenuOpen, setIsMenuOpen] = reactExports.useState(false);
  const [isScrolled, setIsScrolled] = reactExports.useState(false);
  const location2 = useLocation();
  const { t: t2, language } = useLanguage();
  reactExports.useEffect(() => {
    const handleScroll = () => {
      if (window.scrollY > 10) {
        setIsScrolled(true);
      } else {
        setIsScrolled(false);
      }
    };
    window.addEventListener("scroll", handleScroll);
    return () => window.removeEventListener("scroll", handleScroll);
  }, []);
  reactExports.useEffect(() => {
    setIsMenuOpen(false);
  }, [location2.pathname]);
  const headerClass = isScrolled ? "bg-white shadow-md" : "bg-transparent";
  const isHomePage = location2.pathname === "/" || location2.pathname === "/en";
  const getLanguagePrefix = () => {
    return location2.pathname.startsWith("/en") ? "/en" : "";
  };
  const handleSectionScroll = (e2, sectionId) => {
    e2.preventDefault();
    if (!isHomePage) {
      const prefix = getLanguagePrefix();
      window.location.href = `${prefix}/#${sectionId}`;
      return;
    }
    const section = document.getElementById(sectionId);
    if (section) {
      section.scrollIntoView({ behavior: "smooth" });
    }
  };
  const handlePricingClick = (e2) => {
    e2.preventDefault();
    if (!isHomePage) {
      const prefix = getLanguagePrefix();
      window.location.href = `${prefix}/#pricing`;
      return;
    }
    const pricingSection = document.getElementById("pricing");
    if (pricingSection) {
      pricingSection.scrollIntoView({ behavior: "smooth" });
    }
  };
  const handleGetStartedClick = () => {
    window.location.href = "https://app.mylinearts.com";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "header",
    {
      className: `sticky top-0 z-50 transition-all duration-300 ${headerClass}`,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container mx-auto px-4 sm:px-6 lg:px-8", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between h-16 md:h-20", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: getLanguagePrefix() || "/", className: "flex items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "/logo.png", alt: "MylineArts Logo", className: "h-10 w-auto" }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("nav", { className: "hidden xl:flex items-center space-x-6", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSelector, {}),
            isHomePage ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "a",
                {
                  href: "#how-it-works",
                  onClick: (e2) => handleSectionScroll(e2, "how-it-works"),
                  className: "text-gray-600 hover:text-primary-600 font-medium whitespace-nowrap",
                  children: t2("nav.howItWorks")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "a",
                {
                  href: "#benefits",
                  onClick: (e2) => handleSectionScroll(e2, "benefits"),
                  className: "text-gray-600 hover:text-primary-600 font-medium whitespace-nowrap",
                  children: t2("nav.benefits")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "a",
                {
                  href: "#about-us",
                  onClick: (e2) => handleSectionScroll(e2, "about-us"),
                  className: "text-gray-600 hover:text-primary-600 font-medium whitespace-nowrap",
                  children: language === "pt-BR" ? "Sobre nós" : "About us"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "a",
                {
                  href: "#pricing",
                  onClick: handlePricingClick,
                  className: "text-gray-600 hover:text-primary-600 font-medium whitespace-nowrap",
                  children: t2("nav.pricing")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "a",
                {
                  href: "#faq",
                  onClick: (e2) => handleSectionScroll(e2, "faq"),
                  className: "text-gray-600 hover:text-primary-600 font-medium whitespace-nowrap",
                  children: t2("nav.faq")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Link,
                {
                  to: `${getLanguagePrefix()}/blog`,
                  className: "text-gray-600 hover:text-primary-600 font-medium whitespace-nowrap",
                  children: language === "pt-BR" ? "Blog" : "Blog"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "button",
                {
                  onClick: handleGetStartedClick,
                  className: "btn btn-primary whitespace-nowrap",
                  children: t2("nav.getStarted")
                }
              )
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center space-x-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: handleGetStartedClick,
                className: "btn btn-primary whitespace-nowrap",
                children: t2("nav.getStarted")
              }
            ) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "xl:hidden flex items-center space-x-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSelector, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                type: "button",
                className: "text-gray-500 hover:text-gray-600 focus:outline-none",
                "aria-label": "Toggle menu",
                onClick: () => setIsMenuOpen(!isMenuOpen),
                children: isMenuOpen ? /* @__PURE__ */ jsxRuntimeExports.jsx(X$1, { className: "h-6 w-6" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Menu, { className: "h-6 w-6" })
              }
            )
          ] })
        ] }) }),
        isMenuOpen && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "xl:hidden bg-white shadow-lg absolute w-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-4 py-3 space-y-2 sm:px-6", children: isHomePage ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "a",
            {
              href: "#how-it-works",
              onClick: (e2) => handleSectionScroll(e2, "how-it-works"),
              className: "block py-2 text-gray-600 hover:text-primary-600 font-medium",
              children: t2("nav.howItWorks")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "a",
            {
              href: "#benefits",
              onClick: (e2) => handleSectionScroll(e2, "benefits"),
              className: "block py-2 text-gray-600 hover:text-primary-600 font-medium",
              children: t2("nav.benefits")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "a",
            {
              href: "#about-us",
              onClick: (e2) => handleSectionScroll(e2, "about-us"),
              className: "block py-2 text-gray-600 hover:text-primary-600 font-medium",
              children: language === "pt-BR" ? "Sobre nós" : "About us"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "a",
            {
              href: "#pricing",
              onClick: handlePricingClick,
              className: "block py-2 text-gray-600 hover:text-primary-600 font-medium",
              children: t2("nav.pricing")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "a",
            {
              href: "#faq",
              onClick: (e2) => handleSectionScroll(e2, "faq"),
              className: "block py-2 text-gray-600 hover:text-primary-600 font-medium",
              children: t2("nav.faq")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Link,
            {
              to: `${getLanguagePrefix()}/blog`,
              className: "block py-2 text-gray-600 hover:text-primary-600 font-medium",
              children: language === "pt-BR" ? "Blog" : "Blog"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              onClick: handleGetStartedClick,
              className: "block w-full text-center py-2 px-4 bg-primary-600 text-white rounded-md hover:bg-primary-700 font-medium",
              children: t2("nav.getStarted")
            }
          )
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "py-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            onClick: handleGetStartedClick,
            className: "block w-full text-center py-2 px-4 bg-primary-600 text-white rounded-md hover:bg-primary-700 font-medium",
            children: t2("nav.getStarted")
          }
        ) }) }) })
      ]
    }
  );
};
const Footer = () => {
  const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
  const location2 = useLocation();
  const isHomePage = location2.pathname === "/" || location2.pathname === "/en";
  const { t: t2, language } = useLanguage();
  const getLanguagePrefix = () => {
    return location2.pathname.startsWith("/en") ? "/en" : "";
  };
  const handleSectionScroll = (e2, sectionId) => {
    e2.preventDefault();
    if (!isHomePage) {
      const prefix = getLanguagePrefix();
      window.location.href = `${prefix}/#${sectionId}`;
      return;
    }
    const section = document.getElementById(sectionId);
    if (section) {
      section.scrollIntoView({ behavior: "smooth" });
    }
  };
  const handlePricingClick = (e2) => {
    e2.preventDefault();
    if (!isHomePage) {
      const prefix = getLanguagePrefix();
      window.location.href = `${prefix}/#pricing`;
      return;
    }
    const pricingSection = document.getElementById("pricing");
    if (pricingSection) {
      pricingSection.scrollIntoView({ behavior: "smooth" });
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("footer", { className: "bg-gray-900 text-white mt-16", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-4 py-12 sm:px-6 lg:px-8", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-3 gap-8", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "md:col-span-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: getLanguagePrefix() || "/", className: "flex items-center mb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "/logo.png", alt: "MylineArts Logo", className: "h-8 w-auto" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-400 mb-4", children: language === "pt-BR" ? "Transforme suas fotos em lindas páginas para colorir com tecnologia de IA" : "Transform your photos into beautiful coloring pages with AI technology" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex space-x-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "a",
            {
              href: "https://www.instagram.com/my.line.arts/",
              target: "_blank",
              rel: "noopener noreferrer",
              className: "text-gray-400 hover:text-white transition-colors",
              "aria-label": "Instagram",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Instagram, { className: "h-5 w-5" })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "a",
            {
              href: "https://www.facebook.com/mylinearts",
              target: "_blank",
              rel: "noopener noreferrer",
              className: "text-gray-400 hover:text-white transition-colors",
              "aria-label": "Facebook",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Facebook, { className: "h-5 w-5" })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "a",
            {
              href: "https://www.linkedin.com/company/my-line-arts/",
              target: "_blank",
              rel: "noopener noreferrer",
              className: "text-gray-400 hover:text-white transition-colors",
              "aria-label": "LinkedIn",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Linkedin, { className: "h-5 w-5" })
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "md:col-span-2 grid grid-cols-1 sm:grid-cols-2 gap-8", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold mb-4", children: t2("footer.product") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "space-y-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "a",
              {
                href: "#how-it-works",
                onClick: (e2) => handleSectionScroll(e2, "how-it-works"),
                className: "text-gray-400 hover:text-white",
                children: t2("nav.howItWorks")
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "a",
              {
                href: "#benefits",
                onClick: (e2) => handleSectionScroll(e2, "benefits"),
                className: "text-gray-400 hover:text-white",
                children: t2("nav.benefits")
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "a",
              {
                href: "#about-us",
                onClick: (e2) => handleSectionScroll(e2, "about-us"),
                className: "text-gray-400 hover:text-white",
                children: language === "pt-BR" ? "Sobre nós" : "About us"
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "a",
              {
                href: "#pricing",
                onClick: handlePricingClick,
                className: "text-gray-400 hover:text-white",
                children: t2("nav.pricing")
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "a",
              {
                href: "#faq",
                onClick: (e2) => handleSectionScroll(e2, "faq"),
                className: "text-gray-400 hover:text-white",
                children: t2("nav.faq")
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Link,
              {
                to: `${getLanguagePrefix()}/blog`,
                className: "text-gray-400 hover:text-white",
                children: language === "pt-BR" ? "Blog" : "Blog"
              }
            ) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold mb-4", children: t2("footer.legal") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "space-y-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Link,
              {
                to: `${getLanguagePrefix()}${language === "pt-BR" ? "/politica-de-privacidade" : "/privacy-policy"}`,
                className: "text-gray-400 hover:text-white",
                children: t2("footer.privacyPolicy")
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Link,
              {
                to: `${getLanguagePrefix()}${language === "pt-BR" ? "/termos-de-servico" : "/terms-of-service"}`,
                className: "text-gray-400 hover:text-white",
                children: t2("footer.termsOfService")
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Link,
              {
                to: `${getLanguagePrefix()}${language === "pt-BR" ? "/politica-de-cookies" : "/cookie-policy"}`,
                className: "text-gray-400 hover:text-white",
                children: t2("footer.cookiePolicy")
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Link,
              {
                to: `${getLanguagePrefix()}${language === "pt-BR" ? "/lgpd" : "/gdpr"}`,
                className: "text-gray-400 hover:text-white",
                children: t2("footer.gdpr")
              }
            ) })
          ] })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "border-t border-gray-800 mt-12 pt-8 flex flex-col sm:flex-row justify-between items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-gray-400", children: [
        "© ",
        currentYear,
        " mylinearts. ",
        t2("footer.rights")
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-gray-400 mt-4 sm:mt-0 flex items-center", children: [
        t2("footer.madeWith"),
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx(Heart, { className: "h-4 w-4 text-accent-500 mx-1" }),
        " ",
        t2("footer.colorful")
      ] })
    ] })
  ] }) });
};
var reactFastCompare;
var hasRequiredReactFastCompare;
function requireReactFastCompare() {
  if (hasRequiredReactFastCompare) return reactFastCompare;
  hasRequiredReactFastCompare = 1;
  var hasElementType = typeof Element !== "undefined";
  var hasMap = typeof Map === "function";
  var hasSet = typeof Set === "function";
  var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
  function equal(a2, b2) {
    if (a2 === b2) return true;
    if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
      if (a2.constructor !== b2.constructor) return false;
      var length, i2, keys;
      if (Array.isArray(a2)) {
        length = a2.length;
        if (length != b2.length) return false;
        for (i2 = length; i2-- !== 0; )
          if (!equal(a2[i2], b2[i2])) return false;
        return true;
      }
      var it2;
      if (hasMap && a2 instanceof Map && b2 instanceof Map) {
        if (a2.size !== b2.size) return false;
        it2 = a2.entries();
        while (!(i2 = it2.next()).done)
          if (!b2.has(i2.value[0])) return false;
        it2 = a2.entries();
        while (!(i2 = it2.next()).done)
          if (!equal(i2.value[1], b2.get(i2.value[0]))) return false;
        return true;
      }
      if (hasSet && a2 instanceof Set && b2 instanceof Set) {
        if (a2.size !== b2.size) return false;
        it2 = a2.entries();
        while (!(i2 = it2.next()).done)
          if (!b2.has(i2.value[0])) return false;
        return true;
      }
      if (hasArrayBuffer && ArrayBuffer.isView(a2) && ArrayBuffer.isView(b2)) {
        length = a2.length;
        if (length != b2.length) return false;
        for (i2 = length; i2-- !== 0; )
          if (a2[i2] !== b2[i2]) return false;
        return true;
      }
      if (a2.constructor === RegExp) return a2.source === b2.source && a2.flags === b2.flags;
      if (a2.valueOf !== Object.prototype.valueOf && typeof a2.valueOf === "function" && typeof b2.valueOf === "function") return a2.valueOf() === b2.valueOf();
      if (a2.toString !== Object.prototype.toString && typeof a2.toString === "function" && typeof b2.toString === "function") return a2.toString() === b2.toString();
      keys = Object.keys(a2);
      length = keys.length;
      if (length !== Object.keys(b2).length) return false;
      for (i2 = length; i2-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b2, keys[i2])) return false;
      if (hasElementType && a2 instanceof Element) return false;
      for (i2 = length; i2-- !== 0; ) {
        if ((keys[i2] === "_owner" || keys[i2] === "__v" || keys[i2] === "__o") && a2.$$typeof) {
          continue;
        }
        if (!equal(a2[keys[i2]], b2[keys[i2]])) return false;
      }
      return true;
    }
    return a2 !== a2 && b2 !== b2;
  }
  reactFastCompare = function isEqual(a2, b2) {
    try {
      return equal(a2, b2);
    } catch (error) {
      if ((error.message || "").match(/stack|recursion/i)) {
        console.warn("react-fast-compare cannot handle circular refs");
        return false;
      }
      throw error;
    }
  };
  return reactFastCompare;
}
var reactFastCompareExports = requireReactFastCompare();
const fastCompare = /* @__PURE__ */ getDefaultExportFromCjs(reactFastCompareExports);
var invariant_1;
var hasRequiredInvariant;
function requireInvariant() {
  if (hasRequiredInvariant) return invariant_1;
  hasRequiredInvariant = 1;
  var invariant2 = function(condition, format2, a2, b2, c2, d2, e2, f2) {
    if (!condition) {
      var error;
      if (format2 === void 0) {
        error = new Error(
          "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
        );
      } else {
        var args = [a2, b2, c2, d2, e2, f2];
        var argIndex = 0;
        error = new Error(
          format2.replace(/%s/g, function() {
            return args[argIndex++];
          })
        );
        error.name = "Invariant Violation";
      }
      error.framesToPop = 1;
      throw error;
    }
  };
  invariant_1 = invariant2;
  return invariant_1;
}
var invariantExports = requireInvariant();
const invariant$1 = /* @__PURE__ */ getDefaultExportFromCjs(invariantExports);
var shallowequal;
var hasRequiredShallowequal;
function requireShallowequal() {
  if (hasRequiredShallowequal) return shallowequal;
  hasRequiredShallowequal = 1;
  shallowequal = function shallowEqual2(objA, objB, compare, compareContext) {
    var ret = compare ? compare.call(compareContext, objA, objB) : void 0;
    if (ret !== void 0) {
      return !!ret;
    }
    if (objA === objB) {
      return true;
    }
    if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
      return false;
    }
    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) {
      return false;
    }
    var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
    for (var idx = 0; idx < keysA.length; idx++) {
      var key = keysA[idx];
      if (!bHasOwnProperty(key)) {
        return false;
      }
      var valueA = objA[key];
      var valueB = objB[key];
      ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;
      if (ret === false || ret === void 0 && valueA !== valueB) {
        return false;
      }
    }
    return true;
  };
  return shallowequal;
}
var shallowequalExports = requireShallowequal();
const shallowEqual = /* @__PURE__ */ getDefaultExportFromCjs(shallowequalExports);
var TAG_NAMES = /* @__PURE__ */ ((TAG_NAMES2) => {
  TAG_NAMES2["BASE"] = "base";
  TAG_NAMES2["BODY"] = "body";
  TAG_NAMES2["HEAD"] = "head";
  TAG_NAMES2["HTML"] = "html";
  TAG_NAMES2["LINK"] = "link";
  TAG_NAMES2["META"] = "meta";
  TAG_NAMES2["NOSCRIPT"] = "noscript";
  TAG_NAMES2["SCRIPT"] = "script";
  TAG_NAMES2["STYLE"] = "style";
  TAG_NAMES2["TITLE"] = "title";
  TAG_NAMES2["FRAGMENT"] = "Symbol(react.fragment)";
  return TAG_NAMES2;
})(TAG_NAMES || {});
var SEO_PRIORITY_TAGS = {
  link: { rel: ["amphtml", "canonical", "alternate"] },
  script: { type: ["application/ld+json"] },
  meta: {
    charset: "",
    name: ["generator", "robots", "description"],
    property: [
      "og:type",
      "og:title",
      "og:url",
      "og:image",
      "og:image:alt",
      "og:description",
      "twitter:url",
      "twitter:title",
      "twitter:description",
      "twitter:image",
      "twitter:image:alt",
      "twitter:card",
      "twitter:site"
    ]
  }
};
var VALID_TAG_NAMES = Object.values(TAG_NAMES);
var REACT_TAG_MAP = {
  accesskey: "accessKey",
  charset: "charSet",
  class: "className",
  contenteditable: "contentEditable",
  contextmenu: "contextMenu",
  "http-equiv": "httpEquiv",
  itemprop: "itemProp",
  tabindex: "tabIndex"
};
var HTML_TAG_MAP = Object.entries(REACT_TAG_MAP).reduce(
  (carry, [key, value]) => {
    carry[value] = key;
    return carry;
  },
  {}
);
var HELMET_ATTRIBUTE = "data-rh";
var HELMET_PROPS = {
  DEFAULT_TITLE: "defaultTitle",
  DEFER: "defer",
  ENCODE_SPECIAL_CHARACTERS: "encodeSpecialCharacters",
  ON_CHANGE_CLIENT_STATE: "onChangeClientState",
  TITLE_TEMPLATE: "titleTemplate",
  PRIORITIZE_SEO_TAGS: "prioritizeSeoTags"
};
var getInnermostProperty = (propsList, property) => {
  for (let i2 = propsList.length - 1; i2 >= 0; i2 -= 1) {
    const props = propsList[i2];
    if (Object.prototype.hasOwnProperty.call(props, property)) {
      return props[property];
    }
  }
  return null;
};
var getTitleFromPropsList = (propsList) => {
  let innermostTitle = getInnermostProperty(
    propsList,
    "title"
    /* TITLE */
  );
  const innermostTemplate = getInnermostProperty(propsList, HELMET_PROPS.TITLE_TEMPLATE);
  if (Array.isArray(innermostTitle)) {
    innermostTitle = innermostTitle.join("");
  }
  if (innermostTemplate && innermostTitle) {
    return innermostTemplate.replace(/%s/g, () => innermostTitle);
  }
  const innermostDefaultTitle = getInnermostProperty(propsList, HELMET_PROPS.DEFAULT_TITLE);
  return innermostTitle || innermostDefaultTitle || void 0;
};
var getOnChangeClientState = (propsList) => getInnermostProperty(propsList, HELMET_PROPS.ON_CHANGE_CLIENT_STATE) || (() => {
});
var getAttributesFromPropsList = (tagType, propsList) => propsList.filter((props) => typeof props[tagType] !== "undefined").map((props) => props[tagType]).reduce((tagAttrs, current) => ({ ...tagAttrs, ...current }), {});
var getBaseTagFromPropsList = (primaryAttributes, propsList) => propsList.filter((props) => typeof props[
  "base"
  /* BASE */
] !== "undefined").map((props) => props[
  "base"
  /* BASE */
]).reverse().reduce((innermostBaseTag, tag) => {
  if (!innermostBaseTag.length) {
    const keys = Object.keys(tag);
    for (let i2 = 0; i2 < keys.length; i2 += 1) {
      const attributeKey = keys[i2];
      const lowerCaseAttributeKey = attributeKey.toLowerCase();
      if (primaryAttributes.indexOf(lowerCaseAttributeKey) !== -1 && tag[lowerCaseAttributeKey]) {
        return innermostBaseTag.concat(tag);
      }
    }
  }
  return innermostBaseTag;
}, []);
var warn = (msg) => console && typeof console.warn === "function" && console.warn(msg);
var getTagsFromPropsList = (tagName, primaryAttributes, propsList) => {
  const approvedSeenTags = {};
  return propsList.filter((props) => {
    if (Array.isArray(props[tagName])) {
      return true;
    }
    if (typeof props[tagName] !== "undefined") {
      warn(
        `Helmet: ${tagName} should be of type "Array". Instead found type "${typeof props[tagName]}"`
      );
    }
    return false;
  }).map((props) => props[tagName]).reverse().reduce((approvedTags, instanceTags) => {
    const instanceSeenTags = {};
    instanceTags.filter((tag) => {
      let primaryAttributeKey;
      const keys2 = Object.keys(tag);
      for (let i2 = 0; i2 < keys2.length; i2 += 1) {
        const attributeKey = keys2[i2];
        const lowerCaseAttributeKey = attributeKey.toLowerCase();
        if (primaryAttributes.indexOf(lowerCaseAttributeKey) !== -1 && !(primaryAttributeKey === "rel" && tag[primaryAttributeKey].toLowerCase() === "canonical") && !(lowerCaseAttributeKey === "rel" && tag[lowerCaseAttributeKey].toLowerCase() === "stylesheet")) {
          primaryAttributeKey = lowerCaseAttributeKey;
        }
        if (primaryAttributes.indexOf(attributeKey) !== -1 && (attributeKey === "innerHTML" || attributeKey === "cssText" || attributeKey === "itemprop")) {
          primaryAttributeKey = attributeKey;
        }
      }
      if (!primaryAttributeKey || !tag[primaryAttributeKey]) {
        return false;
      }
      const value = tag[primaryAttributeKey].toLowerCase();
      if (!approvedSeenTags[primaryAttributeKey]) {
        approvedSeenTags[primaryAttributeKey] = {};
      }
      if (!instanceSeenTags[primaryAttributeKey]) {
        instanceSeenTags[primaryAttributeKey] = {};
      }
      if (!approvedSeenTags[primaryAttributeKey][value]) {
        instanceSeenTags[primaryAttributeKey][value] = true;
        return true;
      }
      return false;
    }).reverse().forEach((tag) => approvedTags.push(tag));
    const keys = Object.keys(instanceSeenTags);
    for (let i2 = 0; i2 < keys.length; i2 += 1) {
      const attributeKey = keys[i2];
      const tagUnion = {
        ...approvedSeenTags[attributeKey],
        ...instanceSeenTags[attributeKey]
      };
      approvedSeenTags[attributeKey] = tagUnion;
    }
    return approvedTags;
  }, []).reverse();
};
var getAnyTrueFromPropsList = (propsList, checkedTag) => {
  if (Array.isArray(propsList) && propsList.length) {
    for (let index = 0; index < propsList.length; index += 1) {
      const prop = propsList[index];
      if (prop[checkedTag]) {
        return true;
      }
    }
  }
  return false;
};
var reducePropsToState = (propsList) => ({
  baseTag: getBaseTagFromPropsList([
    "href"
    /* HREF */
  ], propsList),
  bodyAttributes: getAttributesFromPropsList("bodyAttributes", propsList),
  defer: getInnermostProperty(propsList, HELMET_PROPS.DEFER),
  encode: getInnermostProperty(propsList, HELMET_PROPS.ENCODE_SPECIAL_CHARACTERS),
  htmlAttributes: getAttributesFromPropsList("htmlAttributes", propsList),
  linkTags: getTagsFromPropsList(
    "link",
    [
      "rel",
      "href"
      /* HREF */
    ],
    propsList
  ),
  metaTags: getTagsFromPropsList(
    "meta",
    [
      "name",
      "charset",
      "http-equiv",
      "property",
      "itemprop"
      /* ITEM_PROP */
    ],
    propsList
  ),
  noscriptTags: getTagsFromPropsList("noscript", [
    "innerHTML"
    /* INNER_HTML */
  ], propsList),
  onChangeClientState: getOnChangeClientState(propsList),
  scriptTags: getTagsFromPropsList(
    "script",
    [
      "src",
      "innerHTML"
      /* INNER_HTML */
    ],
    propsList
  ),
  styleTags: getTagsFromPropsList("style", [
    "cssText"
    /* CSS_TEXT */
  ], propsList),
  title: getTitleFromPropsList(propsList),
  titleAttributes: getAttributesFromPropsList("titleAttributes", propsList),
  prioritizeSeoTags: getAnyTrueFromPropsList(propsList, HELMET_PROPS.PRIORITIZE_SEO_TAGS)
});
var flattenArray = (possibleArray) => Array.isArray(possibleArray) ? possibleArray.join("") : possibleArray;
var checkIfPropsMatch = (props, toMatch) => {
  const keys = Object.keys(props);
  for (let i2 = 0; i2 < keys.length; i2 += 1) {
    if (toMatch[keys[i2]] && toMatch[keys[i2]].includes(props[keys[i2]])) {
      return true;
    }
  }
  return false;
};
var prioritizer = (elementsList, propsToMatch) => {
  if (Array.isArray(elementsList)) {
    return elementsList.reduce(
      (acc, elementAttrs) => {
        if (checkIfPropsMatch(elementAttrs, propsToMatch)) {
          acc.priority.push(elementAttrs);
        } else {
          acc.default.push(elementAttrs);
        }
        return acc;
      },
      { priority: [], default: [] }
    );
  }
  return { default: elementsList, priority: [] };
};
var without = (obj, key) => {
  return {
    ...obj,
    [key]: void 0
  };
};
var SELF_CLOSING_TAGS = [
  "noscript",
  "script",
  "style"
  /* STYLE */
];
var encodeSpecialCharacters = (str, encode = true) => {
  if (encode === false) {
    return String(str);
  }
  return String(str).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
};
var generateElementAttributesAsString = (attributes) => Object.keys(attributes).reduce((str, key) => {
  const attr = typeof attributes[key] !== "undefined" ? `${key}="${attributes[key]}"` : `${key}`;
  return str ? `${str} ${attr}` : attr;
}, "");
var generateTitleAsString = (type2, title, attributes, encode) => {
  const attributeString = generateElementAttributesAsString(attributes);
  const flattenedTitle = flattenArray(title);
  return attributeString ? `<${type2} ${HELMET_ATTRIBUTE}="true" ${attributeString}>${encodeSpecialCharacters(
    flattenedTitle,
    encode
  )}</${type2}>` : `<${type2} ${HELMET_ATTRIBUTE}="true">${encodeSpecialCharacters(
    flattenedTitle,
    encode
  )}</${type2}>`;
};
var generateTagsAsString = (type2, tags, encode = true) => tags.reduce((str, t2) => {
  const tag = t2;
  const attributeHtml = Object.keys(tag).filter(
    (attribute) => !(attribute === "innerHTML" || attribute === "cssText")
  ).reduce((string, attribute) => {
    const attr = typeof tag[attribute] === "undefined" ? attribute : `${attribute}="${encodeSpecialCharacters(tag[attribute], encode)}"`;
    return string ? `${string} ${attr}` : attr;
  }, "");
  const tagContent = tag.innerHTML || tag.cssText || "";
  const isSelfClosing = SELF_CLOSING_TAGS.indexOf(type2) === -1;
  return `${str}<${type2} ${HELMET_ATTRIBUTE}="true" ${attributeHtml}${isSelfClosing ? `/>` : `>${tagContent}</${type2}>`}`;
}, "");
var convertElementAttributesToReactProps = (attributes, initProps = {}) => Object.keys(attributes).reduce((obj, key) => {
  const mapped = REACT_TAG_MAP[key];
  obj[mapped || key] = attributes[key];
  return obj;
}, initProps);
var generateTitleAsReactComponent = (_type, title, attributes) => {
  const initProps = {
    key: title,
    [HELMET_ATTRIBUTE]: true
  };
  const props = convertElementAttributesToReactProps(attributes, initProps);
  return [React3.createElement("title", props, title)];
};
var generateTagsAsReactComponent = (type2, tags) => tags.map((tag, i2) => {
  const mappedTag = {
    key: i2,
    [HELMET_ATTRIBUTE]: true
  };
  Object.keys(tag).forEach((attribute) => {
    const mapped = REACT_TAG_MAP[attribute];
    const mappedAttribute = mapped || attribute;
    if (mappedAttribute === "innerHTML" || mappedAttribute === "cssText") {
      const content = tag.innerHTML || tag.cssText;
      mappedTag.dangerouslySetInnerHTML = { __html: content };
    } else {
      mappedTag[mappedAttribute] = tag[attribute];
    }
  });
  return React3.createElement(type2, mappedTag);
});
var getMethodsForTag = (type2, tags, encode = true) => {
  switch (type2) {
    case "title":
      return {
        toComponent: () => generateTitleAsReactComponent(type2, tags.title, tags.titleAttributes),
        toString: () => generateTitleAsString(type2, tags.title, tags.titleAttributes, encode)
      };
    case "bodyAttributes":
    case "htmlAttributes":
      return {
        toComponent: () => convertElementAttributesToReactProps(tags),
        toString: () => generateElementAttributesAsString(tags)
      };
    default:
      return {
        toComponent: () => generateTagsAsReactComponent(type2, tags),
        toString: () => generateTagsAsString(type2, tags, encode)
      };
  }
};
var getPriorityMethods = ({ metaTags, linkTags, scriptTags, encode }) => {
  const meta = prioritizer(metaTags, SEO_PRIORITY_TAGS.meta);
  const link = prioritizer(linkTags, SEO_PRIORITY_TAGS.link);
  const script = prioritizer(scriptTags, SEO_PRIORITY_TAGS.script);
  const priorityMethods = {
    toComponent: () => [
      ...generateTagsAsReactComponent("meta", meta.priority),
      ...generateTagsAsReactComponent("link", link.priority),
      ...generateTagsAsReactComponent("script", script.priority)
    ],
    toString: () => (
      // generate all the tags as strings and concatenate them
      `${getMethodsForTag("meta", meta.priority, encode)} ${getMethodsForTag(
        "link",
        link.priority,
        encode
      )} ${getMethodsForTag("script", script.priority, encode)}`
    )
  };
  return {
    priorityMethods,
    metaTags: meta.default,
    linkTags: link.default,
    scriptTags: script.default
  };
};
var mapStateOnServer = (props) => {
  const {
    baseTag,
    bodyAttributes,
    encode = true,
    htmlAttributes,
    noscriptTags,
    styleTags,
    title = "",
    titleAttributes,
    prioritizeSeoTags
  } = props;
  let { linkTags, metaTags, scriptTags } = props;
  let priorityMethods = {
    toComponent: () => {
    },
    toString: () => ""
  };
  if (prioritizeSeoTags) {
    ({ priorityMethods, linkTags, metaTags, scriptTags } = getPriorityMethods(props));
  }
  return {
    priority: priorityMethods,
    base: getMethodsForTag("base", baseTag, encode),
    bodyAttributes: getMethodsForTag("bodyAttributes", bodyAttributes, encode),
    htmlAttributes: getMethodsForTag("htmlAttributes", htmlAttributes, encode),
    link: getMethodsForTag("link", linkTags, encode),
    meta: getMethodsForTag("meta", metaTags, encode),
    noscript: getMethodsForTag("noscript", noscriptTags, encode),
    script: getMethodsForTag("script", scriptTags, encode),
    style: getMethodsForTag("style", styleTags, encode),
    title: getMethodsForTag("title", { title, titleAttributes }, encode)
  };
};
var server_default = mapStateOnServer;
var instances = [];
var isDocument = !!(typeof window !== "undefined" && window.document && window.document.createElement);
var HelmetData = class {
  instances = [];
  canUseDOM = isDocument;
  context;
  value = {
    setHelmet: (serverState) => {
      this.context.helmet = serverState;
    },
    helmetInstances: {
      get: () => this.canUseDOM ? instances : this.instances,
      add: (instance) => {
        (this.canUseDOM ? instances : this.instances).push(instance);
      },
      remove: (instance) => {
        const index = (this.canUseDOM ? instances : this.instances).indexOf(instance);
        (this.canUseDOM ? instances : this.instances).splice(index, 1);
      }
    }
  };
  constructor(context, canUseDOM) {
    this.context = context;
    this.canUseDOM = canUseDOM || false;
    if (!canUseDOM) {
      context.helmet = server_default({
        baseTag: [],
        bodyAttributes: {},
        htmlAttributes: {},
        linkTags: [],
        metaTags: [],
        noscriptTags: [],
        scriptTags: [],
        styleTags: [],
        title: "",
        titleAttributes: {}
      });
    }
  }
};
var defaultValue = {};
var Context = React3.createContext(defaultValue);
var HelmetProvider = class _HelmetProvider extends reactExports.Component {
  static canUseDOM = isDocument;
  helmetData;
  constructor(props) {
    super(props);
    this.helmetData = new HelmetData(this.props.context || {}, _HelmetProvider.canUseDOM);
  }
  render() {
    return /* @__PURE__ */ React3.createElement(Context.Provider, { value: this.helmetData.value }, this.props.children);
  }
};
var updateTags = (type2, tags) => {
  const headElement = document.head || document.querySelector(
    "head"
    /* HEAD */
  );
  const tagNodes = headElement.querySelectorAll(`${type2}[${HELMET_ATTRIBUTE}]`);
  const oldTags = [].slice.call(tagNodes);
  const newTags = [];
  let indexToDelete;
  if (tags && tags.length) {
    tags.forEach((tag) => {
      const newElement = document.createElement(type2);
      for (const attribute in tag) {
        if (Object.prototype.hasOwnProperty.call(tag, attribute)) {
          if (attribute === "innerHTML") {
            newElement.innerHTML = tag.innerHTML;
          } else if (attribute === "cssText") {
            if (newElement.styleSheet) {
              newElement.styleSheet.cssText = tag.cssText;
            } else {
              newElement.appendChild(document.createTextNode(tag.cssText));
            }
          } else {
            const attr = attribute;
            const value = typeof tag[attr] === "undefined" ? "" : tag[attr];
            newElement.setAttribute(attribute, value);
          }
        }
      }
      newElement.setAttribute(HELMET_ATTRIBUTE, "true");
      if (oldTags.some((existingTag, index) => {
        indexToDelete = index;
        return newElement.isEqualNode(existingTag);
      })) {
        oldTags.splice(indexToDelete, 1);
      } else {
        newTags.push(newElement);
      }
    });
  }
  oldTags.forEach((tag) => tag.parentNode?.removeChild(tag));
  newTags.forEach((tag) => headElement.appendChild(tag));
  return {
    oldTags,
    newTags
  };
};
var updateAttributes = (tagName, attributes) => {
  const elementTag = document.getElementsByTagName(tagName)[0];
  if (!elementTag) {
    return;
  }
  const helmetAttributeString = elementTag.getAttribute(HELMET_ATTRIBUTE);
  const helmetAttributes = helmetAttributeString ? helmetAttributeString.split(",") : [];
  const attributesToRemove = [...helmetAttributes];
  const attributeKeys = Object.keys(attributes);
  for (const attribute of attributeKeys) {
    const value = attributes[attribute] || "";
    if (elementTag.getAttribute(attribute) !== value) {
      elementTag.setAttribute(attribute, value);
    }
    if (helmetAttributes.indexOf(attribute) === -1) {
      helmetAttributes.push(attribute);
    }
    const indexToSave = attributesToRemove.indexOf(attribute);
    if (indexToSave !== -1) {
      attributesToRemove.splice(indexToSave, 1);
    }
  }
  for (let i2 = attributesToRemove.length - 1; i2 >= 0; i2 -= 1) {
    elementTag.removeAttribute(attributesToRemove[i2]);
  }
  if (helmetAttributes.length === attributesToRemove.length) {
    elementTag.removeAttribute(HELMET_ATTRIBUTE);
  } else if (elementTag.getAttribute(HELMET_ATTRIBUTE) !== attributeKeys.join(",")) {
    elementTag.setAttribute(HELMET_ATTRIBUTE, attributeKeys.join(","));
  }
};
var updateTitle = (title, attributes) => {
  if (typeof title !== "undefined" && document.title !== title) {
    document.title = flattenArray(title);
  }
  updateAttributes("title", attributes);
};
var commitTagChanges = (newState, cb) => {
  const {
    baseTag,
    bodyAttributes,
    htmlAttributes,
    linkTags,
    metaTags,
    noscriptTags,
    onChangeClientState,
    scriptTags,
    styleTags,
    title,
    titleAttributes
  } = newState;
  updateAttributes("body", bodyAttributes);
  updateAttributes("html", htmlAttributes);
  updateTitle(title, titleAttributes);
  const tagUpdates = {
    baseTag: updateTags("base", baseTag),
    linkTags: updateTags("link", linkTags),
    metaTags: updateTags("meta", metaTags),
    noscriptTags: updateTags("noscript", noscriptTags),
    scriptTags: updateTags("script", scriptTags),
    styleTags: updateTags("style", styleTags)
  };
  const addedTags = {};
  const removedTags = {};
  Object.keys(tagUpdates).forEach((tagType) => {
    const { newTags, oldTags } = tagUpdates[tagType];
    if (newTags.length) {
      addedTags[tagType] = newTags;
    }
    if (oldTags.length) {
      removedTags[tagType] = tagUpdates[tagType].oldTags;
    }
  });
  if (cb) {
    cb();
  }
  onChangeClientState(newState, addedTags, removedTags);
};
var _helmetCallback = null;
var handleStateChangeOnClient = (newState) => {
  if (_helmetCallback) {
    cancelAnimationFrame(_helmetCallback);
  }
  if (newState.defer) {
    _helmetCallback = requestAnimationFrame(() => {
      commitTagChanges(newState, () => {
        _helmetCallback = null;
      });
    });
  } else {
    commitTagChanges(newState);
    _helmetCallback = null;
  }
};
var client_default = handleStateChangeOnClient;
var HelmetDispatcher = class extends reactExports.Component {
  rendered = false;
  shouldComponentUpdate(nextProps) {
    return !shallowEqual(nextProps, this.props);
  }
  componentDidUpdate() {
    this.emitChange();
  }
  componentWillUnmount() {
    const { helmetInstances } = this.props.context;
    helmetInstances.remove(this);
    this.emitChange();
  }
  emitChange() {
    const { helmetInstances, setHelmet } = this.props.context;
    let serverState = null;
    const state = reducePropsToState(
      helmetInstances.get().map((instance) => {
        const props = { ...instance.props };
        delete props.context;
        return props;
      })
    );
    if (HelmetProvider.canUseDOM) {
      client_default(state);
    } else if (server_default) {
      serverState = server_default(state);
    }
    setHelmet(serverState);
  }
  // componentWillMount will be deprecated
  // for SSR, initialize on first render
  // constructor is also unsafe in StrictMode
  init() {
    if (this.rendered) {
      return;
    }
    this.rendered = true;
    const { helmetInstances } = this.props.context;
    helmetInstances.add(this);
    this.emitChange();
  }
  render() {
    this.init();
    return null;
  }
};
var Helmet = class extends reactExports.Component {
  static defaultProps = {
    defer: true,
    encodeSpecialCharacters: true,
    prioritizeSeoTags: false
  };
  shouldComponentUpdate(nextProps) {
    return !fastCompare(without(this.props, "helmetData"), without(nextProps, "helmetData"));
  }
  mapNestedChildrenToProps(child, nestedChildren) {
    if (!nestedChildren) {
      return null;
    }
    switch (child.type) {
      case "script":
      case "noscript":
        return {
          innerHTML: nestedChildren
        };
      case "style":
        return {
          cssText: nestedChildren
        };
      default:
        throw new Error(
          `<${child.type} /> elements are self-closing and can not contain children. Refer to our API for more information.`
        );
    }
  }
  flattenArrayTypeChildren(child, arrayTypeChildren, newChildProps, nestedChildren) {
    return {
      ...arrayTypeChildren,
      [child.type]: [
        ...arrayTypeChildren[child.type] || [],
        {
          ...newChildProps,
          ...this.mapNestedChildrenToProps(child, nestedChildren)
        }
      ]
    };
  }
  mapObjectTypeChildren(child, newProps, newChildProps, nestedChildren) {
    switch (child.type) {
      case "title":
        return {
          ...newProps,
          [child.type]: nestedChildren,
          titleAttributes: { ...newChildProps }
        };
      case "body":
        return {
          ...newProps,
          bodyAttributes: { ...newChildProps }
        };
      case "html":
        return {
          ...newProps,
          htmlAttributes: { ...newChildProps }
        };
      default:
        return {
          ...newProps,
          [child.type]: { ...newChildProps }
        };
    }
  }
  mapArrayTypeChildrenToProps(arrayTypeChildren, newProps) {
    let newFlattenedProps = { ...newProps };
    Object.keys(arrayTypeChildren).forEach((arrayChildName) => {
      newFlattenedProps = {
        ...newFlattenedProps,
        [arrayChildName]: arrayTypeChildren[arrayChildName]
      };
    });
    return newFlattenedProps;
  }
  warnOnInvalidChildren(child, nestedChildren) {
    invariant$1(
      VALID_TAG_NAMES.some((name) => child.type === name),
      typeof child.type === "function" ? `You may be attempting to nest <Helmet> components within each other, which is not allowed. Refer to our API for more information.` : `Only elements types ${VALID_TAG_NAMES.join(
        ", "
      )} are allowed. Helmet does not support rendering <${child.type}> elements. Refer to our API for more information.`
    );
    invariant$1(
      !nestedChildren || typeof nestedChildren === "string" || Array.isArray(nestedChildren) && !nestedChildren.some((nestedChild) => typeof nestedChild !== "string"),
      `Helmet expects a string as a child of <${child.type}>. Did you forget to wrap your children in braces? ( <${child.type}>{\`\`}</${child.type}> ) Refer to our API for more information.`
    );
    return true;
  }
  mapChildrenToProps(children, newProps) {
    let arrayTypeChildren = {};
    React3.Children.forEach(children, (child) => {
      if (!child || !child.props) {
        return;
      }
      const { children: nestedChildren, ...childProps } = child.props;
      const newChildProps = Object.keys(childProps).reduce((obj, key) => {
        obj[HTML_TAG_MAP[key] || key] = childProps[key];
        return obj;
      }, {});
      let { type: type2 } = child;
      if (typeof type2 === "symbol") {
        type2 = type2.toString();
      } else {
        this.warnOnInvalidChildren(child, nestedChildren);
      }
      switch (type2) {
        case "Symbol(react.fragment)":
          newProps = this.mapChildrenToProps(nestedChildren, newProps);
          break;
        case "link":
        case "meta":
        case "noscript":
        case "script":
        case "style":
          arrayTypeChildren = this.flattenArrayTypeChildren(
            child,
            arrayTypeChildren,
            newChildProps,
            nestedChildren
          );
          break;
        default:
          newProps = this.mapObjectTypeChildren(child, newProps, newChildProps, nestedChildren);
          break;
      }
    });
    return this.mapArrayTypeChildrenToProps(arrayTypeChildren, newProps);
  }
  render() {
    const { children, ...props } = this.props;
    let newProps = { ...props };
    let { helmetData } = props;
    if (children) {
      newProps = this.mapChildrenToProps(children, newProps);
    }
    if (helmetData && !(helmetData instanceof HelmetData)) {
      const data = helmetData;
      helmetData = new HelmetData(data.context, true);
      delete newProps.helmetData;
    }
    return helmetData ? /* @__PURE__ */ React3.createElement(HelmetDispatcher, { ...newProps, context: helmetData.value }) : /* @__PURE__ */ React3.createElement(Context.Consumer, null, (context) => /* @__PURE__ */ React3.createElement(HelmetDispatcher, { ...newProps, context }));
  }
};
const links = () => [{
  rel: "preconnect",
  href: "https://fonts.googleapis.com"
}, {
  rel: "preconnect",
  href: "https://fonts.gstatic.com",
  crossOrigin: "anonymous"
}, {
  rel: "stylesheet",
  href: "https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap"
}];
function Layout({
  children
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("html", {
    lang: "en",
    children: [/* @__PURE__ */ jsxRuntimeExports.jsxs("head", {
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx("meta", {
        charSet: "utf-8"
      }), /* @__PURE__ */ jsxRuntimeExports.jsx("meta", {
        name: "viewport",
        content: "width=device-width, initial-scale=1"
      }), /* @__PURE__ */ jsxRuntimeExports.jsx(Meta, {}), /* @__PURE__ */ jsxRuntimeExports.jsx(Links, {})]
    }), /* @__PURE__ */ jsxRuntimeExports.jsxs("body", {
      children: [children, /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollRestoration, {}), /* @__PURE__ */ jsxRuntimeExports.jsx(Scripts, {})]
    })]
  });
}
const root = withComponentProps(function App() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(HelmetProvider, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(PostHogProvider, {
      apiKey: "phc_LPqbRjBsBw8uGbzLfIoocPm12AGJqbVBAhMQHyVGirO",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(LanguageProvider, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Header, {}), /* @__PURE__ */ jsxRuntimeExports.jsx(Outlet, {}), /* @__PURE__ */ jsxRuntimeExports.jsx(Footer, {})]
      })
    })
  });
});
const ErrorBoundary = withErrorBoundaryProps(function ErrorBoundary2({
  error
}) {
  let message = "Oops!";
  let details = "An unexpected error occurred.";
  let stack;
  if (isRouteErrorResponse(error)) {
    message = error.status === 404 ? "404" : "Error";
    details = error.status === 404 ? "The requested page could not be found." : error.statusText || details;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("main", {
    className: "pt-16 p-4 container mx-auto",
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h1", {
      children: message
    }), /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
      children: details
    }), stack]
  });
});
const route0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ErrorBoundary,
  Layout,
  default: root,
  links
}, Symbol.toStringTag, { value: "Module" }));
const HowItWorks = () => {
  const { language } = useLanguage();
  const howItWorksData = {
    "pt-BR": {
      title: "Como funciona",
      subtitle: "Crie seu livro de colorir personalizado em apenas alguns passos simples",
      steps: [
        {
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CreditCard, { className: "w-12 h-12 text-primary-500" }),
          title: "Compre seus créditos",
          description: "Compre os créditos necessários para gerar quantas imagens quiser."
        },
        {
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Upload, { className: "w-12 h-12 text-primary-500" }),
          title: "Envie suas fotos",
          description: "Selecione e envie suas fotos favoritas para serem transformadas."
        },
        {
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Eye, { className: "w-12 h-12 text-primary-500" }),
          title: "Visualize suas imagens",
          description: "Veja como suas fotos ficarão como páginas para colorir."
        },
        {
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Printer, { className: "w-12 h-12 text-primary-500" }),
          title: "Pinte e aproveite",
          description: "Com suas imagens prontas, é só imprimir ou pintar digitalmente!"
        }
      ]
    },
    "en": {
      title: "How it works",
      subtitle: "Create your custom coloring book in just a few simple steps",
      steps: [
        {
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CreditCard, { className: "w-12 h-12 text-primary-500" }),
          title: "Purchase credits",
          description: "Purchase the credits needed to generate as many images as you want."
        },
        {
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Upload, { className: "w-12 h-12 text-primary-500" }),
          title: "Upload your photos",
          description: "Select and upload your favorite photos to be transformed."
        },
        {
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Eye, { className: "w-12 h-12 text-primary-500" }),
          title: "Preview images",
          description: "See how your photos will look as coloring pages."
        },
        {
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Printer, { className: "w-12 h-12 text-primary-500" }),
          title: "Color & enjoy",
          description: "With your images ready, just print or paint digitally!"
        }
      ]
    }
  };
  const currentData = howItWorksData[language] || howItWorksData["pt-BR"];
  return /* @__PURE__ */ jsxRuntimeExports.jsx("section", { id: "how-it-works", className: "py-20 bg-gray-50", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-4 sm:px-6 lg:px-8", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center mb-16", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-3xl md:text-4xl font-bold text-gray-900 mb-4", children: currentData.title }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xl text-gray-600 max-w-2xl mx-auto", children: currentData.subtitle })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-8", children: currentData.steps.map((step, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "flex flex-col items-center text-center relative",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-24 h-24 flex items-center justify-center bg-primary-100 rounded-full mb-6", children: step.icon }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold text-gray-800 mb-3", children: step.title }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600", children: step.description }),
          index < currentData.steps.length - 1 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hidden lg:block absolute right-0 top-1/2 transform -translate-y-1/2 -translate-x-1/2", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "w-8 h-8 text-primary-300", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M14 5l7 7m0 0l-7 7m7-7H3" }) }) })
        ]
      },
      index
    )) })
  ] }) });
};
const Benefits = () => {
  const { t: t2 } = useLanguage();
  const benefits = [
    {
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Heart, { className: "w-10 h-10 text-primary-500" }),
      title: t2("benefits.personal.title"),
      description: t2("benefits.personal.description")
    },
    {
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Clock, { className: "w-10 h-10 text-primary-500" }),
      title: t2("benefits.fast.title"),
      description: t2("benefits.fast.description")
    },
    {
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Palette, { className: "w-10 h-10 text-primary-500" }),
      title: t2("benefits.creative.title"),
      description: t2("benefits.creative.description")
    },
    {
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Users, { className: "w-10 h-10 text-primary-500" }),
      title: t2("benefits.family.title"),
      description: t2("benefits.family.description")
    },
    {
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Star, { className: "w-10 h-10 text-primary-500" }),
      title: t2("benefits.gift.title"),
      description: t2("benefits.gift.description")
    },
    {
      icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Award, { className: "w-10 h-10 text-primary-500" }),
      title: t2("benefits.quality.title"),
      description: t2("benefits.quality.description")
    }
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsx("section", { id: "benefits", className: "py-20 bg-white", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-4 sm:px-6 lg:px-8", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center mb-16", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-3xl md:text-4xl font-bold text-gray-900 mb-4", children: "Os benefícios do My Line Arts" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xl text-gray-600 max-w-2xl mx-auto", children: t2("benefits.subtitle") })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8",
        children: benefits.map((benefit, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "bg-gray-50 rounded-xl p-6 shadow-sm hover:shadow-md transition-shadow duration-300",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "shrink-0 p-3 rounded-lg bg-primary-100 mr-4", children: benefit.icon }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold text-gray-800 mb-2", children: benefit.title }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600", children: benefit.description })
              ] })
            ] })
          },
          index
        ))
      }
    )
  ] }) });
};
const AboutUs = () => {
  const { language } = useLanguage();
  const aboutData = {
    "pt-BR": {
      title: "Nossa história",
      subtitle: "Descubra como nasceu a ideia de democratizar a criação de livros de colorir personalizados",
      story: {
        title: "A inspiração por trás do MylineArts",
        content: [
          'Tudo começou quando descobri o fenômeno "Boobie Goods", que está super em alta no momento. Vi uma influenciadora que criou um livro de colorir personalizado para a mãe dela no mesmo estilo, e fiquei impressionada com o resultado.',
          "Percebi que nem todo mundo tem a habilidade artística para criar algo assim, mas todos merecem ter a mesma oportunidade de presentear alguém especial com algo tão único e pessoal.",
          "Foi assim que nasceu o MylineArts: para democratizar essa experiência e permitir que qualquer pessoa possa transformar suas memórias mais preciosas em páginas de colorir personalizadas."
        ]
      },
      mission: {
        title: "Nossa missão",
        description: "Tornar a criação de livros de colorir personalizados acessível para todos, independente de habilidades artísticas.",
        values: [
          {
            icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Heart, { className: "w-6 h-6 text-primary-500" }),
            title: "Conexão emocional",
            description: "Acreditamos no poder das memórias e na importância de preservá-las de forma criativa."
          },
          {
            icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Users, { className: "w-6 h-6 text-secondary-500" }),
            title: "Acessibilidade",
            description: "Queremos que todos tenham acesso a essa experiência, independente de suas habilidades técnicas."
          },
          {
            icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Sparkles, { className: "w-6 h-6 text-accent-500" }),
            title: "Inovação",
            description: "Utilizamos tecnologia de ponta para transformar ideias simples em experiências extraordinárias."
          }
        ]
      },
      cta: {
        title: "Faça parte da nossa história",
        description: "Junte-se a milhares de pessoas que já transformaram suas memórias em arte.",
        button: "Criar meu livro"
      }
    },
    "en": {
      title: "Our story",
      subtitle: "Discover how the idea to democratize personalized coloring book creation was born",
      story: {
        title: "The inspiration behind MylineArts",
        content: [
          'It all started when I discovered the "Boobie Goods" phenomenon, which is super trending right now. I saw an influencer who created a personalized coloring book for her mother in the same style, and I was impressed with the result.',
          "I realized that not everyone has the artistic skills to create something like that, but everyone deserves the same opportunity to give someone special something so unique and personal.",
          "That's how MylineArts was born: to democratize this experience and allow anyone to transform their most precious memories into personalized coloring pages."
        ]
      },
      mission: {
        title: "Our mission",
        description: "Make personalized coloring book creation accessible to everyone, regardless of artistic skills.",
        values: [
          {
            icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Heart, { className: "w-6 h-6 text-primary-500" }),
            title: "Emotional connection",
            description: "We believe in the power of memories and the importance of preserving them creatively."
          },
          {
            icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Users, { className: "w-6 h-6 text-secondary-500" }),
            title: "Accessibility",
            description: "We want everyone to have access to this experience, regardless of their technical skills."
          },
          {
            icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Sparkles, { className: "w-6 h-6 text-accent-500" }),
            title: "Innovation",
            description: "We use cutting-edge technology to transform simple ideas into extraordinary experiences."
          }
        ]
      },
      cta: {
        title: "Be part of our story",
        description: "Join thousands of people who have already transformed their memories into art.",
        button: "Create my book"
      }
    }
  };
  const currentData = aboutData[language] || aboutData["pt-BR"];
  const handleGetStartedClick = () => {
    window.location.href = "https://app.mylinearts.com";
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("section", { id: "about-us", className: "py-20 bg-linear-to-br from-gray-50 to-white", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-4 sm:px-6 lg:px-8", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center mb-16", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-3xl md:text-4xl font-bold text-gray-900 mb-4", children: currentData.title }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xl text-gray-600 max-w-3xl mx-auto", children: currentData.subtitle })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-6xl mx-auto", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-2xl shadow-md p-8 md:p-12 mb-12", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center mb-8", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-3 bg-primary-100 rounded-lg mr-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Lightbulb, { className: "w-8 h-8 text-primary-600" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-2xl md:text-3xl font-bold text-gray-900", children: currentData.story.title })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-6 text-lg text-gray-700 leading-relaxed", children: currentData.story.content.map((paragraph, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          "p",
          {
            children: paragraph
          },
          index
        )) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: "grid grid-cols-1 lg:grid-cols-2 gap-12 items-start",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                className: "bg-white rounded-2xl shadow-md p-8",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-2xl font-bold text-gray-900 mb-4", children: currentData.mission.title }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-lg text-gray-700 leading-relaxed", children: currentData.mission.description })
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "space-y-6",
                children: currentData.mission.values.map((value, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "div",
                  {
                    className: "bg-white rounded-xl shadow-md p-6 flex items-start",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "shrink-0 p-3 bg-gray-50 rounded-lg mr-4", children: value.icon }),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "text-lg font-bold text-gray-900 mb-2", children: value.title }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600", children: value.description })
                      ] })
                    ]
                  },
                  index
                ))
              }
            )
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: "text-center mt-16",
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-linear-to-r from-primary-500 to-secondary-500 rounded-2xl shadow-xl p-8 md:p-12 text-white", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-2xl md:text-3xl font-bold mb-4", children: currentData.cta.title }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xl mb-8 opacity-90", children: currentData.cta.description }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                onClick: handleGetStartedClick,
                className: "bg-white text-primary-600 font-bold py-4 px-8 rounded-full text-lg shadow-lg hover:shadow-xl transition-all duration-300",
                children: currentData.cta.button
              }
            )
          ] })
        }
      )
    ] })
  ] }) });
};
const formatCurrency = (amount, currency) => {
  const currencyLocaleMap = {
    "eur": "de-DE",
    "usd": "en-US",
    "brl": "pt-BR",
    "gbp": "en-GB"
  };
  const locale = currencyLocaleMap[currency] || "de-DE";
  return new Intl.NumberFormat(locale, {
    style: "currency",
    currency: currency.toUpperCase()
  }).format(amount / 100);
};
const getCurrencySymbol = (currency) => {
  const symbols = {
    "eur": "€",
    "usd": "$",
    "brl": "R$",
    "gbp": "£"
  };
  return symbols[currency] || "€";
};
const Pricing = () => {
  const { language } = useLanguage();
  const { plans: plans2, currency } = useLoaderData();
  const pricingData = {
    "pt-BR": {
      title: "Planos simples e transparentes",
      subtitle: "Escolha o plano ideal para transformar suas fotos em páginas para colorir",
      plans: [
        {
          name: "Inicial",
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Image, { className: "w-8 h-8 text-primary-500" }),
          features: [
            "Modelos de IA avançado",
            "Suporte por e-mail",
            "Acesso a todas as imagens geradas"
          ],
          buttonText: "Escolher esse",
          popular: false,
          bgGradient: "from-primary-50 to-primary-100"
        },
        {
          name: "Artista inicial",
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Image, { className: "w-8 h-8 text-primary-500" }),
          features: [
            "Modelos de IA avançado",
            "Suporte por e-mail",
            "Acesso a todas as imagens geradas"
          ],
          buttonText: "Escolher esse",
          popular: false,
          bgGradient: "from-primary-50 to-primary-100"
        },
        {
          name: "Desenhista",
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Star, { className: "w-8 h-8 text-warning-500" }),
          features: [
            "Prioridade na geração de imagens",
            "Suporte rápido",
            "Acesso a todas as imagens geradas"
          ],
          buttonText: "Escolher esse",
          popular: true,
          bgGradient: "from-warning-50 to-warning-100"
        },
        {
          name: "Profissional",
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Crown, { className: "w-8 h-8 text-accent-500" }),
          features: [
            "Prioridade na geração de imagens",
            "Suporte rápido",
            "Acesso a todas as imagens geradas"
          ],
          buttonText: "Escolher esse",
          popular: false,
          bgGradient: "from-accent-50 to-accent-100"
        }
      ],
      howItWorks: {
        title: "💡 Como funciona o sistema de créditos?",
        steps: [
          {
            title: "Compre créditos",
            description: "Escolha o plano que melhor se adapta às suas necessidades"
          },
          {
            title: "Use 1 crédito por imagem",
            description: "Cada foto transformada consome apenas 1 crédito"
          },
          {
            title: "Baixe suas criações",
            description: "Acesso ilimitado a todas as suas imagens geradas"
          }
        ]
      },
      trustIndicators: {
        included: "✅ Todos os planos incluem acesso completo à plataforma",
        details: `💳 Preços em ${getCurrencySymbol(currency)} • 🔒 Pagamento seguro • ❌ Sem taxas ocultas ou assinaturas`
      },
      popularBadge: "⭐ MAIS POPULAR ⭐"
    },
    "en": {
      title: "Simple and transparent plans",
      subtitle: "Choose the ideal plan to transform your photos into coloring pages",
      plans: [
        {
          name: "Starter",
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Image, { className: "w-8 h-8 text-primary-500" }),
          features: [
            "Advanced AI models",
            "Email support",
            "Access to all generated images"
          ],
          buttonText: "Choose this",
          popular: false,
          bgGradient: "from-primary-50 to-primary-100"
        },
        {
          name: "Artist",
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Star, { className: "w-8 h-8 text-warning-500" }),
          features: [
            "Priority image generation",
            "Fast support",
            "Access to all generated images"
          ],
          buttonText: "Choose this",
          popular: true,
          bgGradient: "from-warning-50 to-warning-100"
        },
        {
          name: "Professional",
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Crown, { className: "w-8 h-8 text-accent-500" }),
          features: [
            "Priority image generation",
            "Fast support",
            "Access to all generated images"
          ],
          buttonText: "Choose this",
          popular: false,
          bgGradient: "from-accent-50 to-accent-100"
        }
      ],
      howItWorks: {
        title: "💡 How does the credit system work?",
        steps: [
          {
            title: "Buy credits",
            description: "Choose the plan that best fits your needs"
          },
          {
            title: "Use 1 credit per image",
            description: "Each transformed photo consumes only 1 credit"
          },
          {
            title: "Download your creations",
            description: "Unlimited access to all your generated images"
          }
        ]
      },
      trustIndicators: {
        included: "✅ All plans include full platform access",
        details: `💳 Prices in ${getCurrencySymbol(currency)} • 🔒 Secure payment • ❌ No hidden fees or subscriptions`
      },
      popularBadge: "⭐ MOST POPULAR ⭐"
    }
  };
  const currentData = pricingData[language] || pricingData["en"];
  return /* @__PURE__ */ jsxRuntimeExports.jsx("section", { id: "pricing", className: "py-20 bg-gradient-to-br from-gray-50 to-white", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-4 sm:px-6 lg:px-8", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center mb-16", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-3xl md:text-4xl font-bold text-gray-900 mb-4", children: currentData.title }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xl text-gray-600 max-w-2xl mx-auto", children: currentData.subtitle })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8 max-w-6xl mx-auto",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Await, { resolve: plans2, errorElement: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center text-red-500", children: "Error loading prices" }), children: (data) => data.plans.map((plan, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: `relative bg-white rounded-2xl shadow-xl overflow-hidden transform transition-all duration-300 hover:scale-105 ${plan.popular ? "ring-2 ring-primary-500 scale-105" : ""}`,
            children: [
              plan.popular && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute top-0 left-0 right-0 bg-gradient-to-r from-primary-500 to-primary-600 text-white text-center py-3 text-sm font-bold", children: currentData.popularBadge }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `p-8 ${plan.popular ? "pt-16" : ""}`, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `flex items-center justify-center mb-6`, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `p-4 rounded-full bg-gradient-to-br ${currentData.plans[index]?.bgGradient}`, children: currentData.plans[index]?.icon }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-5xl font-bold text-gray-900 mb-2", children: formatCurrency(plan.price.unitAmount, plan.price.currency) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-gray-500 text-sm mb-1", children: [
                    formatCurrency(plan.price.unitAmount / plan.plan.credits, plan.price.currency),
                    " por crédito"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-primary-600 font-semibold bg-primary-50 px-3 py-1 rounded-full inline-block", children: plan.plan.credits === 1 ? "1 Crédito = 1 Imagem" : `${plan.plan.credits} Créditos = ${plan.plan.credits} Imagens` })
                ] })
              ] })
            ]
          },
          `plan-${plan.name}-${index}`
        )) })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "text-center mt-16",
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-2xl shadow-md p-8 max-w-4xl mx-auto", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold text-gray-900 mb-4", children: currentData.howItWorks.title }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-1 md:grid-cols-3 gap-6 text-left", children: currentData.howItWorks.steps.map((step, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-primary-100 rounded-full p-2 mr-3 mt-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-primary-600 font-bold text-sm", children: index + 1 }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "font-semibold text-gray-800 mb-1", children: step.title }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 text-sm", children: step.description })
            ] })
          ] }, `step-${index}`)) })
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "text-center mt-12",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 mb-2", children: currentData.trustIndicators.included }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-500", children: currentData.trustIndicators.details })
        ]
      }
    )
  ] }) });
};
const SocialMedia = () => {
  const { language } = useLanguage();
  const socialData = {
    "pt-BR": {
      title: "Siga-nos nas redes sociais",
      subtitle: "Acompanhe nossas novidades, dicas de colorir e inspirações criativas",
      followText: "Seguir",
      platforms: [
        {
          name: "Instagram",
          description: "Veja criações incríveis e dicas de colorir",
          url: "https://www.instagram.com/my.line.arts/",
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Instagram, { className: "w-8 h-8" }),
          color: "from-pink-500 to-purple-600",
          bgColor: "bg-linear-to-br from-pink-50 to-purple-50"
        },
        {
          name: "Facebook",
          description: "Participe da nossa comunidade de artistas",
          url: "https://www.facebook.com/mylinearts",
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Facebook, { className: "w-8 h-8" }),
          color: "from-blue-500 to-blue-700",
          bgColor: "bg-linear-to-br from-blue-50 to-blue-100"
        },
        {
          name: "LinkedIn",
          description: "Conecte-se conosco profissionalmente",
          url: "https://www.linkedin.com/company/my-line-arts/",
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Linkedin, { className: "w-8 h-8" }),
          color: "from-blue-600 to-blue-800",
          bgColor: "bg-linear-to-br from-blue-50 to-indigo-50"
        }
      ]
    },
    "en": {
      title: "Follow us on social media",
      subtitle: "Stay updated with our latest news, coloring tips, and creative inspirations",
      followText: "Follow",
      platforms: [
        {
          name: "Instagram",
          description: "See amazing creations and coloring tips",
          url: "https://www.instagram.com/my.line.arts/",
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Instagram, { className: "w-8 h-8" }),
          color: "from-pink-500 to-purple-600",
          bgColor: "bg-linear-to-br from-pink-50 to-purple-50"
        },
        {
          name: "Facebook",
          description: "Join our community of artists",
          url: "https://www.facebook.com/mylinearts",
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Facebook, { className: "w-8 h-8" }),
          color: "from-blue-500 to-blue-700",
          bgColor: "bg-linear-to-br from-blue-50 to-blue-100"
        },
        {
          name: "LinkedIn",
          description: "Connect with us professionally",
          url: "https://www.linkedin.com/company/my-line-arts/",
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Linkedin, { className: "w-8 h-8" }),
          color: "from-blue-600 to-blue-800",
          bgColor: "bg-linear-to-br from-blue-50 to-indigo-50"
        }
      ]
    }
  };
  const currentData = socialData[language] || socialData["pt-BR"];
  return /* @__PURE__ */ jsxRuntimeExports.jsx("section", { id: "social-media", className: "py-20 bg-linear-to-br from-gray-50 to-white", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-4 sm:px-6 lg:px-8", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center mb-16", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-3xl md:text-4xl font-bold text-gray-900 mb-4", children: currentData.title }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xl text-gray-600 max-w-2xl mx-auto", children: currentData.subtitle })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "grid grid-cols-1 md:grid-cols-3 gap-8 max-w-5xl mx-auto",
        children: currentData.platforms.map((platform, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "group",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${platform.bgColor} rounded-2xl p-8 shadow-md hover:shadow-xl transition-all duration-300 transform hover:-translate-y-2 border border-gray-100`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center mb-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `p-4 rounded-full bg-linear-to-r ${platform.color} text-white shadow-lg group-hover:scale-110 transition-transform duration-300`, children: platform.icon }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center mb-6", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-2xl font-bold text-gray-900 mb-3", children: platform.name }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600", children: platform.description })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "a",
                {
                  href: platform.url,
                  target: "_blank",
                  rel: "noopener noreferrer",
                  className: `inline-flex items-center justify-center px-6 py-3 rounded-full bg-linear-to-r ${platform.color} text-white font-semibold shadow-lg hover:shadow-xl transition-all duration-300 group-hover:shadow-2xl`,
                  children: [
                    currentData.followText,
                    /* @__PURE__ */ jsxRuntimeExports.jsx(ExternalLink, { className: "ml-2 h-4 w-4" })
                  ]
                }
              ) })
            ] })
          },
          platform.name
        ))
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "text-center mt-16",
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "bg-white rounded-2xl shadow-md p-8 max-w-2xl mx-auto border border-gray-100", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-xl font-bold text-gray-900 mb-4", children: language === "pt-BR" ? "🎨 Compartilhe suas criações!" : "🎨 Share your creations!" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600 mb-6", children: language === "pt-BR" ? "Marque-nos em suas fotos coloridas e apareça em nossas redes sociais!" : "Tag us in your colored photos and get featured on our social media!" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap justify-center gap-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "inline-flex items-center px-4 py-2 bg-primary-100 text-primary-700 rounded-full text-sm font-medium", children: "#MyLineArts" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "inline-flex items-center px-4 py-2 bg-secondary-100 text-secondary-700 rounded-full text-sm font-medium", children: "#ColoringPages" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "inline-flex items-center px-4 py-2 bg-accent-100 text-accent-700 rounded-full text-sm font-medium", children: "#AIArt" })
          ] })
        ] })
      }
    )
  ] }) });
};
const FAQ = () => {
  const [openIndex, setOpenIndex] = reactExports.useState(null);
  const { language } = useLanguage();
  const toggleFaq = (index) => {
    if (openIndex === index) {
      setOpenIndex(null);
    } else {
      setOpenIndex(index);
    }
  };
  const faqData = {
    "pt-BR": {
      title: "Perguntas frequentes",
      subtitle: "Obtenha respostas para perguntas comuns sobre nosso processo de criação de páginas para colorir",
      questions: [
        {
          id: "1",
          question: "Quanto tempo leva para converter minhas fotos?",
          answer: "Nossa tecnologia de IA geralmente transforma suas fotos em páginas para colorir em 30-60 segundos por imagem, dependendo da complexidade."
        },
        {
          id: "2",
          question: "Que tipo de fotos funcionam melhor?",
          answer: "Fotos com assuntos claros, boa iluminação e fundo com pouca interferência funcionam melhor. No entanto, nossa IA é projetada para lidar com uma grande variedade de imagens."
        },
        {
          id: "3",
          question: "Posso editar as páginas para colorir depois de criadas?",
          answer: "Não, você não pode editar as páginas para colorir após serem geradas. Se não estiver satisfeito com o resultado, será necessário gerar uma nova imagem usando outro crédito."
        },
        {
          id: "4",
          question: "Como recebo meu desenho?",
          answer: "Você poderá fazer o download em PNG de alta resolução, prontos para impressão em casa, gráfica ou até para uso digital (como fundo de tela, por exemplo). Se desejar receber sua arte em casa, entre em contato com o nosso time."
        },
        {
          id: "5",
          question: "Posso presentear alguém com a ilustração?",
          answer: "Sim! Muitas pessoas usam o MyLineArts para presentear mães, avós, casais, amigos ou até crianças. Você pode adicionar uma dedicatória e escolher um formato especial."
        }
      ]
    },
    "en": {
      title: "Frequently asked questions",
      subtitle: "Get answers to common questions about our coloring page creation process",
      questions: [
        {
          id: "1",
          question: "How long does it take to convert my photos?",
          answer: "Our AI technology typically transforms your photos into coloring pages within 30-60 seconds per image, depending on complexity."
        },
        {
          id: "2",
          question: "What type of photos work best?",
          answer: "Photos with clear subjects, good lighting, and minimal background clutter work best. However, our AI is designed to handle a wide variety of images."
        },
        {
          id: "3",
          question: "Can I edit the coloring pages after they're created?",
          answer: "No, you cannot edit the coloring pages after they're generated. If you're not satisfied with the result, you'll need to generate a new image using another credit."
        },
        {
          id: "4",
          question: "How do I receive my drawing?",
          answer: "You can download high-resolution PNG files, ready for printing at home, in print shops or even for digital use (as a desktop background, for example). If you would like to receive your artwork at home, please contact our team."
        },
        {
          id: "5",
          question: "Can I give the illustration as a gift to someone?",
          answer: "Yes! Many people use MyLineArts to give gifts to mothers, grandmothers, couples, friends or even children. You can add a dedication and choose a special format."
        }
      ]
    }
  };
  const currentFaq = faqData[language] || faqData["pt-BR"];
  return /* @__PURE__ */ jsxRuntimeExports.jsx("section", { id: "faq", className: "py-20 bg-white", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-4 sm:px-6 lg:px-8", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center mb-16", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-3xl md:text-4xl font-bold text-gray-900 mb-4", children: currentFaq.title }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-xl text-gray-600 max-w-2xl mx-auto", children: currentFaq.subtitle })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "max-w-3xl mx-auto", children: currentFaq.questions.map((faq, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "mb-4",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              onClick: () => toggleFaq(index),
              className: `flex justify-between items-center w-full p-5 text-left rounded-lg ${openIndex === index ? "bg-primary-100 text-primary-800" : "bg-gray-50 hover:bg-gray-100 text-gray-800"} transition-colors duration-200`,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium text-lg", children: faq.question }),
                openIndex === index ? /* @__PURE__ */ jsxRuntimeExports.jsx(Minus, { className: "h-5 w-5 shrink-0" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { className: "h-5 w-5 shrink-0" })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: openIndex === index && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "overflow-hidden",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-5 bg-gray-50 rounded-b-lg border-t border-gray-100", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-gray-600", children: faq.answer }) })
            }
          ) })
        ]
      },
      faq.id
    )) })
  ] }) });
};
const mockBeforeAfterImages = [
  {
    id: "2",
    title: {
      en: "Pet companion",
      "pt-BR": "Companheiro de estimação"
    },
    before: "/pet-before.jpg",
    after: "/pet-after.webp",
    description: {
      en: "Create a coloring page of your furry friend.",
      "pt-BR": "Crie uma página para colorir do seu amigo peludo."
    }
  },
  {
    id: "3",
    title: {
      en: "Vacation memories",
      "pt-BR": "Memórias de férias"
    },
    before: "/pyramids-before.png",
    after: "/pyramids-after-2.webp",
    description: {
      en: "Relive your favorite travel memories through coloring.",
      "pt-BR": "Reviva suas memórias favoritas de viagem colorindo."
    }
  }
];
var B = reactExports.forwardRef(({ transition: e2, ...t2 }, r2) => {
  let o2 = { position: "absolute", top: 0, left: 0, width: "100%", height: "100%", transition: e2 ? `clip-path ${e2}` : void 0, userSelect: "none", willChange: "clip-path, transition", KhtmlUserSelect: "none", MozUserSelect: "none", WebkitUserSelect: "none" };
  return jsxRuntimeExports.jsx("div", { ...t2, style: o2, "data-rcs": "clip-item", ref: r2 });
});
B.displayName = "ContainerClip";
var W = reactExports.forwardRef(({ children: e2, disabled: t2, portrait: r2, position: o2, transition: i2 }, m2) => {
  let u2 = { position: "absolute", top: 0, width: r2 ? "100%" : void 0, height: r2 ? void 0 : "100%", background: "none", border: 0, padding: 0, pointerEvents: "all", appearance: "none", WebkitAppearance: "none", MozAppearance: "none", outline: 0, transform: r2 ? "translate3d(0, -50% ,0)" : "translate3d(-50%, 0, 0)", transition: i2 ? `${r2 ? "top" : "left"} ${i2}` : void 0 };
  return jsxRuntimeExports.jsx("button", { ref: m2, "aria-label": "Drag to move or focus and use arrow keys", "aria-orientation": r2 ? "vertical" : "horizontal", "aria-valuemin": 0, "aria-valuemax": 100, "aria-valuenow": o2, "data-rcs": "handle-container", disabled: t2, role: "slider", style: u2, children: e2 });
});
W.displayName = "ThisHandleContainer";
var re2 = ({ flip: e2 }) => jsxRuntimeExports.jsx("div", { className: "__rcs-handle-arrow", style: { width: 0, height: 0, borderTop: "8px solid transparent", borderRight: "10px solid", borderBottom: "8px solid transparent", transform: e2 ? "rotate(180deg)" : void 0 } }), F = ({ className: e2 = "__rcs-handle-root", disabled: t2, buttonStyle: r2, linesStyle: o2, portrait: i2, style: m2, ...C2 }) => {
  let u2 = { display: "flex", flexDirection: i2 ? "row" : "column", placeItems: "center", height: "100%", cursor: t2 ? "not-allowed" : i2 ? "ns-resize" : "ew-resize", pointerEvents: "none", color: "#fff", ...m2 }, E2 = { flexGrow: 1, height: i2 ? 2 : "100%", width: i2 ? "100%" : 2, backgroundColor: "currentColor", pointerEvents: "auto", boxShadow: "0 0 4px rgba(0,0,0,.5)", ...o2 }, y2 = { display: "grid", gridAutoFlow: "column", gap: 8, placeContent: "center", flexShrink: 0, width: 56, height: 56, borderRadius: "50%", borderStyle: "solid", borderWidth: 2, pointerEvents: "auto", backdropFilter: "blur(7px)", WebkitBackdropFilter: "blur(7px)", backgroundColor: "rgba(0, 0, 0, 0.125)", boxShadow: "0 0 4px rgba(0,0,0,.35)", transform: i2 ? "rotate(90deg)" : void 0, ...r2 };
  return jsxRuntimeExports.jsxs("div", { ...C2, className: e2, style: u2, children: [jsxRuntimeExports.jsx("div", { className: "__rcs-handle-line", style: E2 }), jsxRuntimeExports.jsxs("div", { className: "__rcs-handle-button", style: y2, children: [jsxRuntimeExports.jsx(re2, {}), jsxRuntimeExports.jsx(re2, { flip: true })] }), jsxRuntimeExports.jsx("div", { className: "__rcs-handle-line", style: E2 })] });
};
var $ = ((i2) => (i2.ARROW_LEFT = "ArrowLeft", i2.ARROW_RIGHT = "ArrowRight", i2.ARROW_UP = "ArrowUp", i2.ARROW_DOWN = "ArrowDown", i2))($ || {}), G = ({ boxSizing: e2 = "border-box", objectFit: t2 = "cover", objectPosition: r2 = "center center", ...o2 } = {}) => ({ display: "block", width: "100%", height: "100%", maxWidth: "100%", boxSizing: e2, objectFit: t2, objectPosition: r2, ...o2 }), oe = (e2) => {
  let t2 = reactExports.useRef(e2);
  return reactExports.useEffect(() => {
    t2.current = e2;
  }), t2.current;
}, U = (e2, t2, r2, o2) => {
  let i2 = reactExports.useRef();
  reactExports.useEffect(() => {
    i2.current = t2;
  }, [t2]), reactExports.useEffect(() => {
    if (!(r2 && r2.addEventListener)) return;
    let m2 = (C2) => i2.current && i2.current(C2);
    return r2.addEventListener(e2, m2, o2), () => {
      r2.removeEventListener(e2, m2, o2);
    };
  }, [e2, r2, o2]);
}, Te = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? reactExports.useLayoutEffect : reactExports.useEffect, ie = (e2, t2) => {
  let r2 = reactExports.useRef(), o2 = reactExports.useCallback(() => {
    e2.current && r2.current && r2.current.observe(e2.current);
  }, [e2]);
  Te(() => (r2.current = new ResizeObserver(([i2]) => t2(i2.contentRect)), o2(), () => {
    r2.current && r2.current.disconnect();
  }), [t2, o2]);
};
var I = { capture: false, passive: true }, X = { capture: true, passive: false }, Me = (e2) => {
  e2.preventDefault(), e2.currentTarget.focus();
}, se = reactExports.forwardRef(({ boundsPadding: e2 = 0, browsingContext: t2 = globalThis, changePositionOnHover: r2 = false, disabled: o2 = false, handle: i2, itemOne: m2, itemTwo: C2, keyboardIncrement: u2 = "5%", onlyHandleDraggable: E2 = false, onPositionChange: y2, portrait: a2 = false, position: g2 = 50, style: le2, transition: ce2, ...pe2 }, de2) => {
  let p2 = reactExports.useRef(null), j2 = reactExports.useRef(null), f2 = reactExports.useRef(null), d2 = reactExports.useRef(g2), [L2, q2] = reactExports.useState(false), [me2, x2] = reactExports.useState(true), w2 = reactExports.useRef(false), [ue2, fe2] = reactExports.useState(), J2 = oe(g2), l2 = reactExports.useCallback(function({ x: s2, y: c2, isOffset: R2 }) {
    let b2 = p2.current, A2 = f2.current, D2 = j2.current, { width: h2, height: S2, left: Pe2, top: Ee2 } = b2.getBoundingClientRect();
    if (h2 === 0 || S2 === 0) return;
    let ye2 = a2 ? R2 ? c2 - Ee2 - t2.scrollY : c2 : R2 ? s2 - Pe2 - t2.scrollX : s2, Q2 = Math.min(Math.max(ye2 / (a2 ? S2 : h2) * 100, 0), 100), z2 = a2 ? S2 / (b2.offsetHeight || 1) : h2 / (b2.offsetWidth || 1), Z2 = e2 * z2 / (a2 ? S2 : h2) * 100, _2 = Math.min(Math.max(Q2, Z2 * z2), 100 - Z2 * z2);
    d2.current = Q2, A2.setAttribute("aria-valuenow", `${Math.round(d2.current)}`), A2.style.top = a2 ? `${_2}%` : "0", A2.style.left = a2 ? "0" : `${_2}%`, D2.style.clipPath = a2 ? `inset(${_2}% 0 0 0)` : `inset(0 0 0 ${_2}%)`, y2 && y2(d2.current);
  }, [e2, y2, a2, t2]);
  reactExports.useEffect(() => {
    let { width: n2, height: s2 } = p2.current.getBoundingClientRect(), c2 = g2 === J2 ? d2.current : g2;
    l2({ x: n2 / 100 * c2, y: s2 / 100 * c2 });
  }, [e2, g2, a2, J2, l2]);
  let Re2 = reactExports.useCallback((n2) => {
    n2.preventDefault(), !(o2 || n2.button !== 0) && (l2({ isOffset: true, x: n2.pageX, y: n2.pageY }), q2(true), x2(true));
  }, [o2, l2]), v2 = reactExports.useCallback(function(s2) {
    l2({ isOffset: true, x: s2.pageX, y: s2.pageY }), x2(false);
  }, [l2]), T2 = reactExports.useCallback(() => {
    q2(false), x2(true);
  }, []), Se2 = reactExports.useCallback(({ width: n2, height: s2 }) => {
    let { width: c2, height: R2 } = p2.current.getBoundingClientRect();
    l2({ x: n2 / 100 * d2.current * c2 / n2, y: s2 / 100 * d2.current * R2 / s2 });
  }, [l2]), Ce2 = reactExports.useCallback((n2) => {
    if (!Object.values($).includes(n2.key)) return;
    n2.preventDefault(), x2(true);
    let { top: s2, left: c2 } = f2.current.getBoundingClientRect(), { width: R2, height: b2 } = p2.current.getBoundingClientRect(), D2 = typeof u2 == "string" ? parseFloat(u2) : u2 / R2 * 100, h2 = a2 ? n2.key === "ArrowLeft" || n2.key === "ArrowDown" : n2.key === "ArrowRight" || n2.key === "ArrowUp", S2 = Math.min(Math.max(h2 ? d2.current + D2 : d2.current - D2, 0), 100);
    l2({ x: a2 ? c2 : R2 * S2 / 100, y: a2 ? b2 * S2 / 100 : s2 });
  }, [u2, a2, l2]);
  reactExports.useEffect(() => {
    fe2(E2 ? f2.current : p2.current);
  }, [E2]), reactExports.useEffect(() => {
    let n2 = p2.current, s2 = () => {
      L2 || T2();
    };
    return r2 && (n2.addEventListener("pointermove", v2, I), n2.addEventListener("pointerleave", s2, I)), () => {
      n2.removeEventListener("pointermove", v2), n2.removeEventListener("pointerleave", s2);
    };
  }, [r2, v2, T2, L2]), reactExports.useEffect(() => (L2 && !w2.current && (t2.addEventListener("pointermove", v2, I), t2.addEventListener("pointerup", T2, I), w2.current = true), () => {
    w2.current && (t2.removeEventListener("pointermove", v2), t2.removeEventListener("pointerup", T2), w2.current = false);
  }), [v2, T2, L2, t2]), reactExports.useImperativeHandle(de2, () => ({ rootContainer: p2.current, handleContainer: f2.current, setPosition(n2) {
    let { width: s2, height: c2 } = p2.current.getBoundingClientRect();
    l2({ x: s2 / 100 * n2, y: c2 / 100 * n2 });
  } }), [l2]), ie(p2, Se2), U("keydown", Ce2, f2.current, X), U("click", Me, f2.current, X), U("pointerdown", Re2, ue2, X);
  let ve2 = i2 || jsxRuntimeExports.jsx(F, { disabled: o2, portrait: a2 }), K2 = me2 ? ce2 : void 0, he2 = { position: "relative", display: "flex", overflow: "hidden", cursor: L2 ? a2 ? "ns-resize" : "ew-resize" : void 0, touchAction: "none", userSelect: "none", KhtmlUserSelect: "none", msUserSelect: "none", MozUserSelect: "none", WebkitUserSelect: "none", ...le2 };
  return jsxRuntimeExports.jsxs("div", { ...pe2, ref: p2, style: he2, "data-rcs": "root", children: [m2, jsxRuntimeExports.jsx(B, { ref: j2, transition: K2, children: C2 }), jsxRuntimeExports.jsx(W, { disabled: o2, portrait: a2, position: Math.round(d2.current), ref: f2, transition: K2, children: ve2 })] });
});
se.displayName = "ReactCompareSlider";
var ae2 = reactExports.forwardRef(({ style: e2, ...t2 }, r2) => {
  let o2 = G(e2);
  return jsxRuntimeExports.jsx("img", { ref: r2, ...t2, style: o2, "data-rcs": "image" });
});
ae2.displayName = "ReactCompareSliderImage";
var type;
var hasRequiredType;
function requireType() {
  if (hasRequiredType) return type;
  hasRequiredType = 1;
  type = TypeError;
  return type;
}
const isRegExp = (val) => val instanceof RegExp;
const isDate = (val) => val instanceof Date;
const isBoolean = (val) => typeof val === "boolean";
const isNull = (val) => val === null;
const isNullOrUndefined = (val) => val === null || val === void 0;
const isNumber = (val) => typeof val === "number";
const isString = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isUndefined = (val) => val === void 0;
const isFunction = (val) => typeof val === "function";
const isBuffer = (val) => {
  return val && typeof val === "object" && typeof val.copy === "function" && typeof val.fill === "function" && typeof val.readUInt8 === "function";
};
const isObject$2 = (val) => val !== null && typeof val === "object" && Object.getPrototypeOf(val).isPrototypeOf(Object);
const isError = (val) => val instanceof Error;
const isPrimitive = (val) => {
  if (typeof val === "object") {
    return val === null;
  }
  return typeof val !== "function";
};
const _errnoException = /* @__PURE__ */ notImplemented("util._errnoException");
const _exceptionWithHostPort = /* @__PURE__ */ notImplemented("util._exceptionWithHostPort");
const getSystemErrorMap = /* @__PURE__ */ notImplemented("util.getSystemErrorMap");
const getSystemErrorName = /* @__PURE__ */ notImplemented("util.getSystemErrorName");
const parseEnv = /* @__PURE__ */ notImplemented("util.parseEnv");
const styleText = /* @__PURE__ */ notImplemented("util.styleText");
const workerdUtil = process.getBuiltinModule("node:util");
const {
  MIMEParams,
  MIMEType,
  TextDecoder: TextDecoder$1,
  TextEncoder: TextEncoder$1,
  // @ts-expect-error missing types?
  _extend,
  aborted,
  callbackify,
  debug,
  debuglog,
  deprecate,
  format,
  formatWithOptions,
  // @ts-expect-error unknown type
  getCallSite,
  inherits,
  inspect,
  isArray,
  isDeepStrictEqual,
  log,
  parseArgs,
  promisify,
  stripVTControlCharacters,
  toUSVString,
  transferableAbortController,
  transferableAbortSignal
} = workerdUtil;
const types = workerdUtil.types;
const util = {
  /**
   * manually unroll unenv-polyfilled-symbols to make it tree-shakeable
   */
  _errnoException,
  _exceptionWithHostPort,
  // @ts-expect-error unenv has unknown type
  getSystemErrorMap,
  // @ts-expect-error unenv has unknown type
  getSystemErrorName,
  isBoolean,
  isBuffer,
  isDate,
  isError,
  isFunction,
  isNull,
  isNullOrUndefined,
  isNumber,
  isObject: isObject$2,
  isPrimitive,
  isRegExp,
  isString,
  isSymbol,
  isUndefined,
  // @ts-expect-error unenv has unknown type
  parseEnv,
  // @ts-expect-error unenv has unknown type
  styleText,
  /**
   * manually unroll workerd-polyfilled-symbols to make it tree-shakeable
   */
  _extend,
  aborted,
  callbackify,
  debug,
  debuglog,
  deprecate,
  format,
  formatWithOptions,
  getCallSite,
  inherits,
  inspect,
  isArray,
  isDeepStrictEqual,
  log,
  MIMEParams,
  MIMEType,
  parseArgs,
  promisify,
  stripVTControlCharacters,
  TextDecoder: TextDecoder$1,
  TextEncoder: TextEncoder$1,
  toUSVString,
  transferableAbortController,
  transferableAbortSignal,
  // special-cased deep merged symbols
  types
};
const util$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MIMEParams,
  MIMEType,
  TextDecoder: TextDecoder$1,
  TextEncoder: TextEncoder$1,
  _errnoException,
  _exceptionWithHostPort,
  _extend,
  aborted,
  callbackify,
  debug,
  debuglog,
  default: util,
  deprecate,
  format,
  formatWithOptions,
  getCallSite,
  getSystemErrorMap,
  getSystemErrorName,
  inherits,
  inspect,
  isArray,
  isBoolean,
  isBuffer,
  isDate,
  isDeepStrictEqual,
  isError,
  isFunction,
  isNull,
  isNullOrUndefined,
  isNumber,
  isObject: isObject$2,
  isPrimitive,
  isRegExp,
  isString,
  isSymbol,
  isUndefined,
  log,
  parseArgs,
  parseEnv,
  promisify,
  stripVTControlCharacters,
  styleText,
  toUSVString,
  transferableAbortController,
  transferableAbortSignal,
  types
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(util$1);
var util_inspect;
var hasRequiredUtil_inspect;
function requireUtil_inspect() {
  if (hasRequiredUtil_inspect) return util_inspect;
  hasRequiredUtil_inspect = 1;
  util_inspect = require$$0.inspect;
  return util_inspect;
}
var objectInspect;
var hasRequiredObjectInspect;
function requireObjectInspect() {
  if (hasRequiredObjectInspect) return objectInspect;
  hasRequiredObjectInspect = 1;
  var hasMap = typeof Map === "function" && Map.prototype;
  var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
  var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
  var mapForEach = hasMap && Map.prototype.forEach;
  var hasSet = typeof Set === "function" && Set.prototype;
  var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
  var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
  var setForEach = hasSet && Set.prototype.forEach;
  var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
  var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
  var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
  var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
  var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
  var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
  var booleanValueOf = Boolean.prototype.valueOf;
  var objectToString = Object.prototype.toString;
  var functionToString = Function.prototype.toString;
  var $match = String.prototype.match;
  var $slice = String.prototype.slice;
  var $replace = String.prototype.replace;
  var $toUpperCase = String.prototype.toUpperCase;
  var $toLowerCase = String.prototype.toLowerCase;
  var $test = RegExp.prototype.test;
  var $concat = Array.prototype.concat;
  var $join = Array.prototype.join;
  var $arrSlice = Array.prototype.slice;
  var $floor = Math.floor;
  var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
  var gOPS = Object.getOwnPropertySymbols;
  var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
  var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
  var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O2) {
    return O2.__proto__;
  } : null);
  function addNumericSeparator(num, str) {
    if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
      return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === "number") {
      var int2 = num < 0 ? -$floor(-num) : $floor(num);
      if (int2 !== num) {
        var intStr = String(int2);
        var dec = $slice.call(str, intStr.length + 1);
        return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return $replace.call(str, sepRegex, "$&_");
  }
  var utilInspect = /* @__PURE__ */ requireUtil_inspect();
  var inspectCustom = utilInspect.custom;
  var inspectSymbol = isSymbol2(inspectCustom) ? inspectCustom : null;
  var quotes = {
    __proto__: null,
    "double": '"',
    single: "'"
  };
  var quoteREs = {
    __proto__: null,
    "double": /(["\\])/g,
    single: /(['\\])/g
  };
  objectInspect = function inspect_(obj, options, depth, seen) {
    var opts = options || {};
    if (has(opts, "quoteStyle") && !has(quotes, opts.quoteStyle)) {
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
    if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
      throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    }
    if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
      throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
      throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;
    if (typeof obj === "undefined") {
      return "undefined";
    }
    if (obj === null) {
      return "null";
    }
    if (typeof obj === "boolean") {
      return obj ? "true" : "false";
    }
    if (typeof obj === "string") {
      return inspectString(obj, opts);
    }
    if (typeof obj === "number") {
      if (obj === 0) {
        return Infinity / obj > 0 ? "0" : "-0";
      }
      var str = String(obj);
      return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === "bigint") {
      var bigIntStr = String(obj) + "n";
      return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }
    var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
    if (typeof depth === "undefined") {
      depth = 0;
    }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
      return isArray2(obj) ? "[Array]" : "[Object]";
    }
    var indent = getIndent(opts, depth);
    if (typeof seen === "undefined") {
      seen = [];
    } else if (indexOf(seen, obj) >= 0) {
      return "[Circular]";
    }
    function inspect2(value, from, noIndent) {
      if (from) {
        seen = $arrSlice.call(seen);
        seen.push(from);
      }
      if (noIndent) {
        var newOpts = {
          depth: opts.depth
        };
        if (has(opts, "quoteStyle")) {
          newOpts.quoteStyle = opts.quoteStyle;
        }
        return inspect_(value, newOpts, depth + 1, seen);
      }
      return inspect_(value, opts, depth + 1, seen);
    }
    if (typeof obj === "function" && !isRegExp2(obj)) {
      var name = nameOf(obj);
      var keys = arrObjKeys(obj, inspect2);
      return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
    }
    if (isSymbol2(obj)) {
      var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
      return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
      var s2 = "<" + $toLowerCase.call(String(obj.nodeName));
      var attrs = obj.attributes || [];
      for (var i2 = 0; i2 < attrs.length; i2++) {
        s2 += " " + attrs[i2].name + "=" + wrapQuotes(quote(attrs[i2].value), "double", opts);
      }
      s2 += ">";
      if (obj.childNodes && obj.childNodes.length) {
        s2 += "...";
      }
      s2 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
      return s2;
    }
    if (isArray2(obj)) {
      if (obj.length === 0) {
        return "[]";
      }
      var xs2 = arrObjKeys(obj, inspect2);
      if (indent && !singleLineValues(xs2)) {
        return "[" + indentedJoin(xs2, indent) + "]";
      }
      return "[ " + $join.call(xs2, ", ") + " ]";
    }
    if (isError2(obj)) {
      var parts = arrObjKeys(obj, inspect2);
      if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
        return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect2(obj.cause), parts), ", ") + " }";
      }
      if (parts.length === 0) {
        return "[" + String(obj) + "]";
      }
      return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
    }
    if (typeof obj === "object" && customInspect) {
      if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
        return utilInspect(obj, { depth: maxDepth - depth });
      } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
        return obj.inspect();
      }
    }
    if (isMap(obj)) {
      var mapParts = [];
      if (mapForEach) {
        mapForEach.call(obj, function(value, key) {
          mapParts.push(inspect2(key, obj, true) + " => " + inspect2(value, obj));
        });
      }
      return collectionOf("Map", mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
      var setParts = [];
      if (setForEach) {
        setForEach.call(obj, function(value) {
          setParts.push(inspect2(value, obj));
        });
      }
      return collectionOf("Set", setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
      return weakCollectionOf("WeakMap");
    }
    if (isWeakSet(obj)) {
      return weakCollectionOf("WeakSet");
    }
    if (isWeakRef(obj)) {
      return weakCollectionOf("WeakRef");
    }
    if (isNumber2(obj)) {
      return markBoxed(inspect2(Number(obj)));
    }
    if (isBigInt(obj)) {
      return markBoxed(inspect2(bigIntValueOf.call(obj)));
    }
    if (isBoolean2(obj)) {
      return markBoxed(booleanValueOf.call(obj));
    }
    if (isString2(obj)) {
      return markBoxed(inspect2(String(obj)));
    }
    if (typeof window !== "undefined" && obj === window) {
      return "{ [object Window] }";
    }
    if (typeof globalThis !== "undefined" && obj === globalThis || typeof commonjsGlobal !== "undefined" && obj === commonjsGlobal) {
      return "{ [object globalThis] }";
    }
    if (!isDate2(obj) && !isRegExp2(obj)) {
      var ys2 = arrObjKeys(obj, inspect2);
      var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
      var protoTag = obj instanceof Object ? "" : "null prototype";
      var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
      var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
      var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
      if (ys2.length === 0) {
        return tag + "{}";
      }
      if (indent) {
        return tag + "{" + indentedJoin(ys2, indent) + "}";
      }
      return tag + "{ " + $join.call(ys2, ", ") + " }";
    }
    return String(obj);
  };
  function wrapQuotes(s2, defaultStyle, opts) {
    var style = opts.quoteStyle || defaultStyle;
    var quoteChar = quotes[style];
    return quoteChar + s2 + quoteChar;
  }
  function quote(s2) {
    return $replace.call(String(s2), /"/g, "&quot;");
  }
  function canTrustToString(obj) {
    return !toStringTag || !(typeof obj === "object" && (toStringTag in obj || typeof obj[toStringTag] !== "undefined"));
  }
  function isArray2(obj) {
    return toStr(obj) === "[object Array]" && canTrustToString(obj);
  }
  function isDate2(obj) {
    return toStr(obj) === "[object Date]" && canTrustToString(obj);
  }
  function isRegExp2(obj) {
    return toStr(obj) === "[object RegExp]" && canTrustToString(obj);
  }
  function isError2(obj) {
    return toStr(obj) === "[object Error]" && canTrustToString(obj);
  }
  function isString2(obj) {
    return toStr(obj) === "[object String]" && canTrustToString(obj);
  }
  function isNumber2(obj) {
    return toStr(obj) === "[object Number]" && canTrustToString(obj);
  }
  function isBoolean2(obj) {
    return toStr(obj) === "[object Boolean]" && canTrustToString(obj);
  }
  function isSymbol2(obj) {
    if (hasShammedSymbols) {
      return obj && typeof obj === "object" && obj instanceof Symbol;
    }
    if (typeof obj === "symbol") {
      return true;
    }
    if (!obj || typeof obj !== "object" || !symToString) {
      return false;
    }
    try {
      symToString.call(obj);
      return true;
    } catch (e2) {
    }
    return false;
  }
  function isBigInt(obj) {
    if (!obj || typeof obj !== "object" || !bigIntValueOf) {
      return false;
    }
    try {
      bigIntValueOf.call(obj);
      return true;
    } catch (e2) {
    }
    return false;
  }
  var hasOwn = Object.prototype.hasOwnProperty || function(key) {
    return key in this;
  };
  function has(obj, key) {
    return hasOwn.call(obj, key);
  }
  function toStr(obj) {
    return objectToString.call(obj);
  }
  function nameOf(f2) {
    if (f2.name) {
      return f2.name;
    }
    var m2 = $match.call(functionToString.call(f2), /^function\s*([\w$]+)/);
    if (m2) {
      return m2[1];
    }
    return null;
  }
  function indexOf(xs2, x2) {
    if (xs2.indexOf) {
      return xs2.indexOf(x2);
    }
    for (var i2 = 0, l2 = xs2.length; i2 < l2; i2++) {
      if (xs2[i2] === x2) {
        return i2;
      }
    }
    return -1;
  }
  function isMap(x2) {
    if (!mapSize || !x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      mapSize.call(x2);
      try {
        setSize.call(x2);
      } catch (s2) {
        return true;
      }
      return x2 instanceof Map;
    } catch (e2) {
    }
    return false;
  }
  function isWeakMap(x2) {
    if (!weakMapHas || !x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      weakMapHas.call(x2, weakMapHas);
      try {
        weakSetHas.call(x2, weakSetHas);
      } catch (s2) {
        return true;
      }
      return x2 instanceof WeakMap;
    } catch (e2) {
    }
    return false;
  }
  function isWeakRef(x2) {
    if (!weakRefDeref || !x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      weakRefDeref.call(x2);
      return true;
    } catch (e2) {
    }
    return false;
  }
  function isSet(x2) {
    if (!setSize || !x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      setSize.call(x2);
      try {
        mapSize.call(x2);
      } catch (m2) {
        return true;
      }
      return x2 instanceof Set;
    } catch (e2) {
    }
    return false;
  }
  function isWeakSet(x2) {
    if (!weakSetHas || !x2 || typeof x2 !== "object") {
      return false;
    }
    try {
      weakSetHas.call(x2, weakSetHas);
      try {
        weakMapHas.call(x2, weakMapHas);
      } catch (s2) {
        return true;
      }
      return x2 instanceof WeakSet;
    } catch (e2) {
    }
    return false;
  }
  function isElement(x2) {
    if (!x2 || typeof x2 !== "object") {
      return false;
    }
    if (typeof HTMLElement !== "undefined" && x2 instanceof HTMLElement) {
      return true;
    }
    return typeof x2.nodeName === "string" && typeof x2.getAttribute === "function";
  }
  function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
      var remaining = str.length - opts.maxStringLength;
      var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
      return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    var quoteRE = quoteREs[opts.quoteStyle || "single"];
    quoteRE.lastIndex = 0;
    var s2 = $replace.call($replace.call(str, quoteRE, "\\$1"), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s2, "single", opts);
  }
  function lowbyte(c2) {
    var n2 = c2.charCodeAt(0);
    var x2 = {
      8: "b",
      9: "t",
      10: "n",
      12: "f",
      13: "r"
    }[n2];
    if (x2) {
      return "\\" + x2;
    }
    return "\\x" + (n2 < 16 ? "0" : "") + $toUpperCase.call(n2.toString(16));
  }
  function markBoxed(str) {
    return "Object(" + str + ")";
  }
  function weakCollectionOf(type2) {
    return type2 + " { ? }";
  }
  function collectionOf(type2, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
    return type2 + " (" + size + ") {" + joinedEntries + "}";
  }
  function singleLineValues(xs2) {
    for (var i2 = 0; i2 < xs2.length; i2++) {
      if (indexOf(xs2[i2], "\n") >= 0) {
        return false;
      }
    }
    return true;
  }
  function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === "	") {
      baseIndent = "	";
    } else if (typeof opts.indent === "number" && opts.indent > 0) {
      baseIndent = $join.call(Array(opts.indent + 1), " ");
    } else {
      return null;
    }
    return {
      base: baseIndent,
      prev: $join.call(Array(depth + 1), baseIndent)
    };
  }
  function indentedJoin(xs2, indent) {
    if (xs2.length === 0) {
      return "";
    }
    var lineJoiner = "\n" + indent.prev + indent.base;
    return lineJoiner + $join.call(xs2, "," + lineJoiner) + "\n" + indent.prev;
  }
  function arrObjKeys(obj, inspect2) {
    var isArr = isArray2(obj);
    var xs2 = [];
    if (isArr) {
      xs2.length = obj.length;
      for (var i2 = 0; i2 < obj.length; i2++) {
        xs2[i2] = has(obj, i2) ? inspect2(obj[i2], obj) : "";
      }
    }
    var syms = typeof gOPS === "function" ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
      symMap = {};
      for (var k2 = 0; k2 < syms.length; k2++) {
        symMap["$" + syms[k2]] = syms[k2];
      }
    }
    for (var key in obj) {
      if (!has(obj, key)) {
        continue;
      }
      if (isArr && String(Number(key)) === key && key < obj.length) {
        continue;
      }
      if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
        continue;
      } else if ($test.call(/[^\w$]/, key)) {
        xs2.push(inspect2(key, obj) + ": " + inspect2(obj[key], obj));
      } else {
        xs2.push(key + ": " + inspect2(obj[key], obj));
      }
    }
    if (typeof gOPS === "function") {
      for (var j2 = 0; j2 < syms.length; j2++) {
        if (isEnumerable.call(obj, syms[j2])) {
          xs2.push("[" + inspect2(syms[j2]) + "]: " + inspect2(obj[syms[j2]], obj));
        }
      }
    }
    return xs2;
  }
  return objectInspect;
}
var sideChannelList;
var hasRequiredSideChannelList;
function requireSideChannelList() {
  if (hasRequiredSideChannelList) return sideChannelList;
  hasRequiredSideChannelList = 1;
  var inspect2 = /* @__PURE__ */ requireObjectInspect();
  var $TypeError = /* @__PURE__ */ requireType();
  var listGetNode = function(list, key, isDelete) {
    var prev = list;
    var curr;
    for (; (curr = prev.next) != null; prev = curr) {
      if (curr.key === key) {
        prev.next = curr.next;
        if (!isDelete) {
          curr.next = /** @type {NonNullable<typeof list.next>} */
          list.next;
          list.next = curr;
        }
        return curr;
      }
    }
  };
  var listGet = function(objects, key) {
    if (!objects) {
      return void 0;
    }
    var node = listGetNode(objects, key);
    return node && node.value;
  };
  var listSet = function(objects, key, value) {
    var node = listGetNode(objects, key);
    if (node) {
      node.value = value;
    } else {
      objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */
      {
        // eslint-disable-line no-param-reassign, no-extra-parens
        key,
        next: objects.next,
        value
      };
    }
  };
  var listHas = function(objects, key) {
    if (!objects) {
      return false;
    }
    return !!listGetNode(objects, key);
  };
  var listDelete = function(objects, key) {
    if (objects) {
      return listGetNode(objects, key, true);
    }
  };
  sideChannelList = function getSideChannelList() {
    var $o;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError("Side channel does not contain " + inspect2(key));
        }
      },
      "delete": function(key) {
        var root2 = $o && $o.next;
        var deletedNode = listDelete($o, key);
        if (deletedNode && root2 && root2 === deletedNode) {
          $o = void 0;
        }
        return !!deletedNode;
      },
      get: function(key) {
        return listGet($o, key);
      },
      has: function(key) {
        return listHas($o, key);
      },
      set: function(key, value) {
        if (!$o) {
          $o = {
            next: void 0
          };
        }
        listSet(
          /** @type {NonNullable<typeof $o>} */
          $o,
          key,
          value
        );
      }
    };
    return channel;
  };
  return sideChannelList;
}
var esObjectAtoms;
var hasRequiredEsObjectAtoms;
function requireEsObjectAtoms() {
  if (hasRequiredEsObjectAtoms) return esObjectAtoms;
  hasRequiredEsObjectAtoms = 1;
  esObjectAtoms = Object;
  return esObjectAtoms;
}
var esErrors;
var hasRequiredEsErrors;
function requireEsErrors() {
  if (hasRequiredEsErrors) return esErrors;
  hasRequiredEsErrors = 1;
  esErrors = Error;
  return esErrors;
}
var _eval;
var hasRequired_eval;
function require_eval() {
  if (hasRequired_eval) return _eval;
  hasRequired_eval = 1;
  _eval = EvalError;
  return _eval;
}
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  range = RangeError;
  return range;
}
var ref;
var hasRequiredRef;
function requireRef() {
  if (hasRequiredRef) return ref;
  hasRequiredRef = 1;
  ref = ReferenceError;
  return ref;
}
var syntax;
var hasRequiredSyntax;
function requireSyntax() {
  if (hasRequiredSyntax) return syntax;
  hasRequiredSyntax = 1;
  syntax = SyntaxError;
  return syntax;
}
var uri;
var hasRequiredUri;
function requireUri() {
  if (hasRequiredUri) return uri;
  hasRequiredUri = 1;
  uri = URIError;
  return uri;
}
var abs;
var hasRequiredAbs;
function requireAbs() {
  if (hasRequiredAbs) return abs;
  hasRequiredAbs = 1;
  abs = Math.abs;
  return abs;
}
var floor;
var hasRequiredFloor;
function requireFloor() {
  if (hasRequiredFloor) return floor;
  hasRequiredFloor = 1;
  floor = Math.floor;
  return floor;
}
var max;
var hasRequiredMax;
function requireMax() {
  if (hasRequiredMax) return max;
  hasRequiredMax = 1;
  max = Math.max;
  return max;
}
var min;
var hasRequiredMin;
function requireMin() {
  if (hasRequiredMin) return min;
  hasRequiredMin = 1;
  min = Math.min;
  return min;
}
var pow;
var hasRequiredPow;
function requirePow() {
  if (hasRequiredPow) return pow;
  hasRequiredPow = 1;
  pow = Math.pow;
  return pow;
}
var round;
var hasRequiredRound;
function requireRound() {
  if (hasRequiredRound) return round;
  hasRequiredRound = 1;
  round = Math.round;
  return round;
}
var _isNaN;
var hasRequired_isNaN;
function require_isNaN() {
  if (hasRequired_isNaN) return _isNaN;
  hasRequired_isNaN = 1;
  _isNaN = Number.isNaN || function isNaN2(a2) {
    return a2 !== a2;
  };
  return _isNaN;
}
var sign;
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign;
  hasRequiredSign = 1;
  var $isNaN = /* @__PURE__ */ require_isNaN();
  sign = function sign2(number2) {
    if ($isNaN(number2) || number2 === 0) {
      return number2;
    }
    return number2 < 0 ? -1 : 1;
  };
  return sign;
}
var gOPD;
var hasRequiredGOPD;
function requireGOPD() {
  if (hasRequiredGOPD) return gOPD;
  hasRequiredGOPD = 1;
  gOPD = Object.getOwnPropertyDescriptor;
  return gOPD;
}
var gopd;
var hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var $gOPD = /* @__PURE__ */ requireGOPD();
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e2) {
      $gOPD = null;
    }
  }
  gopd = $gOPD;
  return gopd;
}
var esDefineProperty;
var hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var $defineProperty = Object.defineProperty || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e2) {
      $defineProperty = false;
    }
  }
  esDefineProperty = $defineProperty;
  return esDefineProperty;
}
var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  shams = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _2 in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(obj, sym)
      );
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams;
}
var hasSymbols;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams();
  hasSymbols = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols;
}
var Reflect_getPrototypeOf;
var hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  if (hasRequiredReflect_getPrototypeOf) return Reflect_getPrototypeOf;
  hasRequiredReflect_getPrototypeOf = 1;
  Reflect_getPrototypeOf = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  return Reflect_getPrototypeOf;
}
var Object_getPrototypeOf;
var hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms();
  Object_getPrototypeOf = $Object.getPrototypeOf || null;
  return Object_getPrototypeOf;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max2 = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty2(a2, b2) {
    var arr = [];
    for (var i2 = 0; i2 < a2.length; i2 += 1) {
      arr[i2] = a2[i2];
    }
    for (var j2 = 0; j2 < b2.length; j2 += 1) {
      arr[j2 + a2.length] = b2[j2];
    }
    return arr;
  };
  var slicy = function slicy2(arrLike, offset) {
    var arr = [];
    for (var i2 = offset, j2 = 0; i2 < arrLike.length; i2 += 1, j2 += 1) {
      arr[j2] = arrLike[i2];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i2 = 0; i2 < arr.length; i2 += 1) {
      str += arr[i2];
      if (i2 + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  implementation = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(
          this,
          concatty(args, arguments)
        );
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(
        that,
        concatty(args, arguments)
      );
    };
    var boundLength = max2(0, target.length - args.length);
    var boundArgs = [];
    for (var i2 = 0; i2 < boundLength; i2++) {
      boundArgs[i2] = "$" + i2;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
  return implementation;
}
var functionBind;
var hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var implementation2 = requireImplementation();
  functionBind = Function.prototype.bind || implementation2;
  return functionBind;
}
var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
  if (hasRequiredFunctionCall) return functionCall;
  hasRequiredFunctionCall = 1;
  functionCall = Function.prototype.call;
  return functionCall;
}
var functionApply;
var hasRequiredFunctionApply;
function requireFunctionApply() {
  if (hasRequiredFunctionApply) return functionApply;
  hasRequiredFunctionApply = 1;
  functionApply = Function.prototype.apply;
  return functionApply;
}
var reflectApply;
var hasRequiredReflectApply;
function requireReflectApply() {
  if (hasRequiredReflectApply) return reflectApply;
  hasRequiredReflectApply = 1;
  reflectApply = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  return reflectApply;
}
var actualApply;
var hasRequiredActualApply;
function requireActualApply() {
  if (hasRequiredActualApply) return actualApply;
  hasRequiredActualApply = 1;
  var bind = requireFunctionBind();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var $reflectApply = requireReflectApply();
  actualApply = $reflectApply || bind.call($call, $apply);
  return actualApply;
}
var callBindApplyHelpers;
var hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var bind = requireFunctionBind();
  var $TypeError = /* @__PURE__ */ requireType();
  var $call = requireFunctionCall();
  var $actualApply = requireActualApply();
  callBindApplyHelpers = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== "function") {
      throw new $TypeError("a function is required");
    }
    return $actualApply(bind, $call, args);
  };
  return callBindApplyHelpers;
}
var get;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get;
  hasRequiredGet = 1;
  var callBind = requireCallBindApplyHelpers();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var hasProtoAccessor;
  try {
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (e2) {
    if (!e2 || typeof e2 !== "object" || !("code" in e2) || e2.code !== "ERR_PROTO_ACCESS") {
      throw e2;
    }
  }
  var desc = !!hasProtoAccessor && gOPD2 && gOPD2(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  );
  var $Object = Object;
  var $getPrototypeOf = $Object.getPrototypeOf;
  get = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
    /** @type {import('./get')} */
    function getDunder(value) {
      return $getPrototypeOf(value == null ? value : $Object(value));
    }
  ) : false;
  return get;
}
var getProto;
var hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto;
  hasRequiredGetProto = 1;
  var reflectGetProto = requireReflect_getPrototypeOf();
  var originalGetProto = requireObject_getPrototypeOf();
  var getDunderProto = /* @__PURE__ */ requireGet();
  getProto = reflectGetProto ? function getProto2(O2) {
    return reflectGetProto(O2);
  } : originalGetProto ? function getProto2(O2) {
    if (!O2 || typeof O2 !== "object" && typeof O2 !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O2);
  } : getDunderProto ? function getProto2(O2) {
    return getDunderProto(O2);
  } : null;
  return getProto;
}
var hasown;
var hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind = requireFunctionBind();
  hasown = bind.call(call, $hasOwn);
  return hasown;
}
var getIntrinsic;
var hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var undefined$1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms();
  var $Error = /* @__PURE__ */ requireEsErrors();
  var $EvalError = /* @__PURE__ */ require_eval();
  var $RangeError = /* @__PURE__ */ requireRange();
  var $ReferenceError = /* @__PURE__ */ requireRef();
  var $SyntaxError = /* @__PURE__ */ requireSyntax();
  var $TypeError = /* @__PURE__ */ requireType();
  var $URIError = /* @__PURE__ */ requireUri();
  var abs2 = /* @__PURE__ */ requireAbs();
  var floor2 = /* @__PURE__ */ requireFloor();
  var max2 = /* @__PURE__ */ requireMax();
  var min2 = /* @__PURE__ */ requireMin();
  var pow2 = /* @__PURE__ */ requirePow();
  var round2 = /* @__PURE__ */ requireRound();
  var sign2 = /* @__PURE__ */ requireSign();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e2) {
    }
  };
  var $gOPD = /* @__PURE__ */ requireGopd();
  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
  var throwTypeError = function() {
    throw new $TypeError();
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols2 = requireHasSymbols()();
  var getProto2 = requireGetProto();
  var $ObjectGPO = requireObject_getPrototypeOf();
  var $ReflectGPO = requireReflect_getPrototypeOf();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto2 ? undefined$1 : getProto2(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": $EvalError,
    "%Float16Array%": typeof Float16Array === "undefined" ? undefined$1 : Float16Array,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(getProto2([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": $Object,
    "%Object.getOwnPropertyDescriptor%": $gOPD,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
    "%Function.prototype.call%": $call,
    "%Function.prototype.apply%": $apply,
    "%Object.defineProperty%": $defineProperty,
    "%Object.getPrototypeOf%": $ObjectGPO,
    "%Math.abs%": abs2,
    "%Math.floor%": floor2,
    "%Math.max%": max2,
    "%Math.min%": min2,
    "%Math.pow%": pow2,
    "%Math.round%": round2,
    "%Math.sign%": sign2,
    "%Reflect.getPrototypeOf%": $ReflectGPO
  };
  if (getProto2) {
    try {
      null.error;
    } catch (e2) {
      var errorProto = getProto2(getProto2(e2));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var doEval = function doEval2(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn2 = doEval2("%AsyncGeneratorFunction%");
      if (fn2) {
        value = fn2.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval2("%AsyncGenerator%");
      if (gen && getProto2) {
        value = getProto2(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind = requireFunctionBind();
  var hasOwn = /* @__PURE__ */ requireHasown();
  var $concat = bind.call($call, Array.prototype.concat);
  var $spliceApply = bind.call($apply, Array.prototype.splice);
  var $replace = bind.call($call, String.prototype.replace);
  var $strSlice = bind.call($call, String.prototype.slice);
  var $exec = bind.call($call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath2(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string, rePropName, function(match, number2, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number2 || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  getIntrinsic = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
      var part = parts[i2];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return void undefined$1;
        }
        if ($gOPD && i2 + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
  return getIntrinsic;
}
var callBound;
var hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound) return callBound;
  hasRequiredCallBound = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var callBindBasic = requireCallBindApplyHelpers();
  var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
  callBound = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = (
      /** @type {(this: unknown, ...args: unknown[]) => unknown} */
      GetIntrinsic(name, !!allowMissing)
    );
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
      return callBindBasic(
        /** @type {const} */
        [intrinsic]
      );
    }
    return intrinsic;
  };
  return callBound;
}
var sideChannelMap;
var hasRequiredSideChannelMap;
function requireSideChannelMap() {
  if (hasRequiredSideChannelMap) return sideChannelMap;
  hasRequiredSideChannelMap = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var callBound2 = /* @__PURE__ */ requireCallBound();
  var inspect2 = /* @__PURE__ */ requireObjectInspect();
  var $TypeError = /* @__PURE__ */ requireType();
  var $Map = GetIntrinsic("%Map%", true);
  var $mapGet = callBound2("Map.prototype.get", true);
  var $mapSet = callBound2("Map.prototype.set", true);
  var $mapHas = callBound2("Map.prototype.has", true);
  var $mapDelete = callBound2("Map.prototype.delete", true);
  var $mapSize = callBound2("Map.prototype.size", true);
  sideChannelMap = !!$Map && /** @type {Exclude<import('.'), false>} */
  function getSideChannelMap() {
    var $m;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError("Side channel does not contain " + inspect2(key));
        }
      },
      "delete": function(key) {
        if ($m) {
          var result = $mapDelete($m, key);
          if ($mapSize($m) === 0) {
            $m = void 0;
          }
          return result;
        }
        return false;
      },
      get: function(key) {
        if ($m) {
          return $mapGet($m, key);
        }
      },
      has: function(key) {
        if ($m) {
          return $mapHas($m, key);
        }
        return false;
      },
      set: function(key, value) {
        if (!$m) {
          $m = new $Map();
        }
        $mapSet($m, key, value);
      }
    };
    return channel;
  };
  return sideChannelMap;
}
var sideChannelWeakmap;
var hasRequiredSideChannelWeakmap;
function requireSideChannelWeakmap() {
  if (hasRequiredSideChannelWeakmap) return sideChannelWeakmap;
  hasRequiredSideChannelWeakmap = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var callBound2 = /* @__PURE__ */ requireCallBound();
  var inspect2 = /* @__PURE__ */ requireObjectInspect();
  var getSideChannelMap = requireSideChannelMap();
  var $TypeError = /* @__PURE__ */ requireType();
  var $WeakMap = GetIntrinsic("%WeakMap%", true);
  var $weakMapGet = callBound2("WeakMap.prototype.get", true);
  var $weakMapSet = callBound2("WeakMap.prototype.set", true);
  var $weakMapHas = callBound2("WeakMap.prototype.has", true);
  var $weakMapDelete = callBound2("WeakMap.prototype.delete", true);
  sideChannelWeakmap = $WeakMap ? (
    /** @type {Exclude<import('.'), false>} */
    function getSideChannelWeakMap() {
      var $wm;
      var $m;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect2(key));
          }
        },
        "delete": function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapDelete($wm, key);
            }
          } else if (getSideChannelMap) {
            if ($m) {
              return $m["delete"](key);
            }
          }
          return false;
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          }
          return $m && $m.get(key);
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          }
          return !!$m && $m.has(key);
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if (getSideChannelMap) {
            if (!$m) {
              $m = getSideChannelMap();
            }
            $m.set(key, value);
          }
        }
      };
      return channel;
    }
  ) : getSideChannelMap;
  return sideChannelWeakmap;
}
var sideChannel;
var hasRequiredSideChannel;
function requireSideChannel() {
  if (hasRequiredSideChannel) return sideChannel;
  hasRequiredSideChannel = 1;
  var $TypeError = /* @__PURE__ */ requireType();
  var inspect2 = /* @__PURE__ */ requireObjectInspect();
  var getSideChannelList = requireSideChannelList();
  var getSideChannelMap = requireSideChannelMap();
  var getSideChannelWeakMap = requireSideChannelWeakmap();
  var makeChannel = getSideChannelWeakMap || getSideChannelMap || getSideChannelList;
  sideChannel = function getSideChannel() {
    var $channelData;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError("Side channel does not contain " + inspect2(key));
        }
      },
      "delete": function(key) {
        return !!$channelData && $channelData["delete"](key);
      },
      get: function(key) {
        return $channelData && $channelData.get(key);
      },
      has: function(key) {
        return !!$channelData && $channelData.has(key);
      },
      set: function(key, value) {
        if (!$channelData) {
          $channelData = makeChannel();
        }
        $channelData.set(key, value);
      }
    };
    return channel;
  };
  return sideChannel;
}
var formats;
var hasRequiredFormats;
function requireFormats() {
  if (hasRequiredFormats) return formats;
  hasRequiredFormats = 1;
  var replace = String.prototype.replace;
  var percentTwenties = /%20/g;
  var Format = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
  };
  formats = {
    "default": Format.RFC3986,
    formatters: {
      RFC1738: function(value) {
        return replace.call(value, percentTwenties, "+");
      },
      RFC3986: function(value) {
        return String(value);
      }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
  };
  return formats;
}
var utils;
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  var formats2 = /* @__PURE__ */ requireFormats();
  var has = Object.prototype.hasOwnProperty;
  var isArray2 = Array.isArray;
  var hexTable = function() {
    var array = [];
    for (var i2 = 0; i2 < 256; ++i2) {
      array.push("%" + ((i2 < 16 ? "0" : "") + i2.toString(16)).toUpperCase());
    }
    return array;
  }();
  var compactQueue = function compactQueue2(queue) {
    while (queue.length > 1) {
      var item = queue.pop();
      var obj = item.obj[item.prop];
      if (isArray2(obj)) {
        var compacted = [];
        for (var j2 = 0; j2 < obj.length; ++j2) {
          if (typeof obj[j2] !== "undefined") {
            compacted.push(obj[j2]);
          }
        }
        item.obj[item.prop] = compacted;
      }
    }
  };
  var arrayToObject = function arrayToObject2(source, options) {
    var obj = options && options.plainObjects ? { __proto__: null } : {};
    for (var i2 = 0; i2 < source.length; ++i2) {
      if (typeof source[i2] !== "undefined") {
        obj[i2] = source[i2];
      }
    }
    return obj;
  };
  var merge = function merge2(target, source, options) {
    if (!source) {
      return target;
    }
    if (typeof source !== "object" && typeof source !== "function") {
      if (isArray2(target)) {
        target.push(source);
      } else if (target && typeof target === "object") {
        if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
          target[source] = true;
        }
      } else {
        return [target, source];
      }
      return target;
    }
    if (!target || typeof target !== "object") {
      return [target].concat(source);
    }
    var mergeTarget = target;
    if (isArray2(target) && !isArray2(source)) {
      mergeTarget = arrayToObject(target, options);
    }
    if (isArray2(target) && isArray2(source)) {
      source.forEach(function(item, i2) {
        if (has.call(target, i2)) {
          var targetItem = target[i2];
          if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
            target[i2] = merge2(targetItem, item, options);
          } else {
            target.push(item);
          }
        } else {
          target[i2] = item;
        }
      });
      return target;
    }
    return Object.keys(source).reduce(function(acc, key) {
      var value = source[key];
      if (has.call(acc, key)) {
        acc[key] = merge2(acc[key], value, options);
      } else {
        acc[key] = value;
      }
      return acc;
    }, mergeTarget);
  };
  var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function(acc, key) {
      acc[key] = source[key];
      return acc;
    }, target);
  };
  var decode = function(str, defaultDecoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, " ");
    if (charset === "iso-8859-1") {
      return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    try {
      return decodeURIComponent(strWithoutPlus);
    } catch (e2) {
      return strWithoutPlus;
    }
  };
  var limit = 1024;
  var encode = function encode2(str, defaultEncoder, charset, kind, format2) {
    if (str.length === 0) {
      return str;
    }
    var string = str;
    if (typeof str === "symbol") {
      string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== "string") {
      string = String(str);
    }
    if (charset === "iso-8859-1") {
      return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
        return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
      });
    }
    var out = "";
    for (var j2 = 0; j2 < string.length; j2 += limit) {
      var segment = string.length >= limit ? string.slice(j2, j2 + limit) : string;
      var arr = [];
      for (var i2 = 0; i2 < segment.length; ++i2) {
        var c2 = segment.charCodeAt(i2);
        if (c2 === 45 || c2 === 46 || c2 === 95 || c2 === 126 || c2 >= 48 && c2 <= 57 || c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122 || format2 === formats2.RFC1738 && (c2 === 40 || c2 === 41)) {
          arr[arr.length] = segment.charAt(i2);
          continue;
        }
        if (c2 < 128) {
          arr[arr.length] = hexTable[c2];
          continue;
        }
        if (c2 < 2048) {
          arr[arr.length] = hexTable[192 | c2 >> 6] + hexTable[128 | c2 & 63];
          continue;
        }
        if (c2 < 55296 || c2 >= 57344) {
          arr[arr.length] = hexTable[224 | c2 >> 12] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
          continue;
        }
        i2 += 1;
        c2 = 65536 + ((c2 & 1023) << 10 | segment.charCodeAt(i2) & 1023);
        arr[arr.length] = hexTable[240 | c2 >> 18] + hexTable[128 | c2 >> 12 & 63] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
      }
      out += arr.join("");
    }
    return out;
  };
  var compact = function compact2(value) {
    var queue = [{ obj: { o: value }, prop: "o" }];
    var refs = [];
    for (var i2 = 0; i2 < queue.length; ++i2) {
      var item = queue[i2];
      var obj = item.obj[item.prop];
      var keys = Object.keys(obj);
      for (var j2 = 0; j2 < keys.length; ++j2) {
        var key = keys[j2];
        var val = obj[key];
        if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
          queue.push({ obj, prop: key });
          refs.push(val);
        }
      }
    }
    compactQueue(queue);
    return value;
  };
  var isRegExp2 = function isRegExp3(obj) {
    return Object.prototype.toString.call(obj) === "[object RegExp]";
  };
  var isBuffer2 = function isBuffer3(obj) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
  };
  var combine = function combine2(a2, b2) {
    return [].concat(a2, b2);
  };
  var maybeMap = function maybeMap2(val, fn2) {
    if (isArray2(val)) {
      var mapped = [];
      for (var i2 = 0; i2 < val.length; i2 += 1) {
        mapped.push(fn2(val[i2]));
      }
      return mapped;
    }
    return fn2(val);
  };
  utils = {
    arrayToObject,
    assign,
    combine,
    compact,
    decode,
    encode,
    isBuffer: isBuffer2,
    isRegExp: isRegExp2,
    maybeMap,
    merge
  };
  return utils;
}
var stringify_1;
var hasRequiredStringify;
function requireStringify() {
  if (hasRequiredStringify) return stringify_1;
  hasRequiredStringify = 1;
  var getSideChannel = requireSideChannel();
  var utils2 = /* @__PURE__ */ requireUtils();
  var formats2 = /* @__PURE__ */ requireFormats();
  var has = Object.prototype.hasOwnProperty;
  var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
      return prefix + "[]";
    },
    comma: "comma",
    indices: function indices(prefix, key) {
      return prefix + "[" + key + "]";
    },
    repeat: function repeat(prefix) {
      return prefix;
    }
  };
  var isArray2 = Array.isArray;
  var push = Array.prototype.push;
  var pushToArray = function(arr, valueOrArray) {
    push.apply(arr, isArray2(valueOrArray) ? valueOrArray : [valueOrArray]);
  };
  var toISO = Date.prototype.toISOString;
  var defaultFormat = formats2["default"];
  var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: "indices",
    charset: "utf-8",
    charsetSentinel: false,
    commaRoundTrip: false,
    delimiter: "&",
    encode: true,
    encodeDotInKeys: false,
    encoder: utils2.encode,
    encodeValuesOnly: false,
    filter: void 0,
    format: defaultFormat,
    formatter: formats2.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
      return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
  };
  var isNonNullishPrimitive = function isNonNullishPrimitive2(v2) {
    return typeof v2 === "string" || typeof v2 === "number" || typeof v2 === "boolean" || typeof v2 === "symbol" || typeof v2 === "bigint";
  };
  var sentinel = {};
  var stringify = function stringify2(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter2, sort, allowDots, serializeDate, format2, formatter, encodeValuesOnly, charset, sideChannel2) {
    var obj = object;
    var tmpSc = sideChannel2;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
      var pos = tmpSc.get(object);
      step += 1;
      if (typeof pos !== "undefined") {
        if (pos === step) {
          throw new RangeError("Cyclic object value");
        } else {
          findFlag = true;
        }
      }
      if (typeof tmpSc.get(sentinel) === "undefined") {
        step = 0;
      }
    }
    if (typeof filter2 === "function") {
      obj = filter2(prefix, obj);
    } else if (obj instanceof Date) {
      obj = serializeDate(obj);
    } else if (generateArrayPrefix === "comma" && isArray2(obj)) {
      obj = utils2.maybeMap(obj, function(value2) {
        if (value2 instanceof Date) {
          return serializeDate(value2);
        }
        return value2;
      });
    }
    if (obj === null) {
      if (strictNullHandling) {
        return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format2) : prefix;
      }
      obj = "";
    }
    if (isNonNullishPrimitive(obj) || utils2.isBuffer(obj)) {
      if (encoder) {
        var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format2);
        return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format2))];
      }
      return [formatter(prefix) + "=" + formatter(String(obj))];
    }
    var values = [];
    if (typeof obj === "undefined") {
      return values;
    }
    var objKeys;
    if (generateArrayPrefix === "comma" && isArray2(obj)) {
      if (encodeValuesOnly && encoder) {
        obj = utils2.maybeMap(obj, encoder);
      }
      objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
    } else if (isArray2(filter2)) {
      objKeys = filter2;
    } else {
      var keys = Object.keys(obj);
      objKeys = sort ? keys.sort(sort) : keys;
    }
    var encodedPrefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
    var adjustedPrefix = commaRoundTrip && isArray2(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
    if (allowEmptyArrays && isArray2(obj) && obj.length === 0) {
      return adjustedPrefix + "[]";
    }
    for (var j2 = 0; j2 < objKeys.length; ++j2) {
      var key = objKeys[j2];
      var value = typeof key === "object" && key && typeof key.value !== "undefined" ? key.value : obj[key];
      if (skipNulls && value === null) {
        continue;
      }
      var encodedKey = allowDots && encodeDotInKeys ? String(key).replace(/\./g, "%2E") : String(key);
      var keyPrefix = isArray2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
      sideChannel2.set(object, step);
      var valueSideChannel = getSideChannel();
      valueSideChannel.set(sentinel, sideChannel2);
      pushToArray(values, stringify2(
        value,
        keyPrefix,
        generateArrayPrefix,
        commaRoundTrip,
        allowEmptyArrays,
        strictNullHandling,
        skipNulls,
        encodeDotInKeys,
        generateArrayPrefix === "comma" && encodeValuesOnly && isArray2(obj) ? null : encoder,
        filter2,
        sort,
        allowDots,
        serializeDate,
        format2,
        formatter,
        encodeValuesOnly,
        charset,
        valueSideChannel
      ));
    }
    return values;
  };
  var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
    if (!opts) {
      return defaults;
    }
    if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    }
    if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
      throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
    }
    if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
      throw new TypeError("Encoder has to be a function.");
    }
    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    var format2 = formats2["default"];
    if (typeof opts.format !== "undefined") {
      if (!has.call(formats2.formatters, opts.format)) {
        throw new TypeError("Unknown format option provided.");
      }
      format2 = opts.format;
    }
    var formatter = formats2.formatters[format2];
    var filter2 = defaults.filter;
    if (typeof opts.filter === "function" || isArray2(opts.filter)) {
      filter2 = opts.filter;
    }
    var arrayFormat;
    if (opts.arrayFormat in arrayPrefixGenerators) {
      arrayFormat = opts.arrayFormat;
    } else if ("indices" in opts) {
      arrayFormat = opts.indices ? "indices" : "repeat";
    } else {
      arrayFormat = defaults.arrayFormat;
    }
    if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
      throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    }
    var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
    return {
      addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
      allowDots,
      allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
      arrayFormat,
      charset,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
      commaRoundTrip: !!opts.commaRoundTrip,
      delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
      encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
      encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
      encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
      encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
      filter: filter2,
      format: format2,
      formatter,
      serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
      skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
      sort: typeof opts.sort === "function" ? opts.sort : null,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
    };
  };
  stringify_1 = function(object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);
    var objKeys;
    var filter2;
    if (typeof options.filter === "function") {
      filter2 = options.filter;
      obj = filter2("", obj);
    } else if (isArray2(options.filter)) {
      filter2 = options.filter;
      objKeys = filter2;
    }
    var keys = [];
    if (typeof obj !== "object" || obj === null) {
      return "";
    }
    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
    var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
    if (!objKeys) {
      objKeys = Object.keys(obj);
    }
    if (options.sort) {
      objKeys.sort(options.sort);
    }
    var sideChannel2 = getSideChannel();
    for (var i2 = 0; i2 < objKeys.length; ++i2) {
      var key = objKeys[i2];
      var value = obj[key];
      if (options.skipNulls && value === null) {
        continue;
      }
      pushToArray(keys, stringify(
        value,
        key,
        generateArrayPrefix,
        commaRoundTrip,
        options.allowEmptyArrays,
        options.strictNullHandling,
        options.skipNulls,
        options.encodeDotInKeys,
        options.encode ? options.encoder : null,
        options.filter,
        options.sort,
        options.allowDots,
        options.serializeDate,
        options.format,
        options.formatter,
        options.encodeValuesOnly,
        options.charset,
        sideChannel2
      ));
    }
    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? "?" : "";
    if (options.charsetSentinel) {
      if (options.charset === "iso-8859-1") {
        prefix += "utf8=%26%2310003%3B&";
      } else {
        prefix += "utf8=%E2%9C%93&";
      }
    }
    return joined.length > 0 ? prefix + joined : "";
  };
  return stringify_1;
}
var parse;
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse;
  hasRequiredParse = 1;
  var utils2 = /* @__PURE__ */ requireUtils();
  var has = Object.prototype.hasOwnProperty;
  var isArray2 = Array.isArray;
  var defaults = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: utils2.decode,
    delimiter: "&",
    depth: 5,
    duplicates: "combine",
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1e3,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false,
    throwOnLimitExceeded: false
  };
  var interpretNumericEntities = function(str) {
    return str.replace(/&#(\d+);/g, function($0, numberStr) {
      return String.fromCharCode(parseInt(numberStr, 10));
    });
  };
  var parseArrayValue = function(val, options, currentArrayLength) {
    if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
      return val.split(",");
    }
    if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {
      throw new RangeError("Array limit exceeded. Only " + options.arrayLimit + " element" + (options.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
    }
    return val;
  };
  var isoSentinel = "utf8=%26%2310003%3B";
  var charsetSentinel = "utf8=%E2%9C%93";
  var parseValues = function parseQueryStringValues(str, options) {
    var obj = { __proto__: null };
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
    cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
    var parts = cleanStr.split(
      options.delimiter,
      options.throwOnLimitExceeded ? limit + 1 : limit
    );
    if (options.throwOnLimitExceeded && parts.length > limit) {
      throw new RangeError("Parameter limit exceeded. Only " + limit + " parameter" + (limit === 1 ? "" : "s") + " allowed.");
    }
    var skipIndex = -1;
    var i2;
    var charset = options.charset;
    if (options.charsetSentinel) {
      for (i2 = 0; i2 < parts.length; ++i2) {
        if (parts[i2].indexOf("utf8=") === 0) {
          if (parts[i2] === charsetSentinel) {
            charset = "utf-8";
          } else if (parts[i2] === isoSentinel) {
            charset = "iso-8859-1";
          }
          skipIndex = i2;
          i2 = parts.length;
        }
      }
    }
    for (i2 = 0; i2 < parts.length; ++i2) {
      if (i2 === skipIndex) {
        continue;
      }
      var part = parts[i2];
      var bracketEqualsPos = part.indexOf("]=");
      var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
      var key;
      var val;
      if (pos === -1) {
        key = options.decoder(part, defaults.decoder, charset, "key");
        val = options.strictNullHandling ? null : "";
      } else {
        key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
        val = utils2.maybeMap(
          parseArrayValue(
            part.slice(pos + 1),
            options,
            isArray2(obj[key]) ? obj[key].length : 0
          ),
          function(encodedVal) {
            return options.decoder(encodedVal, defaults.decoder, charset, "value");
          }
        );
      }
      if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
        val = interpretNumericEntities(String(val));
      }
      if (part.indexOf("[]=") > -1) {
        val = isArray2(val) ? [val] : val;
      }
      var existing = has.call(obj, key);
      if (existing && options.duplicates === "combine") {
        obj[key] = utils2.combine(obj[key], val);
      } else if (!existing || options.duplicates === "last") {
        obj[key] = val;
      }
    }
    return obj;
  };
  var parseObject = function(chain, val, options, valuesParsed) {
    var currentArrayLength = 0;
    if (chain.length > 0 && chain[chain.length - 1] === "[]") {
      var parentKey = chain.slice(0, -1).join("");
      currentArrayLength = Array.isArray(val) && val[parentKey] ? val[parentKey].length : 0;
    }
    var leaf = valuesParsed ? val : parseArrayValue(val, options, currentArrayLength);
    for (var i2 = chain.length - 1; i2 >= 0; --i2) {
      var obj;
      var root2 = chain[i2];
      if (root2 === "[]" && options.parseArrays) {
        obj = options.allowEmptyArrays && (leaf === "" || options.strictNullHandling && leaf === null) ? [] : utils2.combine([], leaf);
      } else {
        obj = options.plainObjects ? { __proto__: null } : {};
        var cleanRoot = root2.charAt(0) === "[" && root2.charAt(root2.length - 1) === "]" ? root2.slice(1, -1) : root2;
        var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
        var index = parseInt(decodedRoot, 10);
        if (!options.parseArrays && decodedRoot === "") {
          obj = { 0: leaf };
        } else if (!isNaN(index) && root2 !== decodedRoot && String(index) === decodedRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
          obj = [];
          obj[index] = leaf;
        } else if (decodedRoot !== "__proto__") {
          obj[decodedRoot] = leaf;
        }
      }
      leaf = obj;
    }
    return leaf;
  };
  var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
      return;
    }
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;
    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;
    var keys = [];
    if (parent) {
      if (!options.plainObjects && has.call(Object.prototype, parent)) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(parent);
    }
    var i2 = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i2 < options.depth) {
      i2 += 1;
      if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(segment[1]);
    }
    if (segment) {
      if (options.strictDepth === true) {
        throw new RangeError("Input depth exceeded depth option of " + options.depth + " and strictDepth is true");
      }
      keys.push("[" + key.slice(segment.index) + "]");
    }
    return parseObject(keys, val, options, valuesParsed);
  };
  var normalizeParseOptions = function normalizeParseOptions2(opts) {
    if (!opts) {
      return defaults;
    }
    if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    }
    if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
      throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
    }
    if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
      throw new TypeError("Decoder has to be a function.");
    }
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    if (typeof opts.throwOnLimitExceeded !== "undefined" && typeof opts.throwOnLimitExceeded !== "boolean") {
      throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
    }
    var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
    var duplicates = typeof opts.duplicates === "undefined" ? defaults.duplicates : opts.duplicates;
    if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
      throw new TypeError("The duplicates option must be either combine, first, or last");
    }
    var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
    return {
      allowDots,
      allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
      allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
      allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
      arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
      charset,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
      comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
      decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
      decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
      delimiter: typeof opts.delimiter === "string" || utils2.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
      // eslint-disable-next-line no-implicit-coercion, no-extra-parens
      depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
      duplicates,
      ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
      interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
      parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
      parseArrays: opts.parseArrays !== false,
      plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
      strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults.strictDepth,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling,
      throwOnLimitExceeded: typeof opts.throwOnLimitExceeded === "boolean" ? opts.throwOnLimitExceeded : false
    };
  };
  parse = function(str, opts) {
    var options = normalizeParseOptions(opts);
    if (str === "" || str === null || typeof str === "undefined") {
      return options.plainObjects ? { __proto__: null } : {};
    }
    var tempObj = typeof str === "string" ? parseValues(str, options) : str;
    var obj = options.plainObjects ? { __proto__: null } : {};
    var keys = Object.keys(tempObj);
    for (var i2 = 0; i2 < keys.length; ++i2) {
      var key = keys[i2];
      var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
      obj = utils2.merge(obj, newObj, options);
    }
    if (options.allowSparse === true) {
      return obj;
    }
    return utils2.compact(obj);
  };
  return parse;
}
var lib;
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  var stringify = /* @__PURE__ */ requireStringify();
  var parse2 = /* @__PURE__ */ requireParse();
  var formats2 = /* @__PURE__ */ requireFormats();
  lib = {
    formats: formats2,
    parse: parse2,
    stringify
  };
  return lib;
}
var libExports = /* @__PURE__ */ requireLib();
const OPTIONS_KEYS = [
  "apiKey",
  "idempotencyKey",
  "stripeAccount",
  "apiVersion",
  "maxNetworkRetries",
  "timeout",
  "host",
  "authenticator",
  "stripeContext",
  "additionalHeaders",
  "streaming"
];
function isOptionsHash(o2) {
  return o2 && typeof o2 === "object" && OPTIONS_KEYS.some((prop) => Object.prototype.hasOwnProperty.call(o2, prop));
}
function queryStringifyRequestData(data, apiMode) {
  return libExports.stringify(data, {
    serializeDate: (d2) => Math.floor(d2.getTime() / 1e3).toString(),
    arrayFormat: apiMode == "v2" ? "repeat" : "indices"
  }).replace(/%5B/g, "[").replace(/%5D/g, "]");
}
const makeURLInterpolator = /* @__PURE__ */ (() => {
  const rc = {
    "\n": "\\n",
    '"': '\\"',
    "\u2028": "\\u2028",
    "\u2029": "\\u2029"
  };
  return (str) => {
    const cleanString = str.replace(/["\n\r\u2028\u2029]/g, ($0) => rc[$0]);
    return (outputs) => {
      return cleanString.replace(/\{([\s\S]+?)\}/g, ($0, $1) => {
        const output = outputs[$1];
        if (isValidEncodeUriComponentType(output))
          return encodeURIComponent(output);
        return "";
      });
    };
  };
})();
function isValidEncodeUriComponentType(value) {
  return ["number", "string", "boolean"].includes(typeof value);
}
function extractUrlParams(path) {
  const params = path.match(/\{\w+\}/g);
  if (!params) {
    return [];
  }
  return params.map((param) => param.replace(/[{}]/g, ""));
}
function getDataFromArgs(args) {
  if (!Array.isArray(args) || !args[0] || typeof args[0] !== "object") {
    return {};
  }
  if (!isOptionsHash(args[0])) {
    return args.shift();
  }
  const argKeys = Object.keys(args[0]);
  const optionKeysInArgs = argKeys.filter((key) => OPTIONS_KEYS.includes(key));
  if (optionKeysInArgs.length > 0 && optionKeysInArgs.length !== argKeys.length) {
    emitWarning(`Options found in arguments (${optionKeysInArgs.join(", ")}). Did you mean to pass an options object? See https://github.com/stripe/stripe-node/wiki/Passing-Options.`);
  }
  return {};
}
function getOptionsFromArgs(args) {
  const opts = {
    host: null,
    headers: {},
    settings: {},
    streaming: false
  };
  if (args.length > 0) {
    const arg = args[args.length - 1];
    if (typeof arg === "string") {
      opts.authenticator = createApiKeyAuthenticator(args.pop());
    } else if (isOptionsHash(arg)) {
      const params = Object.assign({}, args.pop());
      const extraKeys = Object.keys(params).filter((key) => !OPTIONS_KEYS.includes(key));
      if (extraKeys.length) {
        emitWarning(`Invalid options found (${extraKeys.join(", ")}); ignoring.`);
      }
      if (params.apiKey) {
        opts.authenticator = createApiKeyAuthenticator(params.apiKey);
      }
      if (params.idempotencyKey) {
        opts.headers["Idempotency-Key"] = params.idempotencyKey;
      }
      if (params.stripeAccount) {
        opts.headers["Stripe-Account"] = params.stripeAccount;
      }
      if (params.stripeContext) {
        if (opts.headers["Stripe-Account"]) {
          throw new Error("Can't specify both stripeAccount and stripeContext.");
        }
        opts.headers["Stripe-Context"] = params.stripeContext;
      }
      if (params.apiVersion) {
        opts.headers["Stripe-Version"] = params.apiVersion;
      }
      if (Number.isInteger(params.maxNetworkRetries)) {
        opts.settings.maxNetworkRetries = params.maxNetworkRetries;
      }
      if (Number.isInteger(params.timeout)) {
        opts.settings.timeout = params.timeout;
      }
      if (params.host) {
        opts.host = params.host;
      }
      if (params.authenticator) {
        if (params.apiKey) {
          throw new Error("Can't specify both apiKey and authenticator.");
        }
        if (typeof params.authenticator !== "function") {
          throw new Error("The authenticator must be a function receiving a request as the first parameter.");
        }
        opts.authenticator = params.authenticator;
      }
      if (params.additionalHeaders) {
        opts.headers = params.additionalHeaders;
      }
      if (params.streaming) {
        opts.streaming = true;
      }
    }
  }
  return opts;
}
function protoExtend(sub) {
  const Super = this;
  const Constructor = Object.prototype.hasOwnProperty.call(sub, "constructor") ? sub.constructor : function(...args) {
    Super.apply(this, args);
  };
  Object.assign(Constructor, Super);
  Constructor.prototype = Object.create(Super.prototype);
  Object.assign(Constructor.prototype, sub);
  return Constructor;
}
function removeNullish(obj) {
  if (typeof obj !== "object") {
    throw new Error("Argument must be an object");
  }
  return Object.keys(obj).reduce((result, key) => {
    if (obj[key] != null) {
      result[key] = obj[key];
    }
    return result;
  }, {});
}
function normalizeHeaders(obj) {
  if (!(obj && typeof obj === "object")) {
    return obj;
  }
  return Object.keys(obj).reduce((result, header) => {
    result[normalizeHeader(header)] = obj[header];
    return result;
  }, {});
}
function normalizeHeader(header) {
  return header.split("-").map((text) => text.charAt(0).toUpperCase() + text.substr(1).toLowerCase()).join("-");
}
function callbackifyPromiseWithTimeout(promise, callback) {
  if (callback) {
    return promise.then((res) => {
      setTimeout(() => {
        callback(null, res);
      }, 0);
    }, (err) => {
      setTimeout(() => {
        callback(err, null);
      }, 0);
    });
  }
  return promise;
}
function pascalToCamelCase(name) {
  if (name === "OAuth") {
    return "oauth";
  } else {
    return name[0].toLowerCase() + name.substring(1);
  }
}
function emitWarning(warning) {
  if (typeof process.emitWarning !== "function") {
    return console.warn(`Stripe: ${warning}`);
  }
  return process.emitWarning(warning, "Stripe");
}
function isObject$1(obj) {
  const type2 = typeof obj;
  return (type2 === "function" || type2 === "object") && !!obj;
}
function flattenAndStringify(data) {
  const result = {};
  const step = (obj, prevKey) => {
    Object.entries(obj).forEach(([key, value]) => {
      const newKey = prevKey ? `${prevKey}[${key}]` : key;
      if (isObject$1(value)) {
        if (!(value instanceof Uint8Array) && !Object.prototype.hasOwnProperty.call(value, "data")) {
          return step(value, newKey);
        } else {
          result[newKey] = value;
        }
      } else {
        result[newKey] = String(value);
      }
    });
  };
  step(data, null);
  return result;
}
function validateInteger(name, n2, defaultVal) {
  if (!Number.isInteger(n2)) {
    if (defaultVal !== void 0) {
      return defaultVal;
    } else {
      throw new Error(`${name} must be an integer`);
    }
  }
  return n2;
}
function determineProcessUserAgentProperties() {
  return typeof process === "undefined" ? {} : {
    lang_version: process.version,
    platform: process.platform
  };
}
function createApiKeyAuthenticator(apiKey) {
  const authenticator = (request) => {
    request.headers.Authorization = "Bearer " + apiKey;
    return Promise.resolve();
  };
  authenticator._apiKey = apiKey;
  return authenticator;
}
function dateTimeReplacer(key, value) {
  if (this[key] instanceof Date) {
    return Math.floor(this[key].getTime() / 1e3).toString();
  }
  return value;
}
function jsonStringifyRequestData(data) {
  return JSON.stringify(data, dateTimeReplacer);
}
function getAPIMode(path) {
  if (!path) {
    return "v1";
  }
  return path.startsWith("/v2") ? "v2" : "v1";
}
function parseHttpHeaderAsString(header) {
  if (Array.isArray(header)) {
    return header.join(", ");
  }
  return String(header);
}
function parseHttpHeaderAsNumber(header) {
  const number2 = Array.isArray(header) ? header[0] : header;
  return Number(number2);
}
function parseHeadersForFetch(headers) {
  return Object.entries(headers).map(([key, value]) => {
    return [key, parseHttpHeaderAsString(value)];
  });
}
class HttpClient {
  /** The client name used for diagnostics. */
  getClientName() {
    throw new Error("getClientName not implemented.");
  }
  makeRequest(host, port, path, method, headers, requestData, protocol, timeout) {
    throw new Error("makeRequest not implemented.");
  }
  /** Helper to make a consistent timeout error across implementations. */
  static makeTimeoutError() {
    const timeoutErr = new TypeError(HttpClient.TIMEOUT_ERROR_CODE);
    timeoutErr.code = HttpClient.TIMEOUT_ERROR_CODE;
    return timeoutErr;
  }
}
HttpClient.CONNECTION_CLOSED_ERROR_CODES = ["ECONNRESET", "EPIPE"];
HttpClient.TIMEOUT_ERROR_CODE = "ETIMEDOUT";
class HttpClientResponse {
  constructor(statusCode, headers) {
    this._statusCode = statusCode;
    this._headers = headers;
  }
  getStatusCode() {
    return this._statusCode;
  }
  getHeaders() {
    return this._headers;
  }
  getRawResponse() {
    throw new Error("getRawResponse not implemented.");
  }
  toStream(streamCompleteCallback) {
    throw new Error("toStream not implemented.");
  }
  toJSON() {
    throw new Error("toJSON not implemented.");
  }
}
class FetchHttpClient extends HttpClient {
  constructor(fetchFn) {
    super();
    if (!fetchFn) {
      if (!globalThis.fetch) {
        throw new Error("fetch() function not provided and is not defined in the global scope. You must provide a fetch implementation.");
      }
      fetchFn = globalThis.fetch;
    }
    if (globalThis.AbortController) {
      this._fetchFn = FetchHttpClient.makeFetchWithAbortTimeout(fetchFn);
    } else {
      this._fetchFn = FetchHttpClient.makeFetchWithRaceTimeout(fetchFn);
    }
  }
  static makeFetchWithRaceTimeout(fetchFn) {
    return (url, init, timeout) => {
      let pendingTimeoutId;
      const timeoutPromise = new Promise((_2, reject) => {
        pendingTimeoutId = setTimeout(() => {
          pendingTimeoutId = null;
          reject(HttpClient.makeTimeoutError());
        }, timeout);
      });
      const fetchPromise = fetchFn(url, init);
      return Promise.race([fetchPromise, timeoutPromise]).finally(() => {
        if (pendingTimeoutId) {
          clearTimeout(pendingTimeoutId);
        }
      });
    };
  }
  static makeFetchWithAbortTimeout(fetchFn) {
    return async (url, init, timeout) => {
      const abort = new AbortController();
      let timeoutId = setTimeout(() => {
        timeoutId = null;
        abort.abort(HttpClient.makeTimeoutError());
      }, timeout);
      try {
        return await fetchFn(url, Object.assign(Object.assign({}, init), { signal: abort.signal }));
      } catch (err) {
        if (err.name === "AbortError") {
          throw HttpClient.makeTimeoutError();
        } else {
          throw err;
        }
      } finally {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
      }
    };
  }
  /** @override. */
  getClientName() {
    return "fetch";
  }
  async makeRequest(host, port, path, method, headers, requestData, protocol, timeout) {
    const isInsecureConnection = protocol === "http";
    const url = new URL(path, `${isInsecureConnection ? "http" : "https"}://${host}`);
    url.port = port;
    const methodHasPayload = method == "POST" || method == "PUT" || method == "PATCH";
    const body = requestData || (methodHasPayload ? "" : void 0);
    const res = await this._fetchFn(url.toString(), {
      method,
      headers: parseHeadersForFetch(headers),
      body: typeof body === "object" ? JSON.stringify(body) : body
    }, timeout);
    return new FetchHttpClientResponse(res);
  }
}
class FetchHttpClientResponse extends HttpClientResponse {
  constructor(res) {
    super(res.status, FetchHttpClientResponse._transformHeadersToObject(res.headers));
    this._res = res;
  }
  getRawResponse() {
    return this._res;
  }
  toStream(streamCompleteCallback) {
    streamCompleteCallback();
    return this._res.body;
  }
  toJSON() {
    return this._res.json();
  }
  static _transformHeadersToObject(headers) {
    const headersObj = {};
    for (const entry2 of headers) {
      if (!Array.isArray(entry2) || entry2.length != 2) {
        throw new Error("Response objects produced by the fetch function given to FetchHttpClient do not have an iterable headers map. Response#headers should be an iterable object.");
      }
      headersObj[entry2[0]] = entry2[1];
    }
    return headersObj;
  }
}
class CryptoProvider {
  /**
   * Computes a SHA-256 HMAC given a secret and a payload (encoded in UTF-8).
   * The output HMAC should be encoded in hexadecimal.
   *
   * Sample values for implementations:
   * - computeHMACSignature('', 'test_secret') => 'f7f9bd47fb987337b5796fdc1fdb9ba221d0d5396814bfcaf9521f43fd8927fd'
   * - computeHMACSignature('\ud83d\ude00', 'test_secret') => '837da296d05c4fe31f61d5d7ead035099d9585a5bcde87de952012a78f0b0c43
   */
  computeHMACSignature(payload, secret) {
    throw new Error("computeHMACSignature not implemented.");
  }
  /**
   * Asynchronous version of `computeHMACSignature`. Some implementations may
   * only allow support async signature computation.
   *
   * Computes a SHA-256 HMAC given a secret and a payload (encoded in UTF-8).
   * The output HMAC should be encoded in hexadecimal.
   *
   * Sample values for implementations:
   * - computeHMACSignature('', 'test_secret') => 'f7f9bd47fb987337b5796fdc1fdb9ba221d0d5396814bfcaf9521f43fd8927fd'
   * - computeHMACSignature('\ud83d\ude00', 'test_secret') => '837da296d05c4fe31f61d5d7ead035099d9585a5bcde87de952012a78f0b0c43
   */
  computeHMACSignatureAsync(payload, secret) {
    throw new Error("computeHMACSignatureAsync not implemented.");
  }
  /**
   * Computes a SHA-256 hash of the data.
   */
  computeSHA256Async(data) {
    throw new Error("computeSHA256 not implemented.");
  }
}
class CryptoProviderOnlySupportsAsyncError extends Error {
}
class SubtleCryptoProvider extends CryptoProvider {
  constructor(subtleCrypto) {
    super();
    this.subtleCrypto = subtleCrypto || crypto.subtle;
  }
  /** @override */
  computeHMACSignature(payload, secret) {
    throw new CryptoProviderOnlySupportsAsyncError("SubtleCryptoProvider cannot be used in a synchronous context.");
  }
  /** @override */
  async computeHMACSignatureAsync(payload, secret) {
    const encoder = new TextEncoder();
    const key = await this.subtleCrypto.importKey("raw", encoder.encode(secret), {
      name: "HMAC",
      hash: { name: "SHA-256" }
    }, false, ["sign"]);
    const signatureBuffer = await this.subtleCrypto.sign("hmac", key, encoder.encode(payload));
    const signatureBytes = new Uint8Array(signatureBuffer);
    const signatureHexCodes = new Array(signatureBytes.length);
    for (let i2 = 0; i2 < signatureBytes.length; i2++) {
      signatureHexCodes[i2] = byteHexMapping[signatureBytes[i2]];
    }
    return signatureHexCodes.join("");
  }
  /** @override */
  async computeSHA256Async(data) {
    return new Uint8Array(await this.subtleCrypto.digest("SHA-256", data));
  }
}
const byteHexMapping = new Array(256);
for (let i2 = 0; i2 < byteHexMapping.length; i2++) {
  byteHexMapping[i2] = i2.toString(16).padStart(2, "0");
}
class PlatformFunctions {
  constructor() {
    this._fetchFn = null;
    this._agent = null;
  }
  /**
   * Gets uname with Node's built-in `exec` function, if available.
   */
  getUname() {
    throw new Error("getUname not implemented.");
  }
  /**
   * Generates a v4 UUID. See https://stackoverflow.com/a/2117523
   */
  uuid4() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c2) => {
      const r2 = Math.random() * 16 | 0;
      const v2 = c2 === "x" ? r2 : r2 & 3 | 8;
      return v2.toString(16);
    });
  }
  /**
   * Compares strings in constant time.
   */
  secureCompare(a2, b2) {
    if (a2.length !== b2.length) {
      return false;
    }
    const len = a2.length;
    let result = 0;
    for (let i2 = 0; i2 < len; ++i2) {
      result |= a2.charCodeAt(i2) ^ b2.charCodeAt(i2);
    }
    return result === 0;
  }
  /**
   * Creates an event emitter.
   */
  createEmitter() {
    throw new Error("createEmitter not implemented.");
  }
  /**
   * Checks if the request data is a stream. If so, read the entire stream
   * to a buffer and return the buffer.
   */
  tryBufferData(data) {
    throw new Error("tryBufferData not implemented.");
  }
  /**
   * Creates an HTTP client which uses the Node `http` and `https` packages
   * to issue requests.
   */
  createNodeHttpClient(agent) {
    throw new Error("createNodeHttpClient not implemented.");
  }
  /**
   * Creates an HTTP client for issuing Stripe API requests which uses the Web
   * Fetch API.
   *
   * A fetch function can optionally be passed in as a parameter. If none is
   * passed, will default to the default `fetch` function in the global scope.
   */
  createFetchHttpClient(fetchFn) {
    return new FetchHttpClient(fetchFn);
  }
  /**
   * Creates an HTTP client using runtime-specific APIs.
   */
  createDefaultHttpClient() {
    throw new Error("createDefaultHttpClient not implemented.");
  }
  /**
   * Creates a CryptoProvider which uses the Node `crypto` package for its computations.
   */
  createNodeCryptoProvider() {
    throw new Error("createNodeCryptoProvider not implemented.");
  }
  /**
   * Creates a CryptoProvider which uses the SubtleCrypto interface of the Web Crypto API.
   */
  createSubtleCryptoProvider(subtleCrypto) {
    return new SubtleCryptoProvider(subtleCrypto);
  }
  createDefaultCryptoProvider() {
    throw new Error("createDefaultCryptoProvider not implemented.");
  }
}
class _StripeEvent extends Event {
  constructor(eventName, data) {
    super(eventName);
    this.data = data;
  }
}
class StripeEmitter {
  constructor() {
    this.eventTarget = new EventTarget();
    this.listenerMapping = /* @__PURE__ */ new Map();
  }
  on(eventName, listener) {
    const listenerWrapper = (event) => {
      listener(event.data);
    };
    this.listenerMapping.set(listener, listenerWrapper);
    return this.eventTarget.addEventListener(eventName, listenerWrapper);
  }
  removeListener(eventName, listener) {
    const listenerWrapper = this.listenerMapping.get(listener);
    this.listenerMapping.delete(listener);
    return this.eventTarget.removeEventListener(eventName, listenerWrapper);
  }
  once(eventName, listener) {
    const listenerWrapper = (event) => {
      listener(event.data);
    };
    this.listenerMapping.set(listener, listenerWrapper);
    return this.eventTarget.addEventListener(eventName, listenerWrapper, {
      once: true
    });
  }
  emit(eventName, data) {
    return this.eventTarget.dispatchEvent(new _StripeEvent(eventName, data));
  }
}
class WebPlatformFunctions extends PlatformFunctions {
  /** @override */
  getUname() {
    return Promise.resolve(null);
  }
  /** @override */
  createEmitter() {
    return new StripeEmitter();
  }
  /** @override */
  tryBufferData(data) {
    if (data.file.data instanceof ReadableStream) {
      throw new Error("Uploading a file as a stream is not supported in non-Node environments. Please open or upvote an issue at github.com/stripe/stripe-node if you use this, detailing your use-case.");
    }
    return Promise.resolve(data);
  }
  /** @override */
  createNodeHttpClient() {
    throw new Error("Stripe: `createNodeHttpClient()` is not available in non-Node environments. Please use `createFetchHttpClient()` instead.");
  }
  /** @override */
  createDefaultHttpClient() {
    return super.createFetchHttpClient();
  }
  /** @override */
  createNodeCryptoProvider() {
    throw new Error("Stripe: `createNodeCryptoProvider()` is not available in non-Node environments. Please use `createSubtleCryptoProvider()` instead.");
  }
  /** @override */
  createDefaultCryptoProvider() {
    return this.createSubtleCryptoProvider();
  }
}
const generateV1Error = (rawStripeError) => {
  switch (rawStripeError.type) {
    case "card_error":
      return new StripeCardError(rawStripeError);
    case "invalid_request_error":
      return new StripeInvalidRequestError(rawStripeError);
    case "api_error":
      return new StripeAPIError(rawStripeError);
    case "authentication_error":
      return new StripeAuthenticationError(rawStripeError);
    case "rate_limit_error":
      return new StripeRateLimitError(rawStripeError);
    case "idempotency_error":
      return new StripeIdempotencyError(rawStripeError);
    case "invalid_grant":
      return new StripeInvalidGrantError(rawStripeError);
    default:
      return new StripeUnknownError(rawStripeError);
  }
};
const generateV2Error = (rawStripeError) => {
  switch (rawStripeError.type) {
    // switchCases: The beginning of the section generated from our OpenAPI spec
    case "temporary_session_expired":
      return new TemporarySessionExpiredError(rawStripeError);
  }
  switch (rawStripeError.code) {
    case "invalid_fields":
      return new StripeInvalidRequestError(rawStripeError);
  }
  return generateV1Error(rawStripeError);
};
class StripeError extends Error {
  constructor(raw = {}, type2 = null) {
    var _a;
    super(raw.message);
    this.type = type2 || this.constructor.name;
    this.raw = raw;
    this.rawType = raw.type;
    this.code = raw.code;
    this.doc_url = raw.doc_url;
    this.param = raw.param;
    this.detail = raw.detail;
    this.headers = raw.headers;
    this.requestId = raw.requestId;
    this.statusCode = raw.statusCode;
    this.message = (_a = raw.message) !== null && _a !== void 0 ? _a : "";
    this.userMessage = raw.user_message;
    this.charge = raw.charge;
    this.decline_code = raw.decline_code;
    this.payment_intent = raw.payment_intent;
    this.payment_method = raw.payment_method;
    this.payment_method_type = raw.payment_method_type;
    this.setup_intent = raw.setup_intent;
    this.source = raw.source;
  }
}
StripeError.generate = generateV1Error;
class StripeCardError extends StripeError {
  constructor(raw = {}) {
    super(raw, "StripeCardError");
  }
}
class StripeInvalidRequestError extends StripeError {
  constructor(raw = {}) {
    super(raw, "StripeInvalidRequestError");
  }
}
class StripeAPIError extends StripeError {
  constructor(raw = {}) {
    super(raw, "StripeAPIError");
  }
}
class StripeAuthenticationError extends StripeError {
  constructor(raw = {}) {
    super(raw, "StripeAuthenticationError");
  }
}
class StripePermissionError extends StripeError {
  constructor(raw = {}) {
    super(raw, "StripePermissionError");
  }
}
class StripeRateLimitError extends StripeError {
  constructor(raw = {}) {
    super(raw, "StripeRateLimitError");
  }
}
class StripeConnectionError extends StripeError {
  constructor(raw = {}) {
    super(raw, "StripeConnectionError");
  }
}
class StripeSignatureVerificationError extends StripeError {
  constructor(header, payload, raw = {}) {
    super(raw, "StripeSignatureVerificationError");
    this.header = header;
    this.payload = payload;
  }
}
class StripeIdempotencyError extends StripeError {
  constructor(raw = {}) {
    super(raw, "StripeIdempotencyError");
  }
}
class StripeInvalidGrantError extends StripeError {
  constructor(raw = {}) {
    super(raw, "StripeInvalidGrantError");
  }
}
class StripeUnknownError extends StripeError {
  constructor(raw = {}) {
    super(raw, "StripeUnknownError");
  }
}
class TemporarySessionExpiredError extends StripeError {
  constructor(rawStripeError = {}) {
    super(rawStripeError, "TemporarySessionExpiredError");
  }
}
const _Error = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  StripeAPIError,
  StripeAuthenticationError,
  StripeCardError,
  StripeConnectionError,
  StripeError,
  StripeIdempotencyError,
  StripeInvalidGrantError,
  StripeInvalidRequestError,
  StripePermissionError,
  StripeRateLimitError,
  StripeSignatureVerificationError,
  StripeUnknownError,
  TemporarySessionExpiredError,
  generateV1Error,
  generateV2Error
}, Symbol.toStringTag, { value: "Module" }));
const MAX_RETRY_AFTER_WAIT = 60;
class RequestSender {
  constructor(stripe, maxBufferedRequestMetric) {
    this._stripe = stripe;
    this._maxBufferedRequestMetric = maxBufferedRequestMetric;
  }
  _addHeadersDirectlyToObject(obj, headers) {
    obj.requestId = headers["request-id"];
    obj.stripeAccount = obj.stripeAccount || headers["stripe-account"];
    obj.apiVersion = obj.apiVersion || headers["stripe-version"];
    obj.idempotencyKey = obj.idempotencyKey || headers["idempotency-key"];
  }
  _makeResponseEvent(requestEvent, statusCode, headers) {
    const requestEndTime = Date.now();
    const requestDurationMs = requestEndTime - requestEvent.request_start_time;
    return removeNullish({
      api_version: headers["stripe-version"],
      account: headers["stripe-account"],
      idempotency_key: headers["idempotency-key"],
      method: requestEvent.method,
      path: requestEvent.path,
      status: statusCode,
      request_id: this._getRequestId(headers),
      elapsed: requestDurationMs,
      request_start_time: requestEvent.request_start_time,
      request_end_time: requestEndTime
    });
  }
  _getRequestId(headers) {
    return headers["request-id"];
  }
  /**
   * Used by methods with spec.streaming === true. For these methods, we do not
   * buffer successful responses into memory or do parse them into stripe
   * objects, we delegate that all of that to the user and pass back the raw
   * http.Response object to the callback.
   *
   * (Unsuccessful responses shouldn't make it here, they should
   * still be buffered/parsed and handled by _jsonResponseHandler -- see
   * makeRequest)
   */
  _streamingResponseHandler(requestEvent, usage, callback) {
    return (res) => {
      const headers = res.getHeaders();
      const streamCompleteCallback = () => {
        const responseEvent = this._makeResponseEvent(requestEvent, res.getStatusCode(), headers);
        this._stripe._emitter.emit("response", responseEvent);
        this._recordRequestMetrics(this._getRequestId(headers), responseEvent.elapsed, usage);
      };
      const stream = res.toStream(streamCompleteCallback);
      this._addHeadersDirectlyToObject(stream, headers);
      return callback(null, stream);
    };
  }
  /**
   * Default handler for Stripe responses. Buffers the response into memory,
   * parses the JSON and returns it (i.e. passes it to the callback) if there
   * is no "error" field. Otherwise constructs/passes an appropriate Error.
   */
  _jsonResponseHandler(requestEvent, apiMode, usage, callback) {
    return (res) => {
      const headers = res.getHeaders();
      const requestId = this._getRequestId(headers);
      const statusCode = res.getStatusCode();
      const responseEvent = this._makeResponseEvent(requestEvent, statusCode, headers);
      this._stripe._emitter.emit("response", responseEvent);
      res.toJSON().then((jsonResponse) => {
        if (jsonResponse.error) {
          let err;
          if (typeof jsonResponse.error === "string") {
            jsonResponse.error = {
              type: jsonResponse.error,
              message: jsonResponse.error_description
            };
          }
          jsonResponse.error.headers = headers;
          jsonResponse.error.statusCode = statusCode;
          jsonResponse.error.requestId = requestId;
          if (statusCode === 401) {
            err = new StripeAuthenticationError(jsonResponse.error);
          } else if (statusCode === 403) {
            err = new StripePermissionError(jsonResponse.error);
          } else if (statusCode === 429) {
            err = new StripeRateLimitError(jsonResponse.error);
          } else if (apiMode === "v2") {
            err = generateV2Error(jsonResponse.error);
          } else {
            err = generateV1Error(jsonResponse.error);
          }
          throw err;
        }
        return jsonResponse;
      }, (e2) => {
        throw new StripeAPIError({
          message: "Invalid JSON received from the Stripe API",
          exception: e2,
          requestId: headers["request-id"]
        });
      }).then((jsonResponse) => {
        this._recordRequestMetrics(requestId, responseEvent.elapsed, usage);
        const rawResponse = res.getRawResponse();
        this._addHeadersDirectlyToObject(rawResponse, headers);
        Object.defineProperty(jsonResponse, "lastResponse", {
          enumerable: false,
          writable: false,
          value: rawResponse
        });
        callback(null, jsonResponse);
      }, (e2) => callback(e2, null));
    };
  }
  static _generateConnectionErrorMessage(requestRetries) {
    return `An error occurred with our connection to Stripe.${requestRetries > 0 ? ` Request was retried ${requestRetries} times.` : ""}`;
  }
  // For more on when and how to retry API requests, see https://stripe.com/docs/error-handling#safely-retrying-requests-with-idempotency
  static _shouldRetry(res, numRetries, maxRetries, error) {
    if (error && numRetries === 0 && HttpClient.CONNECTION_CLOSED_ERROR_CODES.includes(error.code)) {
      return true;
    }
    if (numRetries >= maxRetries) {
      return false;
    }
    if (!res) {
      return true;
    }
    if (res.getHeaders()["stripe-should-retry"] === "false") {
      return false;
    }
    if (res.getHeaders()["stripe-should-retry"] === "true") {
      return true;
    }
    if (res.getStatusCode() === 409) {
      return true;
    }
    if (res.getStatusCode() >= 500) {
      return true;
    }
    return false;
  }
  _getSleepTimeInMS(numRetries, retryAfter = null) {
    const initialNetworkRetryDelay = this._stripe.getInitialNetworkRetryDelay();
    const maxNetworkRetryDelay = this._stripe.getMaxNetworkRetryDelay();
    let sleepSeconds = Math.min(initialNetworkRetryDelay * Math.pow(2, numRetries - 1), maxNetworkRetryDelay);
    sleepSeconds *= 0.5 * (1 + Math.random());
    sleepSeconds = Math.max(initialNetworkRetryDelay, sleepSeconds);
    if (Number.isInteger(retryAfter) && retryAfter <= MAX_RETRY_AFTER_WAIT) {
      sleepSeconds = Math.max(sleepSeconds, retryAfter);
    }
    return sleepSeconds * 1e3;
  }
  // Max retries can be set on a per request basis. Favor those over the global setting
  _getMaxNetworkRetries(settings = {}) {
    return settings.maxNetworkRetries !== void 0 && Number.isInteger(settings.maxNetworkRetries) ? settings.maxNetworkRetries : this._stripe.getMaxNetworkRetries();
  }
  _defaultIdempotencyKey(method, settings, apiMode) {
    const maxRetries = this._getMaxNetworkRetries(settings);
    const genKey = () => `stripe-node-retry-${this._stripe._platformFunctions.uuid4()}`;
    if (apiMode === "v2") {
      if (method === "POST" || method === "DELETE") {
        return genKey();
      }
    } else if (apiMode === "v1") {
      if (method === "POST" && maxRetries > 0) {
        return genKey();
      }
    }
    return null;
  }
  _makeHeaders({ contentType, contentLength, apiVersion, clientUserAgent, method, userSuppliedHeaders, userSuppliedSettings, stripeAccount, stripeContext, apiMode }) {
    const defaultHeaders = {
      Accept: "application/json",
      "Content-Type": contentType,
      "User-Agent": this._getUserAgentString(apiMode),
      "X-Stripe-Client-User-Agent": clientUserAgent,
      "X-Stripe-Client-Telemetry": this._getTelemetryHeader(),
      "Stripe-Version": apiVersion,
      "Stripe-Account": stripeAccount,
      "Stripe-Context": stripeContext,
      "Idempotency-Key": this._defaultIdempotencyKey(method, userSuppliedSettings, apiMode)
    };
    const methodHasPayload = method == "POST" || method == "PUT" || method == "PATCH";
    if (methodHasPayload || contentLength) {
      if (!methodHasPayload) {
        emitWarning(`${method} method had non-zero contentLength but no payload is expected for this verb`);
      }
      defaultHeaders["Content-Length"] = contentLength;
    }
    return Object.assign(
      removeNullish(defaultHeaders),
      // If the user supplied, say 'idempotency-key', override instead of appending by ensuring caps are the same.
      normalizeHeaders(userSuppliedHeaders)
    );
  }
  _getUserAgentString(apiMode) {
    const packageVersion = this._stripe.getConstant("PACKAGE_VERSION");
    const appInfo = this._stripe._appInfo ? this._stripe.getAppInfoAsString() : "";
    return `Stripe/${apiMode} NodeBindings/${packageVersion} ${appInfo}`.trim();
  }
  _getTelemetryHeader() {
    if (this._stripe.getTelemetryEnabled() && this._stripe._prevRequestMetrics.length > 0) {
      const metrics = this._stripe._prevRequestMetrics.shift();
      return JSON.stringify({
        last_request_metrics: metrics
      });
    }
  }
  _recordRequestMetrics(requestId, requestDurationMs, usage) {
    if (this._stripe.getTelemetryEnabled() && requestId) {
      if (this._stripe._prevRequestMetrics.length > this._maxBufferedRequestMetric) {
        emitWarning("Request metrics buffer is full, dropping telemetry message.");
      } else {
        const m2 = {
          request_id: requestId,
          request_duration_ms: requestDurationMs
        };
        if (usage && usage.length > 0) {
          m2.usage = usage;
        }
        this._stripe._prevRequestMetrics.push(m2);
      }
    }
  }
  _rawRequest(method, path, params, options) {
    const requestPromise = new Promise((resolve, reject) => {
      let opts;
      try {
        const requestMethod = method.toUpperCase();
        if (requestMethod !== "POST" && params && Object.keys(params).length !== 0) {
          throw new Error("rawRequest only supports params on POST requests. Please pass null and add your parameters to path.");
        }
        const args = [].slice.call([params, options]);
        const dataFromArgs = getDataFromArgs(args);
        const data = requestMethod === "POST" ? Object.assign({}, dataFromArgs) : null;
        const calculatedOptions = getOptionsFromArgs(args);
        const headers2 = calculatedOptions.headers;
        const authenticator2 = calculatedOptions.authenticator;
        opts = {
          requestMethod,
          requestPath: path,
          bodyData: data,
          queryData: {},
          authenticator: authenticator2,
          headers: headers2,
          host: calculatedOptions.host,
          streaming: !!calculatedOptions.streaming,
          settings: {},
          usage: ["raw_request"]
        };
      } catch (err) {
        reject(err);
        return;
      }
      function requestCallback(err, response) {
        if (err) {
          reject(err);
        } else {
          resolve(response);
        }
      }
      const { headers, settings } = opts;
      const authenticator = opts.authenticator;
      this._request(opts.requestMethod, opts.host, path, opts.bodyData, authenticator, { headers, settings, streaming: opts.streaming }, opts.usage, requestCallback);
    });
    return requestPromise;
  }
  _request(method, host, path, data, authenticator, options, usage = [], callback, requestDataProcessor = null) {
    var _a;
    let requestData;
    authenticator = (_a = authenticator !== null && authenticator !== void 0 ? authenticator : this._stripe._authenticator) !== null && _a !== void 0 ? _a : null;
    const apiMode = getAPIMode(path);
    const retryRequest = (requestFn, apiVersion, headers, requestRetries, retryAfter) => {
      return setTimeout(requestFn, this._getSleepTimeInMS(requestRetries, retryAfter), apiVersion, headers, requestRetries + 1);
    };
    const makeRequest = (apiVersion, headers, numRetries) => {
      const timeout = options.settings && options.settings.timeout && Number.isInteger(options.settings.timeout) && options.settings.timeout >= 0 ? options.settings.timeout : this._stripe.getApiField("timeout");
      const request = {
        host: host || this._stripe.getApiField("host"),
        port: this._stripe.getApiField("port"),
        path,
        method,
        headers: Object.assign({}, headers),
        body: requestData,
        protocol: this._stripe.getApiField("protocol")
      };
      authenticator(request).then(() => {
        const req = this._stripe.getApiField("httpClient").makeRequest(request.host, request.port, request.path, request.method, request.headers, request.body, request.protocol, timeout);
        const requestStartTime = Date.now();
        const requestEvent = removeNullish({
          api_version: apiVersion,
          account: parseHttpHeaderAsString(headers["Stripe-Account"]),
          idempotency_key: parseHttpHeaderAsString(headers["Idempotency-Key"]),
          method,
          path,
          request_start_time: requestStartTime
        });
        const requestRetries = numRetries || 0;
        const maxRetries = this._getMaxNetworkRetries(options.settings || {});
        this._stripe._emitter.emit("request", requestEvent);
        req.then((res) => {
          if (RequestSender._shouldRetry(res, requestRetries, maxRetries)) {
            return retryRequest(makeRequest, apiVersion, headers, requestRetries, parseHttpHeaderAsNumber(res.getHeaders()["retry-after"]));
          } else if (options.streaming && res.getStatusCode() < 400) {
            return this._streamingResponseHandler(requestEvent, usage, callback)(res);
          } else {
            return this._jsonResponseHandler(requestEvent, apiMode, usage, callback)(res);
          }
        }).catch((error) => {
          if (RequestSender._shouldRetry(null, requestRetries, maxRetries, error)) {
            return retryRequest(makeRequest, apiVersion, headers, requestRetries, null);
          } else {
            const isTimeoutError = error.code && error.code === HttpClient.TIMEOUT_ERROR_CODE;
            return callback(new StripeConnectionError({
              message: isTimeoutError ? `Request aborted due to timeout being reached (${timeout}ms)` : RequestSender._generateConnectionErrorMessage(requestRetries),
              detail: error
            }));
          }
        });
      }).catch((e2) => {
        throw new StripeError({
          message: "Unable to authenticate the request",
          exception: e2
        });
      });
    };
    const prepareAndMakeRequest = (error, data2) => {
      if (error) {
        return callback(error);
      }
      requestData = data2;
      this._stripe.getClientUserAgent((clientUserAgent) => {
        const apiVersion = this._stripe.getApiField("version");
        const headers = this._makeHeaders({
          contentType: apiMode == "v2" ? "application/json" : "application/x-www-form-urlencoded",
          contentLength: requestData.length,
          apiVersion,
          clientUserAgent,
          method,
          userSuppliedHeaders: options.headers,
          userSuppliedSettings: options.settings,
          stripeAccount: apiMode == "v2" ? null : this._stripe.getApiField("stripeAccount"),
          stripeContext: apiMode == "v2" ? this._stripe.getApiField("stripeContext") : null,
          apiMode
        });
        makeRequest(apiVersion, headers, 0);
      });
    };
    if (requestDataProcessor) {
      requestDataProcessor(method, data, options.headers, prepareAndMakeRequest);
    } else {
      let stringifiedData;
      if (apiMode == "v2") {
        stringifiedData = data ? jsonStringifyRequestData(data) : "";
      } else {
        stringifiedData = queryStringifyRequestData(data || {}, apiMode);
      }
      prepareAndMakeRequest(null, stringifiedData);
    }
  }
}
class V1Iterator {
  constructor(firstPagePromise, requestArgs, spec, stripeResource) {
    this.index = 0;
    this.pagePromise = firstPagePromise;
    this.promiseCache = { currentPromise: null };
    this.requestArgs = requestArgs;
    this.spec = spec;
    this.stripeResource = stripeResource;
  }
  async iterate(pageResult) {
    if (!(pageResult && pageResult.data && typeof pageResult.data.length === "number")) {
      throw Error("Unexpected: Stripe API response does not have a well-formed `data` array.");
    }
    const reverseIteration = isReverseIteration(this.requestArgs);
    if (this.index < pageResult.data.length) {
      const idx = reverseIteration ? pageResult.data.length - 1 - this.index : this.index;
      const value = pageResult.data[idx];
      this.index += 1;
      return { value, done: false };
    } else if (pageResult.has_more) {
      this.index = 0;
      this.pagePromise = this.getNextPage(pageResult);
      const nextPageResult = await this.pagePromise;
      return this.iterate(nextPageResult);
    }
    return { done: true, value: void 0 };
  }
  /** @abstract */
  getNextPage(_pageResult) {
    throw new Error("Unimplemented");
  }
  async _next() {
    return this.iterate(await this.pagePromise);
  }
  next() {
    if (this.promiseCache.currentPromise) {
      return this.promiseCache.currentPromise;
    }
    const nextPromise = (async () => {
      const ret = await this._next();
      this.promiseCache.currentPromise = null;
      return ret;
    })();
    this.promiseCache.currentPromise = nextPromise;
    return nextPromise;
  }
}
class V1ListIterator extends V1Iterator {
  getNextPage(pageResult) {
    const reverseIteration = isReverseIteration(this.requestArgs);
    const lastId = getLastId(pageResult, reverseIteration);
    return this.stripeResource._makeRequest(this.requestArgs, this.spec, {
      [reverseIteration ? "ending_before" : "starting_after"]: lastId
    });
  }
}
class V1SearchIterator extends V1Iterator {
  getNextPage(pageResult) {
    if (!pageResult.next_page) {
      throw Error("Unexpected: Stripe API response does not have a well-formed `next_page` field, but `has_more` was true.");
    }
    return this.stripeResource._makeRequest(this.requestArgs, this.spec, {
      page: pageResult.next_page
    });
  }
}
class V2ListIterator {
  constructor(firstPagePromise, requestArgs, spec, stripeResource) {
    this.currentPageIterator = (async () => {
      const page = await firstPagePromise;
      return page.data[Symbol.iterator]();
    })();
    this.nextPageUrl = (async () => {
      const page = await firstPagePromise;
      return page.next_page_url || null;
    })();
    this.requestArgs = requestArgs;
    this.spec = spec;
    this.stripeResource = stripeResource;
  }
  async turnPage() {
    const nextPageUrl = await this.nextPageUrl;
    if (!nextPageUrl)
      return null;
    this.spec.fullPath = nextPageUrl;
    const page = await this.stripeResource._makeRequest([], this.spec, {});
    this.nextPageUrl = Promise.resolve(page.next_page_url);
    this.currentPageIterator = Promise.resolve(page.data[Symbol.iterator]());
    return this.currentPageIterator;
  }
  async next() {
    {
      const result2 = (await this.currentPageIterator).next();
      if (!result2.done)
        return { done: false, value: result2.value };
    }
    const nextPageIterator = await this.turnPage();
    if (!nextPageIterator) {
      return { done: true, value: void 0 };
    }
    const result = nextPageIterator.next();
    if (!result.done)
      return { done: false, value: result.value };
    return { done: true, value: void 0 };
  }
}
const makeAutoPaginationMethods = (stripeResource, requestArgs, spec, firstPagePromise) => {
  const apiMode = getAPIMode(spec.fullPath || spec.path);
  if (apiMode !== "v2" && spec.methodType === "search") {
    return makeAutoPaginationMethodsFromIterator(new V1SearchIterator(firstPagePromise, requestArgs, spec, stripeResource));
  }
  if (apiMode !== "v2" && spec.methodType === "list") {
    return makeAutoPaginationMethodsFromIterator(new V1ListIterator(firstPagePromise, requestArgs, spec, stripeResource));
  }
  if (apiMode === "v2" && spec.methodType === "list") {
    return makeAutoPaginationMethodsFromIterator(new V2ListIterator(firstPagePromise, requestArgs, spec, stripeResource));
  }
  return null;
};
const makeAutoPaginationMethodsFromIterator = (iterator) => {
  const autoPagingEach = makeAutoPagingEach((...args) => iterator.next(...args));
  const autoPagingToArray = makeAutoPagingToArray(autoPagingEach);
  const autoPaginationMethods = {
    autoPagingEach,
    autoPagingToArray,
    // Async iterator functions:
    next: () => iterator.next(),
    return: () => {
      return {};
    },
    [getAsyncIteratorSymbol()]: () => {
      return autoPaginationMethods;
    }
  };
  return autoPaginationMethods;
};
function getAsyncIteratorSymbol() {
  if (typeof Symbol !== "undefined" && Symbol.asyncIterator) {
    return Symbol.asyncIterator;
  }
  return "@@asyncIterator";
}
function getDoneCallback(args) {
  if (args.length < 2) {
    return null;
  }
  const onDone = args[1];
  if (typeof onDone !== "function") {
    throw Error(`The second argument to autoPagingEach, if present, must be a callback function; received ${typeof onDone}`);
  }
  return onDone;
}
function getItemCallback(args) {
  if (args.length === 0) {
    return void 0;
  }
  const onItem = args[0];
  if (typeof onItem !== "function") {
    throw Error(`The first argument to autoPagingEach, if present, must be a callback function; received ${typeof onItem}`);
  }
  if (onItem.length === 2) {
    return onItem;
  }
  if (onItem.length > 2) {
    throw Error(`The \`onItem\` callback function passed to autoPagingEach must accept at most two arguments; got ${onItem}`);
  }
  return function _onItem(item, next) {
    const shouldContinue = onItem(item);
    next(shouldContinue);
  };
}
function getLastId(listResult, reverseIteration) {
  const lastIdx = reverseIteration ? 0 : listResult.data.length - 1;
  const lastItem = listResult.data[lastIdx];
  const lastId = lastItem && lastItem.id;
  if (!lastId) {
    throw Error("Unexpected: No `id` found on the last item while auto-paging a list.");
  }
  return lastId;
}
function makeAutoPagingEach(asyncIteratorNext) {
  return function autoPagingEach() {
    const args = [].slice.call(arguments);
    const onItem = getItemCallback(args);
    const onDone = getDoneCallback(args);
    if (args.length > 2) {
      throw Error(`autoPagingEach takes up to two arguments; received ${args}`);
    }
    const autoPagePromise = wrapAsyncIteratorWithCallback(
      asyncIteratorNext,
      // @ts-ignore we might need a null check
      onItem
    );
    return callbackifyPromiseWithTimeout(autoPagePromise, onDone);
  };
}
function makeAutoPagingToArray(autoPagingEach) {
  return function autoPagingToArray(opts, onDone) {
    const limit = opts && opts.limit;
    if (!limit) {
      throw Error("You must pass a `limit` option to autoPagingToArray, e.g., `autoPagingToArray({limit: 1000});`.");
    }
    if (limit > 1e4) {
      throw Error("You cannot specify a limit of more than 10,000 items to fetch in `autoPagingToArray`; use `autoPagingEach` to iterate through longer lists.");
    }
    const promise = new Promise((resolve, reject) => {
      const items = [];
      autoPagingEach((item) => {
        items.push(item);
        if (items.length >= limit) {
          return false;
        }
      }).then(() => {
        resolve(items);
      }).catch(reject);
    });
    return callbackifyPromiseWithTimeout(promise, onDone);
  };
}
function wrapAsyncIteratorWithCallback(asyncIteratorNext, onItem) {
  return new Promise((resolve, reject) => {
    function handleIteration(iterResult) {
      if (iterResult.done) {
        resolve();
        return;
      }
      const item = iterResult.value;
      return new Promise((next) => {
        onItem(item, next);
      }).then((shouldContinue) => {
        if (shouldContinue === false) {
          return handleIteration({ done: true, value: void 0 });
        } else {
          return asyncIteratorNext().then(handleIteration);
        }
      });
    }
    asyncIteratorNext().then(handleIteration).catch(reject);
  });
}
function isReverseIteration(requestArgs) {
  const args = [].slice.call(requestArgs);
  const dataFromArgs = getDataFromArgs(args);
  return !!dataFromArgs.ending_before;
}
function stripeMethod$1$(spec) {
  if (spec.path !== void 0 && spec.fullPath !== void 0) {
    throw new Error(`Method spec specified both a 'path' (${spec.path}) and a 'fullPath' (${spec.fullPath}).`);
  }
  return function(...args) {
    const callback = typeof args[args.length - 1] == "function" && args.pop();
    spec.urlParams = extractUrlParams(spec.fullPath || this.createResourcePathWithSymbols(spec.path || ""));
    const requestPromise = callbackifyPromiseWithTimeout(this._makeRequest(args, spec, {}), callback);
    Object.assign(requestPromise, makeAutoPaginationMethods(this, args, spec, requestPromise));
    return requestPromise;
  };
}
StripeResource.extend = protoExtend;
StripeResource.method = stripeMethod$1$;
StripeResource.MAX_BUFFERED_REQUEST_METRICS = 100;
function StripeResource(stripe, deprecatedUrlData) {
  this._stripe = stripe;
  if (deprecatedUrlData) {
    throw new Error("Support for curried url params was dropped in stripe-node v7.0.0. Instead, pass two ids.");
  }
  this.basePath = makeURLInterpolator(
    // @ts-ignore changing type of basePath
    this.basePath || stripe.getApiField("basePath")
  );
  this.resourcePath = this.path;
  this.path = makeURLInterpolator(this.path);
  this.initialize(...arguments);
}
StripeResource.prototype = {
  _stripe: null,
  // @ts-ignore the type of path changes in ctor
  path: "",
  resourcePath: "",
  // Methods that don't use the API's default '/v1' path can override it with this setting.
  basePath: null,
  initialize() {
  },
  // Function to override the default data processor. This allows full control
  // over how a StripeResource's request data will get converted into an HTTP
  // body. This is useful for non-standard HTTP requests. The function should
  // take method name, data, and headers as arguments.
  requestDataProcessor: null,
  // Function to add a validation checks before sending the request, errors should
  // be thrown, and they will be passed to the callback/promise.
  validateRequest: null,
  createFullPath(commandPath, urlData) {
    const urlParts = [this.basePath(urlData), this.path(urlData)];
    if (typeof commandPath === "function") {
      const computedCommandPath = commandPath(urlData);
      if (computedCommandPath) {
        urlParts.push(computedCommandPath);
      }
    } else {
      urlParts.push(commandPath);
    }
    return this._joinUrlParts(urlParts);
  },
  // Creates a relative resource path with symbols left in (unlike
  // createFullPath which takes some data to replace them with). For example it
  // might produce: /invoices/{id}
  createResourcePathWithSymbols(pathWithSymbols) {
    if (pathWithSymbols) {
      return `/${this._joinUrlParts([this.resourcePath, pathWithSymbols])}`;
    } else {
      return `/${this.resourcePath}`;
    }
  },
  _joinUrlParts(parts) {
    return parts.join("/").replace(/\/{2,}/g, "/");
  },
  _getRequestOpts(requestArgs, spec, overrideData) {
    var _a;
    const requestMethod = (spec.method || "GET").toUpperCase();
    const usage = spec.usage || [];
    const urlParams = spec.urlParams || [];
    const encode = spec.encode || ((data2) => data2);
    const isUsingFullPath = !!spec.fullPath;
    const commandPath = makeURLInterpolator(isUsingFullPath ? spec.fullPath : spec.path || "");
    const path = isUsingFullPath ? spec.fullPath : this.createResourcePathWithSymbols(spec.path);
    const args = [].slice.call(requestArgs);
    const urlData = urlParams.reduce((urlData2, param) => {
      const arg = args.shift();
      if (typeof arg !== "string") {
        throw new Error(`Stripe: Argument "${param}" must be a string, but got: ${arg} (on API request to \`${requestMethod} ${path}\`)`);
      }
      urlData2[param] = arg;
      return urlData2;
    }, {});
    const dataFromArgs = getDataFromArgs(args);
    const data = encode(Object.assign({}, dataFromArgs, overrideData));
    const options = getOptionsFromArgs(args);
    const host = options.host || spec.host;
    const streaming = !!spec.streaming || !!options.streaming;
    if (args.filter((x2) => x2 != null).length) {
      throw new Error(`Stripe: Unknown arguments (${args}). Did you mean to pass an options object? See https://github.com/stripe/stripe-node/wiki/Passing-Options. (on API request to ${requestMethod} \`${path}\`)`);
    }
    const requestPath = isUsingFullPath ? commandPath(urlData) : this.createFullPath(commandPath, urlData);
    const headers = Object.assign(options.headers, spec.headers);
    if (spec.validator) {
      spec.validator(data, { headers });
    }
    const dataInQuery = spec.method === "GET" || spec.method === "DELETE";
    const bodyData = dataInQuery ? null : data;
    const queryData = dataInQuery ? data : {};
    return {
      requestMethod,
      requestPath,
      bodyData,
      queryData,
      authenticator: (_a = options.authenticator) !== null && _a !== void 0 ? _a : null,
      headers,
      host: host !== null && host !== void 0 ? host : null,
      streaming,
      settings: options.settings,
      usage
    };
  },
  _makeRequest(requestArgs, spec, overrideData) {
    return new Promise((resolve, reject) => {
      var _a;
      let opts;
      try {
        opts = this._getRequestOpts(requestArgs, spec, overrideData);
      } catch (err) {
        reject(err);
        return;
      }
      function requestCallback(err, response) {
        if (err) {
          reject(err);
        } else {
          resolve(spec.transformResponseData ? spec.transformResponseData(response) : response);
        }
      }
      const emptyQuery = Object.keys(opts.queryData).length === 0;
      const path = [
        opts.requestPath,
        emptyQuery ? "" : "?",
        queryStringifyRequestData(opts.queryData, getAPIMode(opts.requestPath))
      ].join("");
      const { headers, settings } = opts;
      this._stripe._requestSender._request(opts.requestMethod, opts.host, path, opts.bodyData, opts.authenticator, {
        headers,
        settings,
        streaming: opts.streaming
      }, opts.usage, requestCallback, (_a = this.requestDataProcessor) === null || _a === void 0 ? void 0 : _a.bind(this));
    });
  }
};
function createWebhooks(platformFunctions) {
  const Webhook = {
    DEFAULT_TOLERANCE: 300,
    signature: null,
    constructEvent(payload, header, secret, tolerance, cryptoProvider, receivedAt) {
      try {
        if (!this.signature) {
          throw new Error("ERR: missing signature helper, unable to verify");
        }
        this.signature.verifyHeader(payload, header, secret, tolerance || Webhook.DEFAULT_TOLERANCE, cryptoProvider, receivedAt);
      } catch (e2) {
        if (e2 instanceof CryptoProviderOnlySupportsAsyncError) {
          e2.message += "\nUse `await constructEventAsync(...)` instead of `constructEvent(...)`";
        }
        throw e2;
      }
      const jsonPayload = payload instanceof Uint8Array ? JSON.parse(new TextDecoder("utf8").decode(payload)) : JSON.parse(payload);
      return jsonPayload;
    },
    async constructEventAsync(payload, header, secret, tolerance, cryptoProvider, receivedAt) {
      if (!this.signature) {
        throw new Error("ERR: missing signature helper, unable to verify");
      }
      await this.signature.verifyHeaderAsync(payload, header, secret, tolerance || Webhook.DEFAULT_TOLERANCE, cryptoProvider, receivedAt);
      const jsonPayload = payload instanceof Uint8Array ? JSON.parse(new TextDecoder("utf8").decode(payload)) : JSON.parse(payload);
      return jsonPayload;
    },
    /**
     * Generates a header to be used for webhook mocking
     *
     * @typedef {object} opts
     * @property {number} timestamp - Timestamp of the header. Defaults to Date.now()
     * @property {string} payload - JSON stringified payload object, containing the 'id' and 'object' parameters
     * @property {string} secret - Stripe webhook secret 'whsec_...'
     * @property {string} scheme - Version of API to hit. Defaults to 'v1'.
     * @property {string} signature - Computed webhook signature
     * @property {CryptoProvider} cryptoProvider - Crypto provider to use for computing the signature if none was provided. Defaults to NodeCryptoProvider.
     */
    generateTestHeaderString: function(opts) {
      const preparedOpts = prepareOptions(opts);
      const signature2 = preparedOpts.signature || preparedOpts.cryptoProvider.computeHMACSignature(preparedOpts.payloadString, preparedOpts.secret);
      return preparedOpts.generateHeaderString(signature2);
    },
    generateTestHeaderStringAsync: async function(opts) {
      const preparedOpts = prepareOptions(opts);
      const signature2 = preparedOpts.signature || await preparedOpts.cryptoProvider.computeHMACSignatureAsync(preparedOpts.payloadString, preparedOpts.secret);
      return preparedOpts.generateHeaderString(signature2);
    }
  };
  const signature = {
    EXPECTED_SCHEME: "v1",
    verifyHeader(encodedPayload, encodedHeader, secret, tolerance, cryptoProvider, receivedAt) {
      const { decodedHeader: header, decodedPayload: payload, details, suspectPayloadType } = parseEventDetails(encodedPayload, encodedHeader, this.EXPECTED_SCHEME);
      const secretContainsWhitespace = /\s/.test(secret);
      cryptoProvider = cryptoProvider || getCryptoProvider();
      const expectedSignature = cryptoProvider.computeHMACSignature(makeHMACContent(payload, details), secret);
      validateComputedSignature(payload, header, details, expectedSignature, tolerance, suspectPayloadType, secretContainsWhitespace, receivedAt);
      return true;
    },
    async verifyHeaderAsync(encodedPayload, encodedHeader, secret, tolerance, cryptoProvider, receivedAt) {
      const { decodedHeader: header, decodedPayload: payload, details, suspectPayloadType } = parseEventDetails(encodedPayload, encodedHeader, this.EXPECTED_SCHEME);
      const secretContainsWhitespace = /\s/.test(secret);
      cryptoProvider = cryptoProvider || getCryptoProvider();
      const expectedSignature = await cryptoProvider.computeHMACSignatureAsync(makeHMACContent(payload, details), secret);
      return validateComputedSignature(payload, header, details, expectedSignature, tolerance, suspectPayloadType, secretContainsWhitespace, receivedAt);
    }
  };
  function makeHMACContent(payload, details) {
    return `${details.timestamp}.${payload}`;
  }
  function parseEventDetails(encodedPayload, encodedHeader, expectedScheme) {
    if (!encodedPayload) {
      throw new StripeSignatureVerificationError(encodedHeader, encodedPayload, {
        message: "No webhook payload was provided."
      });
    }
    const suspectPayloadType = typeof encodedPayload != "string" && !(encodedPayload instanceof Uint8Array);
    const textDecoder = new TextDecoder("utf8");
    const decodedPayload = encodedPayload instanceof Uint8Array ? textDecoder.decode(encodedPayload) : encodedPayload;
    if (Array.isArray(encodedHeader)) {
      throw new Error("Unexpected: An array was passed as a header, which should not be possible for the stripe-signature header.");
    }
    if (encodedHeader == null || encodedHeader == "") {
      throw new StripeSignatureVerificationError(encodedHeader, encodedPayload, {
        message: "No stripe-signature header value was provided."
      });
    }
    const decodedHeader = encodedHeader instanceof Uint8Array ? textDecoder.decode(encodedHeader) : encodedHeader;
    const details = parseHeader(decodedHeader, expectedScheme);
    if (!details || details.timestamp === -1) {
      throw new StripeSignatureVerificationError(decodedHeader, decodedPayload, {
        message: "Unable to extract timestamp and signatures from header"
      });
    }
    if (!details.signatures.length) {
      throw new StripeSignatureVerificationError(decodedHeader, decodedPayload, {
        message: "No signatures found with expected scheme"
      });
    }
    return {
      decodedPayload,
      decodedHeader,
      details,
      suspectPayloadType
    };
  }
  function validateComputedSignature(payload, header, details, expectedSignature, tolerance, suspectPayloadType, secretContainsWhitespace, receivedAt) {
    const signatureFound = !!details.signatures.filter(platformFunctions.secureCompare.bind(platformFunctions, expectedSignature)).length;
    const docsLocation = "\nLearn more about webhook signing and explore webhook integration examples for various frameworks at https://docs.stripe.com/webhooks/signature";
    const whitespaceMessage = secretContainsWhitespace ? "\n\nNote: The provided signing secret contains whitespace. This often indicates an extra newline or space is in the value" : "";
    if (!signatureFound) {
      if (suspectPayloadType) {
        throw new StripeSignatureVerificationError(header, payload, {
          message: "Webhook payload must be provided as a string or a Buffer (https://nodejs.org/api/buffer.html) instance representing the _raw_ request body.Payload was provided as a parsed JavaScript object instead. \nSignature verification is impossible without access to the original signed material. \n" + docsLocation + "\n" + whitespaceMessage
        });
      }
      throw new StripeSignatureVerificationError(header, payload, {
        message: "No signatures found matching the expected signature for payload. Are you passing the raw request body you received from Stripe? \n If a webhook request is being forwarded by a third-party tool, ensure that the exact request body, including JSON formatting and new line style, is preserved.\n" + docsLocation + "\n" + whitespaceMessage
      });
    }
    const timestampAge = Math.floor((typeof receivedAt === "number" ? receivedAt : Date.now()) / 1e3) - details.timestamp;
    if (tolerance > 0 && timestampAge > tolerance) {
      throw new StripeSignatureVerificationError(header, payload, {
        message: "Timestamp outside the tolerance zone"
      });
    }
    return true;
  }
  function parseHeader(header, scheme) {
    if (typeof header !== "string") {
      return null;
    }
    return header.split(",").reduce((accum, item) => {
      const kv = item.split("=");
      if (kv[0] === "t") {
        accum.timestamp = parseInt(kv[1], 10);
      }
      if (kv[0] === scheme) {
        accum.signatures.push(kv[1]);
      }
      return accum;
    }, {
      timestamp: -1,
      signatures: []
    });
  }
  let webhooksCryptoProviderInstance = null;
  function getCryptoProvider() {
    if (!webhooksCryptoProviderInstance) {
      webhooksCryptoProviderInstance = platformFunctions.createDefaultCryptoProvider();
    }
    return webhooksCryptoProviderInstance;
  }
  function prepareOptions(opts) {
    if (!opts) {
      throw new StripeError({
        message: "Options are required"
      });
    }
    const timestamp = Math.floor(opts.timestamp) || Math.floor(Date.now() / 1e3);
    const scheme = opts.scheme || signature.EXPECTED_SCHEME;
    const cryptoProvider = opts.cryptoProvider || getCryptoProvider();
    const payloadString = `${timestamp}.${opts.payload}`;
    const generateHeaderString = (signature2) => {
      return `t=${timestamp},${scheme}=${signature2}`;
    };
    return Object.assign(Object.assign({}, opts), {
      timestamp,
      scheme,
      cryptoProvider,
      payloadString,
      generateHeaderString
    });
  }
  Webhook.signature = signature;
  return Webhook;
}
const ApiVersion = "2025-05-28.basil";
function ResourceNamespace(stripe, resources2) {
  for (const name in resources2) {
    if (!Object.prototype.hasOwnProperty.call(resources2, name)) {
      continue;
    }
    const camelCaseName = name[0].toLowerCase() + name.substring(1);
    const resource = new resources2[name](stripe);
    this[camelCaseName] = resource;
  }
}
function resourceNamespace(namespace, resources2) {
  return function(stripe) {
    return new ResourceNamespace(stripe, resources2);
  };
}
const stripeMethod$1_ = StripeResource.method;
const Accounts$1 = StripeResource.extend({
  retrieve: stripeMethod$1_({
    method: "GET",
    fullPath: "/v1/financial_connections/accounts/{account}"
  }),
  list: stripeMethod$1_({
    method: "GET",
    fullPath: "/v1/financial_connections/accounts",
    methodType: "list"
  }),
  disconnect: stripeMethod$1_({
    method: "POST",
    fullPath: "/v1/financial_connections/accounts/{account}/disconnect"
  }),
  listOwners: stripeMethod$1_({
    method: "GET",
    fullPath: "/v1/financial_connections/accounts/{account}/owners",
    methodType: "list"
  }),
  refresh: stripeMethod$1_({
    method: "POST",
    fullPath: "/v1/financial_connections/accounts/{account}/refresh"
  }),
  subscribe: stripeMethod$1_({
    method: "POST",
    fullPath: "/v1/financial_connections/accounts/{account}/subscribe"
  }),
  unsubscribe: stripeMethod$1_({
    method: "POST",
    fullPath: "/v1/financial_connections/accounts/{account}/unsubscribe"
  })
});
const stripeMethod$1Z = StripeResource.method;
const ActiveEntitlements = StripeResource.extend({
  retrieve: stripeMethod$1Z({
    method: "GET",
    fullPath: "/v1/entitlements/active_entitlements/{id}"
  }),
  list: stripeMethod$1Z({
    method: "GET",
    fullPath: "/v1/entitlements/active_entitlements",
    methodType: "list"
  })
});
const stripeMethod$1Y = StripeResource.method;
const Alerts = StripeResource.extend({
  create: stripeMethod$1Y({ method: "POST", fullPath: "/v1/billing/alerts" }),
  retrieve: stripeMethod$1Y({ method: "GET", fullPath: "/v1/billing/alerts/{id}" }),
  list: stripeMethod$1Y({
    method: "GET",
    fullPath: "/v1/billing/alerts",
    methodType: "list"
  }),
  activate: stripeMethod$1Y({
    method: "POST",
    fullPath: "/v1/billing/alerts/{id}/activate"
  }),
  archive: stripeMethod$1Y({
    method: "POST",
    fullPath: "/v1/billing/alerts/{id}/archive"
  }),
  deactivate: stripeMethod$1Y({
    method: "POST",
    fullPath: "/v1/billing/alerts/{id}/deactivate"
  })
});
const stripeMethod$1X = StripeResource.method;
const Authorizations$1 = StripeResource.extend({
  create: stripeMethod$1X({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/authorizations"
  }),
  capture: stripeMethod$1X({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/authorizations/{authorization}/capture"
  }),
  expire: stripeMethod$1X({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/authorizations/{authorization}/expire"
  }),
  finalizeAmount: stripeMethod$1X({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/authorizations/{authorization}/finalize_amount"
  }),
  increment: stripeMethod$1X({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/authorizations/{authorization}/increment"
  }),
  respond: stripeMethod$1X({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/authorizations/{authorization}/fraud_challenges/respond"
  }),
  reverse: stripeMethod$1X({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/authorizations/{authorization}/reverse"
  })
});
const stripeMethod$1W = StripeResource.method;
const Authorizations = StripeResource.extend({
  retrieve: stripeMethod$1W({
    method: "GET",
    fullPath: "/v1/issuing/authorizations/{authorization}"
  }),
  update: stripeMethod$1W({
    method: "POST",
    fullPath: "/v1/issuing/authorizations/{authorization}"
  }),
  list: stripeMethod$1W({
    method: "GET",
    fullPath: "/v1/issuing/authorizations",
    methodType: "list"
  }),
  approve: stripeMethod$1W({
    method: "POST",
    fullPath: "/v1/issuing/authorizations/{authorization}/approve"
  }),
  decline: stripeMethod$1W({
    method: "POST",
    fullPath: "/v1/issuing/authorizations/{authorization}/decline"
  })
});
const stripeMethod$1V = StripeResource.method;
const Calculations = StripeResource.extend({
  create: stripeMethod$1V({ method: "POST", fullPath: "/v1/tax/calculations" }),
  retrieve: stripeMethod$1V({
    method: "GET",
    fullPath: "/v1/tax/calculations/{calculation}"
  }),
  listLineItems: stripeMethod$1V({
    method: "GET",
    fullPath: "/v1/tax/calculations/{calculation}/line_items",
    methodType: "list"
  })
});
const stripeMethod$1U = StripeResource.method;
const Cardholders = StripeResource.extend({
  create: stripeMethod$1U({ method: "POST", fullPath: "/v1/issuing/cardholders" }),
  retrieve: stripeMethod$1U({
    method: "GET",
    fullPath: "/v1/issuing/cardholders/{cardholder}"
  }),
  update: stripeMethod$1U({
    method: "POST",
    fullPath: "/v1/issuing/cardholders/{cardholder}"
  }),
  list: stripeMethod$1U({
    method: "GET",
    fullPath: "/v1/issuing/cardholders",
    methodType: "list"
  })
});
const stripeMethod$1T = StripeResource.method;
const Cards$1 = StripeResource.extend({
  deliverCard: stripeMethod$1T({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/cards/{card}/shipping/deliver"
  }),
  failCard: stripeMethod$1T({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/cards/{card}/shipping/fail"
  }),
  returnCard: stripeMethod$1T({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/cards/{card}/shipping/return"
  }),
  shipCard: stripeMethod$1T({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/cards/{card}/shipping/ship"
  }),
  submitCard: stripeMethod$1T({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/cards/{card}/shipping/submit"
  })
});
const stripeMethod$1S = StripeResource.method;
const Cards = StripeResource.extend({
  create: stripeMethod$1S({ method: "POST", fullPath: "/v1/issuing/cards" }),
  retrieve: stripeMethod$1S({ method: "GET", fullPath: "/v1/issuing/cards/{card}" }),
  update: stripeMethod$1S({ method: "POST", fullPath: "/v1/issuing/cards/{card}" }),
  list: stripeMethod$1S({
    method: "GET",
    fullPath: "/v1/issuing/cards",
    methodType: "list"
  })
});
const stripeMethod$1R = StripeResource.method;
const Configurations$1 = StripeResource.extend({
  create: stripeMethod$1R({
    method: "POST",
    fullPath: "/v1/billing_portal/configurations"
  }),
  retrieve: stripeMethod$1R({
    method: "GET",
    fullPath: "/v1/billing_portal/configurations/{configuration}"
  }),
  update: stripeMethod$1R({
    method: "POST",
    fullPath: "/v1/billing_portal/configurations/{configuration}"
  }),
  list: stripeMethod$1R({
    method: "GET",
    fullPath: "/v1/billing_portal/configurations",
    methodType: "list"
  })
});
const stripeMethod$1Q = StripeResource.method;
const Configurations = StripeResource.extend({
  create: stripeMethod$1Q({
    method: "POST",
    fullPath: "/v1/terminal/configurations"
  }),
  retrieve: stripeMethod$1Q({
    method: "GET",
    fullPath: "/v1/terminal/configurations/{configuration}"
  }),
  update: stripeMethod$1Q({
    method: "POST",
    fullPath: "/v1/terminal/configurations/{configuration}"
  }),
  list: stripeMethod$1Q({
    method: "GET",
    fullPath: "/v1/terminal/configurations",
    methodType: "list"
  }),
  del: stripeMethod$1Q({
    method: "DELETE",
    fullPath: "/v1/terminal/configurations/{configuration}"
  })
});
const stripeMethod$1P = StripeResource.method;
const ConfirmationTokens$1 = StripeResource.extend({
  create: stripeMethod$1P({
    method: "POST",
    fullPath: "/v1/test_helpers/confirmation_tokens"
  })
});
const stripeMethod$1O = StripeResource.method;
const ConnectionTokens = StripeResource.extend({
  create: stripeMethod$1O({
    method: "POST",
    fullPath: "/v1/terminal/connection_tokens"
  })
});
const stripeMethod$1N = StripeResource.method;
const CreditBalanceSummary = StripeResource.extend({
  retrieve: stripeMethod$1N({
    method: "GET",
    fullPath: "/v1/billing/credit_balance_summary"
  })
});
const stripeMethod$1M = StripeResource.method;
const CreditBalanceTransactions = StripeResource.extend({
  retrieve: stripeMethod$1M({
    method: "GET",
    fullPath: "/v1/billing/credit_balance_transactions/{id}"
  }),
  list: stripeMethod$1M({
    method: "GET",
    fullPath: "/v1/billing/credit_balance_transactions",
    methodType: "list"
  })
});
const stripeMethod$1L = StripeResource.method;
const CreditGrants = StripeResource.extend({
  create: stripeMethod$1L({ method: "POST", fullPath: "/v1/billing/credit_grants" }),
  retrieve: stripeMethod$1L({
    method: "GET",
    fullPath: "/v1/billing/credit_grants/{id}"
  }),
  update: stripeMethod$1L({
    method: "POST",
    fullPath: "/v1/billing/credit_grants/{id}"
  }),
  list: stripeMethod$1L({
    method: "GET",
    fullPath: "/v1/billing/credit_grants",
    methodType: "list"
  }),
  expire: stripeMethod$1L({
    method: "POST",
    fullPath: "/v1/billing/credit_grants/{id}/expire"
  }),
  voidGrant: stripeMethod$1L({
    method: "POST",
    fullPath: "/v1/billing/credit_grants/{id}/void"
  })
});
const stripeMethod$1K = StripeResource.method;
const CreditReversals = StripeResource.extend({
  create: stripeMethod$1K({
    method: "POST",
    fullPath: "/v1/treasury/credit_reversals"
  }),
  retrieve: stripeMethod$1K({
    method: "GET",
    fullPath: "/v1/treasury/credit_reversals/{credit_reversal}"
  }),
  list: stripeMethod$1K({
    method: "GET",
    fullPath: "/v1/treasury/credit_reversals",
    methodType: "list"
  })
});
const stripeMethod$1J = StripeResource.method;
const Customers$1 = StripeResource.extend({
  fundCashBalance: stripeMethod$1J({
    method: "POST",
    fullPath: "/v1/test_helpers/customers/{customer}/fund_cash_balance"
  })
});
const stripeMethod$1I = StripeResource.method;
const DebitReversals = StripeResource.extend({
  create: stripeMethod$1I({
    method: "POST",
    fullPath: "/v1/treasury/debit_reversals"
  }),
  retrieve: stripeMethod$1I({
    method: "GET",
    fullPath: "/v1/treasury/debit_reversals/{debit_reversal}"
  }),
  list: stripeMethod$1I({
    method: "GET",
    fullPath: "/v1/treasury/debit_reversals",
    methodType: "list"
  })
});
const stripeMethod$1H = StripeResource.method;
const Disputes$1 = StripeResource.extend({
  create: stripeMethod$1H({ method: "POST", fullPath: "/v1/issuing/disputes" }),
  retrieve: stripeMethod$1H({
    method: "GET",
    fullPath: "/v1/issuing/disputes/{dispute}"
  }),
  update: stripeMethod$1H({
    method: "POST",
    fullPath: "/v1/issuing/disputes/{dispute}"
  }),
  list: stripeMethod$1H({
    method: "GET",
    fullPath: "/v1/issuing/disputes",
    methodType: "list"
  }),
  submit: stripeMethod$1H({
    method: "POST",
    fullPath: "/v1/issuing/disputes/{dispute}/submit"
  })
});
const stripeMethod$1G = StripeResource.method;
const EarlyFraudWarnings = StripeResource.extend({
  retrieve: stripeMethod$1G({
    method: "GET",
    fullPath: "/v1/radar/early_fraud_warnings/{early_fraud_warning}"
  }),
  list: stripeMethod$1G({
    method: "GET",
    fullPath: "/v1/radar/early_fraud_warnings",
    methodType: "list"
  })
});
const stripeMethod$1F = StripeResource.method;
const EventDestinations = StripeResource.extend({
  create: stripeMethod$1F({
    method: "POST",
    fullPath: "/v2/core/event_destinations"
  }),
  retrieve: stripeMethod$1F({
    method: "GET",
    fullPath: "/v2/core/event_destinations/{id}"
  }),
  update: stripeMethod$1F({
    method: "POST",
    fullPath: "/v2/core/event_destinations/{id}"
  }),
  list: stripeMethod$1F({
    method: "GET",
    fullPath: "/v2/core/event_destinations",
    methodType: "list"
  }),
  del: stripeMethod$1F({
    method: "DELETE",
    fullPath: "/v2/core/event_destinations/{id}"
  }),
  disable: stripeMethod$1F({
    method: "POST",
    fullPath: "/v2/core/event_destinations/{id}/disable"
  }),
  enable: stripeMethod$1F({
    method: "POST",
    fullPath: "/v2/core/event_destinations/{id}/enable"
  }),
  ping: stripeMethod$1F({
    method: "POST",
    fullPath: "/v2/core/event_destinations/{id}/ping"
  })
});
const stripeMethod$1E = StripeResource.method;
const Events$1 = StripeResource.extend({
  retrieve(...args) {
    const transformResponseData = (response) => {
      return this.addFetchRelatedObjectIfNeeded(response);
    };
    return stripeMethod$1E({
      method: "GET",
      fullPath: "/v2/core/events/{id}",
      transformResponseData
    }).apply(this, args);
  },
  list(...args) {
    const transformResponseData = (response) => {
      return Object.assign(Object.assign({}, response), { data: response.data.map(this.addFetchRelatedObjectIfNeeded.bind(this)) });
    };
    return stripeMethod$1E({
      method: "GET",
      fullPath: "/v2/core/events",
      methodType: "list",
      transformResponseData
    }).apply(this, args);
  },
  /**
   * @private
   *
   * For internal use in stripe-node.
   *
   * @param pulledEvent The retrieved event object
   * @returns The retrieved event object with a fetchRelatedObject method,
   * if pulledEvent.related_object is valid (non-null and has a url)
   */
  addFetchRelatedObjectIfNeeded(pulledEvent) {
    if (!pulledEvent.related_object || !pulledEvent.related_object.url) {
      return pulledEvent;
    }
    return Object.assign(Object.assign({}, pulledEvent), { fetchRelatedObject: () => (
      // call stripeMethod with 'this' resource to fetch
      // the related object. 'this' is needed to construct
      // and send the request, but the method spec controls
      // the url endpoint and method, so it doesn't matter
      // that 'this' is an Events resource object here
      stripeMethod$1E({
        method: "GET",
        fullPath: pulledEvent.related_object.url
      }).apply(this, [
        {
          stripeAccount: pulledEvent.context
        }
      ])
    ) });
  }
});
const stripeMethod$1D = StripeResource.method;
const Features = StripeResource.extend({
  create: stripeMethod$1D({ method: "POST", fullPath: "/v1/entitlements/features" }),
  retrieve: stripeMethod$1D({
    method: "GET",
    fullPath: "/v1/entitlements/features/{id}"
  }),
  update: stripeMethod$1D({
    method: "POST",
    fullPath: "/v1/entitlements/features/{id}"
  }),
  list: stripeMethod$1D({
    method: "GET",
    fullPath: "/v1/entitlements/features",
    methodType: "list"
  })
});
const stripeMethod$1C = StripeResource.method;
const FinancialAccounts = StripeResource.extend({
  create: stripeMethod$1C({
    method: "POST",
    fullPath: "/v1/treasury/financial_accounts"
  }),
  retrieve: stripeMethod$1C({
    method: "GET",
    fullPath: "/v1/treasury/financial_accounts/{financial_account}"
  }),
  update: stripeMethod$1C({
    method: "POST",
    fullPath: "/v1/treasury/financial_accounts/{financial_account}"
  }),
  list: stripeMethod$1C({
    method: "GET",
    fullPath: "/v1/treasury/financial_accounts",
    methodType: "list"
  }),
  close: stripeMethod$1C({
    method: "POST",
    fullPath: "/v1/treasury/financial_accounts/{financial_account}/close"
  }),
  retrieveFeatures: stripeMethod$1C({
    method: "GET",
    fullPath: "/v1/treasury/financial_accounts/{financial_account}/features"
  }),
  updateFeatures: stripeMethod$1C({
    method: "POST",
    fullPath: "/v1/treasury/financial_accounts/{financial_account}/features"
  })
});
const stripeMethod$1B = StripeResource.method;
const InboundTransfers$1 = StripeResource.extend({
  fail: stripeMethod$1B({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/inbound_transfers/{id}/fail"
  }),
  returnInboundTransfer: stripeMethod$1B({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/inbound_transfers/{id}/return"
  }),
  succeed: stripeMethod$1B({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/inbound_transfers/{id}/succeed"
  })
});
const stripeMethod$1A = StripeResource.method;
const InboundTransfers = StripeResource.extend({
  create: stripeMethod$1A({
    method: "POST",
    fullPath: "/v1/treasury/inbound_transfers"
  }),
  retrieve: stripeMethod$1A({
    method: "GET",
    fullPath: "/v1/treasury/inbound_transfers/{id}"
  }),
  list: stripeMethod$1A({
    method: "GET",
    fullPath: "/v1/treasury/inbound_transfers",
    methodType: "list"
  }),
  cancel: stripeMethod$1A({
    method: "POST",
    fullPath: "/v1/treasury/inbound_transfers/{inbound_transfer}/cancel"
  })
});
const stripeMethod$1z = StripeResource.method;
const Locations = StripeResource.extend({
  create: stripeMethod$1z({ method: "POST", fullPath: "/v1/terminal/locations" }),
  retrieve: stripeMethod$1z({
    method: "GET",
    fullPath: "/v1/terminal/locations/{location}"
  }),
  update: stripeMethod$1z({
    method: "POST",
    fullPath: "/v1/terminal/locations/{location}"
  }),
  list: stripeMethod$1z({
    method: "GET",
    fullPath: "/v1/terminal/locations",
    methodType: "list"
  }),
  del: stripeMethod$1z({
    method: "DELETE",
    fullPath: "/v1/terminal/locations/{location}"
  })
});
const stripeMethod$1y = StripeResource.method;
const MeterEventAdjustments$1 = StripeResource.extend({
  create: stripeMethod$1y({
    method: "POST",
    fullPath: "/v1/billing/meter_event_adjustments"
  })
});
const stripeMethod$1x = StripeResource.method;
const MeterEventAdjustments = StripeResource.extend({
  create: stripeMethod$1x({
    method: "POST",
    fullPath: "/v2/billing/meter_event_adjustments"
  })
});
const stripeMethod$1w = StripeResource.method;
const MeterEventSession = StripeResource.extend({
  create: stripeMethod$1w({
    method: "POST",
    fullPath: "/v2/billing/meter_event_session"
  })
});
const stripeMethod$1v = StripeResource.method;
const MeterEventStream = StripeResource.extend({
  create: stripeMethod$1v({
    method: "POST",
    fullPath: "/v2/billing/meter_event_stream",
    host: "meter-events.stripe.com"
  })
});
const stripeMethod$1u = StripeResource.method;
const MeterEvents$1 = StripeResource.extend({
  create: stripeMethod$1u({ method: "POST", fullPath: "/v1/billing/meter_events" })
});
const stripeMethod$1t = StripeResource.method;
const MeterEvents = StripeResource.extend({
  create: stripeMethod$1t({ method: "POST", fullPath: "/v2/billing/meter_events" })
});
const stripeMethod$1s = StripeResource.method;
const Meters = StripeResource.extend({
  create: stripeMethod$1s({ method: "POST", fullPath: "/v1/billing/meters" }),
  retrieve: stripeMethod$1s({ method: "GET", fullPath: "/v1/billing/meters/{id}" }),
  update: stripeMethod$1s({ method: "POST", fullPath: "/v1/billing/meters/{id}" }),
  list: stripeMethod$1s({
    method: "GET",
    fullPath: "/v1/billing/meters",
    methodType: "list"
  }),
  deactivate: stripeMethod$1s({
    method: "POST",
    fullPath: "/v1/billing/meters/{id}/deactivate"
  }),
  listEventSummaries: stripeMethod$1s({
    method: "GET",
    fullPath: "/v1/billing/meters/{id}/event_summaries",
    methodType: "list"
  }),
  reactivate: stripeMethod$1s({
    method: "POST",
    fullPath: "/v1/billing/meters/{id}/reactivate"
  })
});
const stripeMethod$1r = StripeResource.method;
const Orders = StripeResource.extend({
  create: stripeMethod$1r({ method: "POST", fullPath: "/v1/climate/orders" }),
  retrieve: stripeMethod$1r({
    method: "GET",
    fullPath: "/v1/climate/orders/{order}"
  }),
  update: stripeMethod$1r({
    method: "POST",
    fullPath: "/v1/climate/orders/{order}"
  }),
  list: stripeMethod$1r({
    method: "GET",
    fullPath: "/v1/climate/orders",
    methodType: "list"
  }),
  cancel: stripeMethod$1r({
    method: "POST",
    fullPath: "/v1/climate/orders/{order}/cancel"
  })
});
const stripeMethod$1q = StripeResource.method;
const OutboundPayments$1 = StripeResource.extend({
  update: stripeMethod$1q({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/outbound_payments/{id}"
  }),
  fail: stripeMethod$1q({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/outbound_payments/{id}/fail"
  }),
  post: stripeMethod$1q({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/outbound_payments/{id}/post"
  }),
  returnOutboundPayment: stripeMethod$1q({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/outbound_payments/{id}/return"
  })
});
const stripeMethod$1p = StripeResource.method;
const OutboundPayments = StripeResource.extend({
  create: stripeMethod$1p({
    method: "POST",
    fullPath: "/v1/treasury/outbound_payments"
  }),
  retrieve: stripeMethod$1p({
    method: "GET",
    fullPath: "/v1/treasury/outbound_payments/{id}"
  }),
  list: stripeMethod$1p({
    method: "GET",
    fullPath: "/v1/treasury/outbound_payments",
    methodType: "list"
  }),
  cancel: stripeMethod$1p({
    method: "POST",
    fullPath: "/v1/treasury/outbound_payments/{id}/cancel"
  })
});
const stripeMethod$1o = StripeResource.method;
const OutboundTransfers$1 = StripeResource.extend({
  update: stripeMethod$1o({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}"
  }),
  fail: stripeMethod$1o({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}/fail"
  }),
  post: stripeMethod$1o({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}/post"
  }),
  returnOutboundTransfer: stripeMethod$1o({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}/return"
  })
});
const stripeMethod$1n = StripeResource.method;
const OutboundTransfers = StripeResource.extend({
  create: stripeMethod$1n({
    method: "POST",
    fullPath: "/v1/treasury/outbound_transfers"
  }),
  retrieve: stripeMethod$1n({
    method: "GET",
    fullPath: "/v1/treasury/outbound_transfers/{outbound_transfer}"
  }),
  list: stripeMethod$1n({
    method: "GET",
    fullPath: "/v1/treasury/outbound_transfers",
    methodType: "list"
  }),
  cancel: stripeMethod$1n({
    method: "POST",
    fullPath: "/v1/treasury/outbound_transfers/{outbound_transfer}/cancel"
  })
});
const stripeMethod$1m = StripeResource.method;
const PersonalizationDesigns$1 = StripeResource.extend({
  activate: stripeMethod$1m({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/personalization_designs/{personalization_design}/activate"
  }),
  deactivate: stripeMethod$1m({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/personalization_designs/{personalization_design}/deactivate"
  }),
  reject: stripeMethod$1m({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/personalization_designs/{personalization_design}/reject"
  })
});
const stripeMethod$1l = StripeResource.method;
const PersonalizationDesigns = StripeResource.extend({
  create: stripeMethod$1l({
    method: "POST",
    fullPath: "/v1/issuing/personalization_designs"
  }),
  retrieve: stripeMethod$1l({
    method: "GET",
    fullPath: "/v1/issuing/personalization_designs/{personalization_design}"
  }),
  update: stripeMethod$1l({
    method: "POST",
    fullPath: "/v1/issuing/personalization_designs/{personalization_design}"
  }),
  list: stripeMethod$1l({
    method: "GET",
    fullPath: "/v1/issuing/personalization_designs",
    methodType: "list"
  })
});
const stripeMethod$1k = StripeResource.method;
const PhysicalBundles = StripeResource.extend({
  retrieve: stripeMethod$1k({
    method: "GET",
    fullPath: "/v1/issuing/physical_bundles/{physical_bundle}"
  }),
  list: stripeMethod$1k({
    method: "GET",
    fullPath: "/v1/issuing/physical_bundles",
    methodType: "list"
  })
});
const stripeMethod$1j = StripeResource.method;
const Products$1 = StripeResource.extend({
  retrieve: stripeMethod$1j({
    method: "GET",
    fullPath: "/v1/climate/products/{product}"
  }),
  list: stripeMethod$1j({
    method: "GET",
    fullPath: "/v1/climate/products",
    methodType: "list"
  })
});
const stripeMethod$1i = StripeResource.method;
const Readers$1 = StripeResource.extend({
  presentPaymentMethod: stripeMethod$1i({
    method: "POST",
    fullPath: "/v1/test_helpers/terminal/readers/{reader}/present_payment_method"
  }),
  succeedInputCollection: stripeMethod$1i({
    method: "POST",
    fullPath: "/v1/test_helpers/terminal/readers/{reader}/succeed_input_collection"
  }),
  timeoutInputCollection: stripeMethod$1i({
    method: "POST",
    fullPath: "/v1/test_helpers/terminal/readers/{reader}/timeout_input_collection"
  })
});
const stripeMethod$1h = StripeResource.method;
const Readers = StripeResource.extend({
  create: stripeMethod$1h({ method: "POST", fullPath: "/v1/terminal/readers" }),
  retrieve: stripeMethod$1h({
    method: "GET",
    fullPath: "/v1/terminal/readers/{reader}"
  }),
  update: stripeMethod$1h({
    method: "POST",
    fullPath: "/v1/terminal/readers/{reader}"
  }),
  list: stripeMethod$1h({
    method: "GET",
    fullPath: "/v1/terminal/readers",
    methodType: "list"
  }),
  del: stripeMethod$1h({
    method: "DELETE",
    fullPath: "/v1/terminal/readers/{reader}"
  }),
  cancelAction: stripeMethod$1h({
    method: "POST",
    fullPath: "/v1/terminal/readers/{reader}/cancel_action"
  }),
  collectInputs: stripeMethod$1h({
    method: "POST",
    fullPath: "/v1/terminal/readers/{reader}/collect_inputs"
  }),
  processPaymentIntent: stripeMethod$1h({
    method: "POST",
    fullPath: "/v1/terminal/readers/{reader}/process_payment_intent"
  }),
  processSetupIntent: stripeMethod$1h({
    method: "POST",
    fullPath: "/v1/terminal/readers/{reader}/process_setup_intent"
  }),
  refundPayment: stripeMethod$1h({
    method: "POST",
    fullPath: "/v1/terminal/readers/{reader}/refund_payment"
  }),
  setReaderDisplay: stripeMethod$1h({
    method: "POST",
    fullPath: "/v1/terminal/readers/{reader}/set_reader_display"
  })
});
const stripeMethod$1g = StripeResource.method;
const ReceivedCredits$1 = StripeResource.extend({
  create: stripeMethod$1g({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/received_credits"
  })
});
const stripeMethod$1f = StripeResource.method;
const ReceivedCredits = StripeResource.extend({
  retrieve: stripeMethod$1f({
    method: "GET",
    fullPath: "/v1/treasury/received_credits/{id}"
  }),
  list: stripeMethod$1f({
    method: "GET",
    fullPath: "/v1/treasury/received_credits",
    methodType: "list"
  })
});
const stripeMethod$1e = StripeResource.method;
const ReceivedDebits$1 = StripeResource.extend({
  create: stripeMethod$1e({
    method: "POST",
    fullPath: "/v1/test_helpers/treasury/received_debits"
  })
});
const stripeMethod$1d = StripeResource.method;
const ReceivedDebits = StripeResource.extend({
  retrieve: stripeMethod$1d({
    method: "GET",
    fullPath: "/v1/treasury/received_debits/{id}"
  }),
  list: stripeMethod$1d({
    method: "GET",
    fullPath: "/v1/treasury/received_debits",
    methodType: "list"
  })
});
const stripeMethod$1c = StripeResource.method;
const Refunds$1 = StripeResource.extend({
  expire: stripeMethod$1c({
    method: "POST",
    fullPath: "/v1/test_helpers/refunds/{refund}/expire"
  })
});
const stripeMethod$1b = StripeResource.method;
const Registrations = StripeResource.extend({
  create: stripeMethod$1b({ method: "POST", fullPath: "/v1/tax/registrations" }),
  retrieve: stripeMethod$1b({
    method: "GET",
    fullPath: "/v1/tax/registrations/{id}"
  }),
  update: stripeMethod$1b({
    method: "POST",
    fullPath: "/v1/tax/registrations/{id}"
  }),
  list: stripeMethod$1b({
    method: "GET",
    fullPath: "/v1/tax/registrations",
    methodType: "list"
  })
});
const stripeMethod$1a = StripeResource.method;
const ReportRuns = StripeResource.extend({
  create: stripeMethod$1a({ method: "POST", fullPath: "/v1/reporting/report_runs" }),
  retrieve: stripeMethod$1a({
    method: "GET",
    fullPath: "/v1/reporting/report_runs/{report_run}"
  }),
  list: stripeMethod$1a({
    method: "GET",
    fullPath: "/v1/reporting/report_runs",
    methodType: "list"
  })
});
const stripeMethod$19 = StripeResource.method;
const ReportTypes = StripeResource.extend({
  retrieve: stripeMethod$19({
    method: "GET",
    fullPath: "/v1/reporting/report_types/{report_type}"
  }),
  list: stripeMethod$19({
    method: "GET",
    fullPath: "/v1/reporting/report_types",
    methodType: "list"
  })
});
const stripeMethod$18 = StripeResource.method;
const Requests = StripeResource.extend({
  create: stripeMethod$18({ method: "POST", fullPath: "/v1/forwarding/requests" }),
  retrieve: stripeMethod$18({
    method: "GET",
    fullPath: "/v1/forwarding/requests/{id}"
  }),
  list: stripeMethod$18({
    method: "GET",
    fullPath: "/v1/forwarding/requests",
    methodType: "list"
  })
});
const stripeMethod$17 = StripeResource.method;
const ScheduledQueryRuns = StripeResource.extend({
  retrieve: stripeMethod$17({
    method: "GET",
    fullPath: "/v1/sigma/scheduled_query_runs/{scheduled_query_run}"
  }),
  list: stripeMethod$17({
    method: "GET",
    fullPath: "/v1/sigma/scheduled_query_runs",
    methodType: "list"
  })
});
const stripeMethod$16 = StripeResource.method;
const Secrets = StripeResource.extend({
  create: stripeMethod$16({ method: "POST", fullPath: "/v1/apps/secrets" }),
  list: stripeMethod$16({
    method: "GET",
    fullPath: "/v1/apps/secrets",
    methodType: "list"
  }),
  deleteWhere: stripeMethod$16({
    method: "POST",
    fullPath: "/v1/apps/secrets/delete"
  }),
  find: stripeMethod$16({ method: "GET", fullPath: "/v1/apps/secrets/find" })
});
const stripeMethod$15 = StripeResource.method;
const Sessions$2 = StripeResource.extend({
  create: stripeMethod$15({
    method: "POST",
    fullPath: "/v1/billing_portal/sessions"
  })
});
const stripeMethod$14 = StripeResource.method;
const Sessions$1 = StripeResource.extend({
  create: stripeMethod$14({ method: "POST", fullPath: "/v1/checkout/sessions" }),
  retrieve: stripeMethod$14({
    method: "GET",
    fullPath: "/v1/checkout/sessions/{session}"
  }),
  update: stripeMethod$14({
    method: "POST",
    fullPath: "/v1/checkout/sessions/{session}"
  }),
  list: stripeMethod$14({
    method: "GET",
    fullPath: "/v1/checkout/sessions",
    methodType: "list"
  }),
  expire: stripeMethod$14({
    method: "POST",
    fullPath: "/v1/checkout/sessions/{session}/expire"
  }),
  listLineItems: stripeMethod$14({
    method: "GET",
    fullPath: "/v1/checkout/sessions/{session}/line_items",
    methodType: "list"
  })
});
const stripeMethod$13 = StripeResource.method;
const Sessions = StripeResource.extend({
  create: stripeMethod$13({
    method: "POST",
    fullPath: "/v1/financial_connections/sessions"
  }),
  retrieve: stripeMethod$13({
    method: "GET",
    fullPath: "/v1/financial_connections/sessions/{session}"
  })
});
const stripeMethod$12 = StripeResource.method;
const Settings = StripeResource.extend({
  retrieve: stripeMethod$12({ method: "GET", fullPath: "/v1/tax/settings" }),
  update: stripeMethod$12({ method: "POST", fullPath: "/v1/tax/settings" })
});
const stripeMethod$11 = StripeResource.method;
const Suppliers = StripeResource.extend({
  retrieve: stripeMethod$11({
    method: "GET",
    fullPath: "/v1/climate/suppliers/{supplier}"
  }),
  list: stripeMethod$11({
    method: "GET",
    fullPath: "/v1/climate/suppliers",
    methodType: "list"
  })
});
const stripeMethod$10 = StripeResource.method;
const TestClocks = StripeResource.extend({
  create: stripeMethod$10({
    method: "POST",
    fullPath: "/v1/test_helpers/test_clocks"
  }),
  retrieve: stripeMethod$10({
    method: "GET",
    fullPath: "/v1/test_helpers/test_clocks/{test_clock}"
  }),
  list: stripeMethod$10({
    method: "GET",
    fullPath: "/v1/test_helpers/test_clocks",
    methodType: "list"
  }),
  del: stripeMethod$10({
    method: "DELETE",
    fullPath: "/v1/test_helpers/test_clocks/{test_clock}"
  }),
  advance: stripeMethod$10({
    method: "POST",
    fullPath: "/v1/test_helpers/test_clocks/{test_clock}/advance"
  })
});
const stripeMethod$$ = StripeResource.method;
const Tokens$1 = StripeResource.extend({
  retrieve: stripeMethod$$({
    method: "GET",
    fullPath: "/v1/issuing/tokens/{token}"
  }),
  update: stripeMethod$$({
    method: "POST",
    fullPath: "/v1/issuing/tokens/{token}"
  }),
  list: stripeMethod$$({
    method: "GET",
    fullPath: "/v1/issuing/tokens",
    methodType: "list"
  })
});
const stripeMethod$_ = StripeResource.method;
const TransactionEntries = StripeResource.extend({
  retrieve: stripeMethod$_({
    method: "GET",
    fullPath: "/v1/treasury/transaction_entries/{id}"
  }),
  list: stripeMethod$_({
    method: "GET",
    fullPath: "/v1/treasury/transaction_entries",
    methodType: "list"
  })
});
const stripeMethod$Z = StripeResource.method;
const Transactions$4 = StripeResource.extend({
  createForceCapture: stripeMethod$Z({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/transactions/create_force_capture"
  }),
  createUnlinkedRefund: stripeMethod$Z({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/transactions/create_unlinked_refund"
  }),
  refund: stripeMethod$Z({
    method: "POST",
    fullPath: "/v1/test_helpers/issuing/transactions/{transaction}/refund"
  })
});
const stripeMethod$Y = StripeResource.method;
const Transactions$3 = StripeResource.extend({
  retrieve: stripeMethod$Y({
    method: "GET",
    fullPath: "/v1/financial_connections/transactions/{transaction}"
  }),
  list: stripeMethod$Y({
    method: "GET",
    fullPath: "/v1/financial_connections/transactions",
    methodType: "list"
  })
});
const stripeMethod$X = StripeResource.method;
const Transactions$2 = StripeResource.extend({
  retrieve: stripeMethod$X({
    method: "GET",
    fullPath: "/v1/issuing/transactions/{transaction}"
  }),
  update: stripeMethod$X({
    method: "POST",
    fullPath: "/v1/issuing/transactions/{transaction}"
  }),
  list: stripeMethod$X({
    method: "GET",
    fullPath: "/v1/issuing/transactions",
    methodType: "list"
  })
});
const stripeMethod$W = StripeResource.method;
const Transactions$1 = StripeResource.extend({
  retrieve: stripeMethod$W({
    method: "GET",
    fullPath: "/v1/tax/transactions/{transaction}"
  }),
  createFromCalculation: stripeMethod$W({
    method: "POST",
    fullPath: "/v1/tax/transactions/create_from_calculation"
  }),
  createReversal: stripeMethod$W({
    method: "POST",
    fullPath: "/v1/tax/transactions/create_reversal"
  }),
  listLineItems: stripeMethod$W({
    method: "GET",
    fullPath: "/v1/tax/transactions/{transaction}/line_items",
    methodType: "list"
  })
});
const stripeMethod$V = StripeResource.method;
const Transactions = StripeResource.extend({
  retrieve: stripeMethod$V({
    method: "GET",
    fullPath: "/v1/treasury/transactions/{id}"
  }),
  list: stripeMethod$V({
    method: "GET",
    fullPath: "/v1/treasury/transactions",
    methodType: "list"
  })
});
const stripeMethod$U = StripeResource.method;
const ValueListItems = StripeResource.extend({
  create: stripeMethod$U({
    method: "POST",
    fullPath: "/v1/radar/value_list_items"
  }),
  retrieve: stripeMethod$U({
    method: "GET",
    fullPath: "/v1/radar/value_list_items/{item}"
  }),
  list: stripeMethod$U({
    method: "GET",
    fullPath: "/v1/radar/value_list_items",
    methodType: "list"
  }),
  del: stripeMethod$U({
    method: "DELETE",
    fullPath: "/v1/radar/value_list_items/{item}"
  })
});
const stripeMethod$T = StripeResource.method;
const ValueLists = StripeResource.extend({
  create: stripeMethod$T({ method: "POST", fullPath: "/v1/radar/value_lists" }),
  retrieve: stripeMethod$T({
    method: "GET",
    fullPath: "/v1/radar/value_lists/{value_list}"
  }),
  update: stripeMethod$T({
    method: "POST",
    fullPath: "/v1/radar/value_lists/{value_list}"
  }),
  list: stripeMethod$T({
    method: "GET",
    fullPath: "/v1/radar/value_lists",
    methodType: "list"
  }),
  del: stripeMethod$T({
    method: "DELETE",
    fullPath: "/v1/radar/value_lists/{value_list}"
  })
});
const stripeMethod$S = StripeResource.method;
const VerificationReports = StripeResource.extend({
  retrieve: stripeMethod$S({
    method: "GET",
    fullPath: "/v1/identity/verification_reports/{report}"
  }),
  list: stripeMethod$S({
    method: "GET",
    fullPath: "/v1/identity/verification_reports",
    methodType: "list"
  })
});
const stripeMethod$R = StripeResource.method;
const VerificationSessions = StripeResource.extend({
  create: stripeMethod$R({
    method: "POST",
    fullPath: "/v1/identity/verification_sessions"
  }),
  retrieve: stripeMethod$R({
    method: "GET",
    fullPath: "/v1/identity/verification_sessions/{session}"
  }),
  update: stripeMethod$R({
    method: "POST",
    fullPath: "/v1/identity/verification_sessions/{session}"
  }),
  list: stripeMethod$R({
    method: "GET",
    fullPath: "/v1/identity/verification_sessions",
    methodType: "list"
  }),
  cancel: stripeMethod$R({
    method: "POST",
    fullPath: "/v1/identity/verification_sessions/{session}/cancel"
  }),
  redact: stripeMethod$R({
    method: "POST",
    fullPath: "/v1/identity/verification_sessions/{session}/redact"
  })
});
const stripeMethod$Q = StripeResource.method;
const Accounts = StripeResource.extend({
  create: stripeMethod$Q({ method: "POST", fullPath: "/v1/accounts" }),
  retrieve(id2, ...args) {
    if (typeof id2 === "string") {
      return stripeMethod$Q({
        method: "GET",
        fullPath: "/v1/accounts/{id}"
      }).apply(this, [id2, ...args]);
    } else {
      if (id2 === null || id2 === void 0) {
        [].shift.apply([id2, ...args]);
      }
      return stripeMethod$Q({
        method: "GET",
        fullPath: "/v1/account"
      }).apply(this, [id2, ...args]);
    }
  },
  update: stripeMethod$Q({ method: "POST", fullPath: "/v1/accounts/{account}" }),
  list: stripeMethod$Q({
    method: "GET",
    fullPath: "/v1/accounts",
    methodType: "list"
  }),
  del: stripeMethod$Q({ method: "DELETE", fullPath: "/v1/accounts/{account}" }),
  createExternalAccount: stripeMethod$Q({
    method: "POST",
    fullPath: "/v1/accounts/{account}/external_accounts"
  }),
  createLoginLink: stripeMethod$Q({
    method: "POST",
    fullPath: "/v1/accounts/{account}/login_links"
  }),
  createPerson: stripeMethod$Q({
    method: "POST",
    fullPath: "/v1/accounts/{account}/persons"
  }),
  deleteExternalAccount: stripeMethod$Q({
    method: "DELETE",
    fullPath: "/v1/accounts/{account}/external_accounts/{id}"
  }),
  deletePerson: stripeMethod$Q({
    method: "DELETE",
    fullPath: "/v1/accounts/{account}/persons/{person}"
  }),
  listCapabilities: stripeMethod$Q({
    method: "GET",
    fullPath: "/v1/accounts/{account}/capabilities",
    methodType: "list"
  }),
  listExternalAccounts: stripeMethod$Q({
    method: "GET",
    fullPath: "/v1/accounts/{account}/external_accounts",
    methodType: "list"
  }),
  listPersons: stripeMethod$Q({
    method: "GET",
    fullPath: "/v1/accounts/{account}/persons",
    methodType: "list"
  }),
  reject: stripeMethod$Q({
    method: "POST",
    fullPath: "/v1/accounts/{account}/reject"
  }),
  retrieveCurrent: stripeMethod$Q({ method: "GET", fullPath: "/v1/account" }),
  retrieveCapability: stripeMethod$Q({
    method: "GET",
    fullPath: "/v1/accounts/{account}/capabilities/{capability}"
  }),
  retrieveExternalAccount: stripeMethod$Q({
    method: "GET",
    fullPath: "/v1/accounts/{account}/external_accounts/{id}"
  }),
  retrievePerson: stripeMethod$Q({
    method: "GET",
    fullPath: "/v1/accounts/{account}/persons/{person}"
  }),
  updateCapability: stripeMethod$Q({
    method: "POST",
    fullPath: "/v1/accounts/{account}/capabilities/{capability}"
  }),
  updateExternalAccount: stripeMethod$Q({
    method: "POST",
    fullPath: "/v1/accounts/{account}/external_accounts/{id}"
  }),
  updatePerson: stripeMethod$Q({
    method: "POST",
    fullPath: "/v1/accounts/{account}/persons/{person}"
  })
});
const stripeMethod$P = StripeResource.method;
const AccountLinks = StripeResource.extend({
  create: stripeMethod$P({ method: "POST", fullPath: "/v1/account_links" })
});
const stripeMethod$O = StripeResource.method;
const AccountSessions = StripeResource.extend({
  create: stripeMethod$O({ method: "POST", fullPath: "/v1/account_sessions" })
});
const stripeMethod$N = StripeResource.method;
const ApplePayDomains = StripeResource.extend({
  create: stripeMethod$N({ method: "POST", fullPath: "/v1/apple_pay/domains" }),
  retrieve: stripeMethod$N({
    method: "GET",
    fullPath: "/v1/apple_pay/domains/{domain}"
  }),
  list: stripeMethod$N({
    method: "GET",
    fullPath: "/v1/apple_pay/domains",
    methodType: "list"
  }),
  del: stripeMethod$N({
    method: "DELETE",
    fullPath: "/v1/apple_pay/domains/{domain}"
  })
});
const stripeMethod$M = StripeResource.method;
const ApplicationFees = StripeResource.extend({
  retrieve: stripeMethod$M({
    method: "GET",
    fullPath: "/v1/application_fees/{id}"
  }),
  list: stripeMethod$M({
    method: "GET",
    fullPath: "/v1/application_fees",
    methodType: "list"
  }),
  createRefund: stripeMethod$M({
    method: "POST",
    fullPath: "/v1/application_fees/{id}/refunds"
  }),
  listRefunds: stripeMethod$M({
    method: "GET",
    fullPath: "/v1/application_fees/{id}/refunds",
    methodType: "list"
  }),
  retrieveRefund: stripeMethod$M({
    method: "GET",
    fullPath: "/v1/application_fees/{fee}/refunds/{id}"
  }),
  updateRefund: stripeMethod$M({
    method: "POST",
    fullPath: "/v1/application_fees/{fee}/refunds/{id}"
  })
});
const stripeMethod$L = StripeResource.method;
const Balance = StripeResource.extend({
  retrieve: stripeMethod$L({ method: "GET", fullPath: "/v1/balance" })
});
const stripeMethod$K = StripeResource.method;
const BalanceTransactions = StripeResource.extend({
  retrieve: stripeMethod$K({
    method: "GET",
    fullPath: "/v1/balance_transactions/{id}"
  }),
  list: stripeMethod$K({
    method: "GET",
    fullPath: "/v1/balance_transactions",
    methodType: "list"
  })
});
const stripeMethod$J = StripeResource.method;
const Charges = StripeResource.extend({
  create: stripeMethod$J({ method: "POST", fullPath: "/v1/charges" }),
  retrieve: stripeMethod$J({ method: "GET", fullPath: "/v1/charges/{charge}" }),
  update: stripeMethod$J({ method: "POST", fullPath: "/v1/charges/{charge}" }),
  list: stripeMethod$J({
    method: "GET",
    fullPath: "/v1/charges",
    methodType: "list"
  }),
  capture: stripeMethod$J({
    method: "POST",
    fullPath: "/v1/charges/{charge}/capture"
  }),
  search: stripeMethod$J({
    method: "GET",
    fullPath: "/v1/charges/search",
    methodType: "search"
  })
});
const stripeMethod$I = StripeResource.method;
const ConfirmationTokens = StripeResource.extend({
  retrieve: stripeMethod$I({
    method: "GET",
    fullPath: "/v1/confirmation_tokens/{confirmation_token}"
  })
});
const stripeMethod$H = StripeResource.method;
const CountrySpecs = StripeResource.extend({
  retrieve: stripeMethod$H({
    method: "GET",
    fullPath: "/v1/country_specs/{country}"
  }),
  list: stripeMethod$H({
    method: "GET",
    fullPath: "/v1/country_specs",
    methodType: "list"
  })
});
const stripeMethod$G = StripeResource.method;
const Coupons = StripeResource.extend({
  create: stripeMethod$G({ method: "POST", fullPath: "/v1/coupons" }),
  retrieve: stripeMethod$G({ method: "GET", fullPath: "/v1/coupons/{coupon}" }),
  update: stripeMethod$G({ method: "POST", fullPath: "/v1/coupons/{coupon}" }),
  list: stripeMethod$G({
    method: "GET",
    fullPath: "/v1/coupons",
    methodType: "list"
  }),
  del: stripeMethod$G({ method: "DELETE", fullPath: "/v1/coupons/{coupon}" })
});
const stripeMethod$F = StripeResource.method;
const CreditNotes = StripeResource.extend({
  create: stripeMethod$F({ method: "POST", fullPath: "/v1/credit_notes" }),
  retrieve: stripeMethod$F({ method: "GET", fullPath: "/v1/credit_notes/{id}" }),
  update: stripeMethod$F({ method: "POST", fullPath: "/v1/credit_notes/{id}" }),
  list: stripeMethod$F({
    method: "GET",
    fullPath: "/v1/credit_notes",
    methodType: "list"
  }),
  listLineItems: stripeMethod$F({
    method: "GET",
    fullPath: "/v1/credit_notes/{credit_note}/lines",
    methodType: "list"
  }),
  listPreviewLineItems: stripeMethod$F({
    method: "GET",
    fullPath: "/v1/credit_notes/preview/lines",
    methodType: "list"
  }),
  preview: stripeMethod$F({ method: "GET", fullPath: "/v1/credit_notes/preview" }),
  voidCreditNote: stripeMethod$F({
    method: "POST",
    fullPath: "/v1/credit_notes/{id}/void"
  })
});
const stripeMethod$E = StripeResource.method;
const CustomerSessions = StripeResource.extend({
  create: stripeMethod$E({ method: "POST", fullPath: "/v1/customer_sessions" })
});
const stripeMethod$D = StripeResource.method;
const Customers = StripeResource.extend({
  create: stripeMethod$D({ method: "POST", fullPath: "/v1/customers" }),
  retrieve: stripeMethod$D({ method: "GET", fullPath: "/v1/customers/{customer}" }),
  update: stripeMethod$D({ method: "POST", fullPath: "/v1/customers/{customer}" }),
  list: stripeMethod$D({
    method: "GET",
    fullPath: "/v1/customers",
    methodType: "list"
  }),
  del: stripeMethod$D({ method: "DELETE", fullPath: "/v1/customers/{customer}" }),
  createBalanceTransaction: stripeMethod$D({
    method: "POST",
    fullPath: "/v1/customers/{customer}/balance_transactions"
  }),
  createFundingInstructions: stripeMethod$D({
    method: "POST",
    fullPath: "/v1/customers/{customer}/funding_instructions"
  }),
  createSource: stripeMethod$D({
    method: "POST",
    fullPath: "/v1/customers/{customer}/sources"
  }),
  createTaxId: stripeMethod$D({
    method: "POST",
    fullPath: "/v1/customers/{customer}/tax_ids"
  }),
  deleteDiscount: stripeMethod$D({
    method: "DELETE",
    fullPath: "/v1/customers/{customer}/discount"
  }),
  deleteSource: stripeMethod$D({
    method: "DELETE",
    fullPath: "/v1/customers/{customer}/sources/{id}"
  }),
  deleteTaxId: stripeMethod$D({
    method: "DELETE",
    fullPath: "/v1/customers/{customer}/tax_ids/{id}"
  }),
  listBalanceTransactions: stripeMethod$D({
    method: "GET",
    fullPath: "/v1/customers/{customer}/balance_transactions",
    methodType: "list"
  }),
  listCashBalanceTransactions: stripeMethod$D({
    method: "GET",
    fullPath: "/v1/customers/{customer}/cash_balance_transactions",
    methodType: "list"
  }),
  listPaymentMethods: stripeMethod$D({
    method: "GET",
    fullPath: "/v1/customers/{customer}/payment_methods",
    methodType: "list"
  }),
  listSources: stripeMethod$D({
    method: "GET",
    fullPath: "/v1/customers/{customer}/sources",
    methodType: "list"
  }),
  listTaxIds: stripeMethod$D({
    method: "GET",
    fullPath: "/v1/customers/{customer}/tax_ids",
    methodType: "list"
  }),
  retrieveBalanceTransaction: stripeMethod$D({
    method: "GET",
    fullPath: "/v1/customers/{customer}/balance_transactions/{transaction}"
  }),
  retrieveCashBalance: stripeMethod$D({
    method: "GET",
    fullPath: "/v1/customers/{customer}/cash_balance"
  }),
  retrieveCashBalanceTransaction: stripeMethod$D({
    method: "GET",
    fullPath: "/v1/customers/{customer}/cash_balance_transactions/{transaction}"
  }),
  retrievePaymentMethod: stripeMethod$D({
    method: "GET",
    fullPath: "/v1/customers/{customer}/payment_methods/{payment_method}"
  }),
  retrieveSource: stripeMethod$D({
    method: "GET",
    fullPath: "/v1/customers/{customer}/sources/{id}"
  }),
  retrieveTaxId: stripeMethod$D({
    method: "GET",
    fullPath: "/v1/customers/{customer}/tax_ids/{id}"
  }),
  search: stripeMethod$D({
    method: "GET",
    fullPath: "/v1/customers/search",
    methodType: "search"
  }),
  updateBalanceTransaction: stripeMethod$D({
    method: "POST",
    fullPath: "/v1/customers/{customer}/balance_transactions/{transaction}"
  }),
  updateCashBalance: stripeMethod$D({
    method: "POST",
    fullPath: "/v1/customers/{customer}/cash_balance"
  }),
  updateSource: stripeMethod$D({
    method: "POST",
    fullPath: "/v1/customers/{customer}/sources/{id}"
  }),
  verifySource: stripeMethod$D({
    method: "POST",
    fullPath: "/v1/customers/{customer}/sources/{id}/verify"
  })
});
const stripeMethod$C = StripeResource.method;
const Disputes = StripeResource.extend({
  retrieve: stripeMethod$C({ method: "GET", fullPath: "/v1/disputes/{dispute}" }),
  update: stripeMethod$C({ method: "POST", fullPath: "/v1/disputes/{dispute}" }),
  list: stripeMethod$C({
    method: "GET",
    fullPath: "/v1/disputes",
    methodType: "list"
  }),
  close: stripeMethod$C({
    method: "POST",
    fullPath: "/v1/disputes/{dispute}/close"
  })
});
const stripeMethod$B = StripeResource.method;
const EphemeralKeys = StripeResource.extend({
  create: stripeMethod$B({
    method: "POST",
    fullPath: "/v1/ephemeral_keys",
    validator: (data, options) => {
      if (!options.headers || !options.headers["Stripe-Version"]) {
        throw new Error("Passing apiVersion in a separate options hash is required to create an ephemeral key. See https://stripe.com/docs/api/versioning?lang=node");
      }
    }
  }),
  del: stripeMethod$B({ method: "DELETE", fullPath: "/v1/ephemeral_keys/{key}" })
});
const stripeMethod$A = StripeResource.method;
const Events = StripeResource.extend({
  retrieve: stripeMethod$A({ method: "GET", fullPath: "/v1/events/{id}" }),
  list: stripeMethod$A({
    method: "GET",
    fullPath: "/v1/events",
    methodType: "list"
  })
});
const stripeMethod$z = StripeResource.method;
const ExchangeRates = StripeResource.extend({
  retrieve: stripeMethod$z({
    method: "GET",
    fullPath: "/v1/exchange_rates/{rate_id}"
  }),
  list: stripeMethod$z({
    method: "GET",
    fullPath: "/v1/exchange_rates",
    methodType: "list"
  })
});
const stripeMethod$y = StripeResource.method;
const FileLinks = StripeResource.extend({
  create: stripeMethod$y({ method: "POST", fullPath: "/v1/file_links" }),
  retrieve: stripeMethod$y({ method: "GET", fullPath: "/v1/file_links/{link}" }),
  update: stripeMethod$y({ method: "POST", fullPath: "/v1/file_links/{link}" }),
  list: stripeMethod$y({
    method: "GET",
    fullPath: "/v1/file_links",
    methodType: "list"
  })
});
const multipartDataGenerator = (method, data, headers) => {
  const segno = (Math.round(Math.random() * 1e16) + Math.round(Math.random() * 1e16)).toString();
  headers["Content-Type"] = `multipart/form-data; boundary=${segno}`;
  const textEncoder = new TextEncoder();
  let buffer = new Uint8Array(0);
  const endBuffer = textEncoder.encode("\r\n");
  function push(l2) {
    const prevBuffer = buffer;
    const newBuffer = l2 instanceof Uint8Array ? l2 : new Uint8Array(textEncoder.encode(l2));
    buffer = new Uint8Array(prevBuffer.length + newBuffer.length + 2);
    buffer.set(prevBuffer);
    buffer.set(newBuffer, prevBuffer.length);
    buffer.set(endBuffer, buffer.length - 2);
  }
  function q2(s2) {
    return `"${s2.replace(/"|"/g, "%22").replace(/\r\n|\r|\n/g, " ")}"`;
  }
  const flattenedData = flattenAndStringify(data);
  for (const k2 in flattenedData) {
    if (!Object.prototype.hasOwnProperty.call(flattenedData, k2)) {
      continue;
    }
    const v2 = flattenedData[k2];
    push(`--${segno}`);
    if (Object.prototype.hasOwnProperty.call(v2, "data")) {
      const typedEntry = v2;
      push(`Content-Disposition: form-data; name=${q2(k2)}; filename=${q2(typedEntry.name || "blob")}`);
      push(`Content-Type: ${typedEntry.type || "application/octet-stream"}`);
      push("");
      push(typedEntry.data);
    } else {
      push(`Content-Disposition: form-data; name=${q2(k2)}`);
      push("");
      push(v2);
    }
  }
  push(`--${segno}--`);
  return buffer;
};
function multipartRequestDataProcessor(method, data, headers, callback) {
  data = data || {};
  if (method !== "POST") {
    return callback(null, queryStringifyRequestData(data));
  }
  this._stripe._platformFunctions.tryBufferData(data).then((bufferedData) => {
    const buffer = multipartDataGenerator(method, bufferedData, headers);
    return callback(null, buffer);
  }).catch((err) => callback(err, null));
}
const stripeMethod$x = StripeResource.method;
const Files = StripeResource.extend({
  create: stripeMethod$x({
    method: "POST",
    fullPath: "/v1/files",
    headers: {
      "Content-Type": "multipart/form-data"
    },
    host: "files.stripe.com"
  }),
  retrieve: stripeMethod$x({ method: "GET", fullPath: "/v1/files/{file}" }),
  list: stripeMethod$x({
    method: "GET",
    fullPath: "/v1/files",
    methodType: "list"
  }),
  requestDataProcessor: multipartRequestDataProcessor
});
const stripeMethod$w = StripeResource.method;
const InvoiceItems = StripeResource.extend({
  create: stripeMethod$w({ method: "POST", fullPath: "/v1/invoiceitems" }),
  retrieve: stripeMethod$w({
    method: "GET",
    fullPath: "/v1/invoiceitems/{invoiceitem}"
  }),
  update: stripeMethod$w({
    method: "POST",
    fullPath: "/v1/invoiceitems/{invoiceitem}"
  }),
  list: stripeMethod$w({
    method: "GET",
    fullPath: "/v1/invoiceitems",
    methodType: "list"
  }),
  del: stripeMethod$w({
    method: "DELETE",
    fullPath: "/v1/invoiceitems/{invoiceitem}"
  })
});
const stripeMethod$v = StripeResource.method;
const InvoicePayments = StripeResource.extend({
  retrieve: stripeMethod$v({
    method: "GET",
    fullPath: "/v1/invoice_payments/{invoice_payment}"
  }),
  list: stripeMethod$v({
    method: "GET",
    fullPath: "/v1/invoice_payments",
    methodType: "list"
  })
});
const stripeMethod$u = StripeResource.method;
const InvoiceRenderingTemplates = StripeResource.extend({
  retrieve: stripeMethod$u({
    method: "GET",
    fullPath: "/v1/invoice_rendering_templates/{template}"
  }),
  list: stripeMethod$u({
    method: "GET",
    fullPath: "/v1/invoice_rendering_templates",
    methodType: "list"
  }),
  archive: stripeMethod$u({
    method: "POST",
    fullPath: "/v1/invoice_rendering_templates/{template}/archive"
  }),
  unarchive: stripeMethod$u({
    method: "POST",
    fullPath: "/v1/invoice_rendering_templates/{template}/unarchive"
  })
});
const stripeMethod$t = StripeResource.method;
const Invoices = StripeResource.extend({
  create: stripeMethod$t({ method: "POST", fullPath: "/v1/invoices" }),
  retrieve: stripeMethod$t({ method: "GET", fullPath: "/v1/invoices/{invoice}" }),
  update: stripeMethod$t({ method: "POST", fullPath: "/v1/invoices/{invoice}" }),
  list: stripeMethod$t({
    method: "GET",
    fullPath: "/v1/invoices",
    methodType: "list"
  }),
  del: stripeMethod$t({ method: "DELETE", fullPath: "/v1/invoices/{invoice}" }),
  addLines: stripeMethod$t({
    method: "POST",
    fullPath: "/v1/invoices/{invoice}/add_lines"
  }),
  attachPayment: stripeMethod$t({
    method: "POST",
    fullPath: "/v1/invoices/{invoice}/attach_payment"
  }),
  createPreview: stripeMethod$t({
    method: "POST",
    fullPath: "/v1/invoices/create_preview"
  }),
  finalizeInvoice: stripeMethod$t({
    method: "POST",
    fullPath: "/v1/invoices/{invoice}/finalize"
  }),
  listLineItems: stripeMethod$t({
    method: "GET",
    fullPath: "/v1/invoices/{invoice}/lines",
    methodType: "list"
  }),
  markUncollectible: stripeMethod$t({
    method: "POST",
    fullPath: "/v1/invoices/{invoice}/mark_uncollectible"
  }),
  pay: stripeMethod$t({ method: "POST", fullPath: "/v1/invoices/{invoice}/pay" }),
  removeLines: stripeMethod$t({
    method: "POST",
    fullPath: "/v1/invoices/{invoice}/remove_lines"
  }),
  search: stripeMethod$t({
    method: "GET",
    fullPath: "/v1/invoices/search",
    methodType: "search"
  }),
  sendInvoice: stripeMethod$t({
    method: "POST",
    fullPath: "/v1/invoices/{invoice}/send"
  }),
  updateLines: stripeMethod$t({
    method: "POST",
    fullPath: "/v1/invoices/{invoice}/update_lines"
  }),
  updateLineItem: stripeMethod$t({
    method: "POST",
    fullPath: "/v1/invoices/{invoice}/lines/{line_item_id}"
  }),
  voidInvoice: stripeMethod$t({
    method: "POST",
    fullPath: "/v1/invoices/{invoice}/void"
  })
});
const stripeMethod$s = StripeResource.method;
const Mandates = StripeResource.extend({
  retrieve: stripeMethod$s({ method: "GET", fullPath: "/v1/mandates/{mandate}" })
});
const stripeMethod$r = StripeResource.method;
const oAuthHost = "connect.stripe.com";
const OAuth = StripeResource.extend({
  basePath: "/",
  authorizeUrl(params, options) {
    params = params || {};
    options = options || {};
    let path = "oauth/authorize";
    if (options.express) {
      path = `express/${path}`;
    }
    if (!params.response_type) {
      params.response_type = "code";
    }
    if (!params.client_id) {
      params.client_id = this._stripe.getClientId();
    }
    if (!params.scope) {
      params.scope = "read_write";
    }
    return `https://${oAuthHost}/${path}?${queryStringifyRequestData(params)}`;
  },
  token: stripeMethod$r({
    method: "POST",
    path: "oauth/token",
    host: oAuthHost
  }),
  deauthorize(spec, ...args) {
    if (!spec.client_id) {
      spec.client_id = this._stripe.getClientId();
    }
    return stripeMethod$r({
      method: "POST",
      path: "oauth/deauthorize",
      host: oAuthHost
    }).apply(this, [spec, ...args]);
  }
});
const stripeMethod$q = StripeResource.method;
const PaymentIntents = StripeResource.extend({
  create: stripeMethod$q({ method: "POST", fullPath: "/v1/payment_intents" }),
  retrieve: stripeMethod$q({
    method: "GET",
    fullPath: "/v1/payment_intents/{intent}"
  }),
  update: stripeMethod$q({
    method: "POST",
    fullPath: "/v1/payment_intents/{intent}"
  }),
  list: stripeMethod$q({
    method: "GET",
    fullPath: "/v1/payment_intents",
    methodType: "list"
  }),
  applyCustomerBalance: stripeMethod$q({
    method: "POST",
    fullPath: "/v1/payment_intents/{intent}/apply_customer_balance"
  }),
  cancel: stripeMethod$q({
    method: "POST",
    fullPath: "/v1/payment_intents/{intent}/cancel"
  }),
  capture: stripeMethod$q({
    method: "POST",
    fullPath: "/v1/payment_intents/{intent}/capture"
  }),
  confirm: stripeMethod$q({
    method: "POST",
    fullPath: "/v1/payment_intents/{intent}/confirm"
  }),
  incrementAuthorization: stripeMethod$q({
    method: "POST",
    fullPath: "/v1/payment_intents/{intent}/increment_authorization"
  }),
  search: stripeMethod$q({
    method: "GET",
    fullPath: "/v1/payment_intents/search",
    methodType: "search"
  }),
  verifyMicrodeposits: stripeMethod$q({
    method: "POST",
    fullPath: "/v1/payment_intents/{intent}/verify_microdeposits"
  })
});
const stripeMethod$p = StripeResource.method;
const PaymentLinks = StripeResource.extend({
  create: stripeMethod$p({ method: "POST", fullPath: "/v1/payment_links" }),
  retrieve: stripeMethod$p({
    method: "GET",
    fullPath: "/v1/payment_links/{payment_link}"
  }),
  update: stripeMethod$p({
    method: "POST",
    fullPath: "/v1/payment_links/{payment_link}"
  }),
  list: stripeMethod$p({
    method: "GET",
    fullPath: "/v1/payment_links",
    methodType: "list"
  }),
  listLineItems: stripeMethod$p({
    method: "GET",
    fullPath: "/v1/payment_links/{payment_link}/line_items",
    methodType: "list"
  })
});
const stripeMethod$o = StripeResource.method;
const PaymentMethodConfigurations = StripeResource.extend({
  create: stripeMethod$o({
    method: "POST",
    fullPath: "/v1/payment_method_configurations"
  }),
  retrieve: stripeMethod$o({
    method: "GET",
    fullPath: "/v1/payment_method_configurations/{configuration}"
  }),
  update: stripeMethod$o({
    method: "POST",
    fullPath: "/v1/payment_method_configurations/{configuration}"
  }),
  list: stripeMethod$o({
    method: "GET",
    fullPath: "/v1/payment_method_configurations",
    methodType: "list"
  })
});
const stripeMethod$n = StripeResource.method;
const PaymentMethodDomains = StripeResource.extend({
  create: stripeMethod$n({
    method: "POST",
    fullPath: "/v1/payment_method_domains"
  }),
  retrieve: stripeMethod$n({
    method: "GET",
    fullPath: "/v1/payment_method_domains/{payment_method_domain}"
  }),
  update: stripeMethod$n({
    method: "POST",
    fullPath: "/v1/payment_method_domains/{payment_method_domain}"
  }),
  list: stripeMethod$n({
    method: "GET",
    fullPath: "/v1/payment_method_domains",
    methodType: "list"
  }),
  validate: stripeMethod$n({
    method: "POST",
    fullPath: "/v1/payment_method_domains/{payment_method_domain}/validate"
  })
});
const stripeMethod$m = StripeResource.method;
const PaymentMethods = StripeResource.extend({
  create: stripeMethod$m({ method: "POST", fullPath: "/v1/payment_methods" }),
  retrieve: stripeMethod$m({
    method: "GET",
    fullPath: "/v1/payment_methods/{payment_method}"
  }),
  update: stripeMethod$m({
    method: "POST",
    fullPath: "/v1/payment_methods/{payment_method}"
  }),
  list: stripeMethod$m({
    method: "GET",
    fullPath: "/v1/payment_methods",
    methodType: "list"
  }),
  attach: stripeMethod$m({
    method: "POST",
    fullPath: "/v1/payment_methods/{payment_method}/attach"
  }),
  detach: stripeMethod$m({
    method: "POST",
    fullPath: "/v1/payment_methods/{payment_method}/detach"
  })
});
const stripeMethod$l = StripeResource.method;
const Payouts = StripeResource.extend({
  create: stripeMethod$l({ method: "POST", fullPath: "/v1/payouts" }),
  retrieve: stripeMethod$l({ method: "GET", fullPath: "/v1/payouts/{payout}" }),
  update: stripeMethod$l({ method: "POST", fullPath: "/v1/payouts/{payout}" }),
  list: stripeMethod$l({
    method: "GET",
    fullPath: "/v1/payouts",
    methodType: "list"
  }),
  cancel: stripeMethod$l({
    method: "POST",
    fullPath: "/v1/payouts/{payout}/cancel"
  }),
  reverse: stripeMethod$l({
    method: "POST",
    fullPath: "/v1/payouts/{payout}/reverse"
  })
});
const stripeMethod$k = StripeResource.method;
const Plans = StripeResource.extend({
  create: stripeMethod$k({ method: "POST", fullPath: "/v1/plans" }),
  retrieve: stripeMethod$k({ method: "GET", fullPath: "/v1/plans/{plan}" }),
  update: stripeMethod$k({ method: "POST", fullPath: "/v1/plans/{plan}" }),
  list: stripeMethod$k({
    method: "GET",
    fullPath: "/v1/plans",
    methodType: "list"
  }),
  del: stripeMethod$k({ method: "DELETE", fullPath: "/v1/plans/{plan}" })
});
const stripeMethod$j = StripeResource.method;
const Prices = StripeResource.extend({
  create: stripeMethod$j({ method: "POST", fullPath: "/v1/prices" }),
  retrieve: stripeMethod$j({ method: "GET", fullPath: "/v1/prices/{price}" }),
  update: stripeMethod$j({ method: "POST", fullPath: "/v1/prices/{price}" }),
  list: stripeMethod$j({
    method: "GET",
    fullPath: "/v1/prices",
    methodType: "list"
  }),
  search: stripeMethod$j({
    method: "GET",
    fullPath: "/v1/prices/search",
    methodType: "search"
  })
});
const stripeMethod$i = StripeResource.method;
const Products = StripeResource.extend({
  create: stripeMethod$i({ method: "POST", fullPath: "/v1/products" }),
  retrieve: stripeMethod$i({ method: "GET", fullPath: "/v1/products/{id}" }),
  update: stripeMethod$i({ method: "POST", fullPath: "/v1/products/{id}" }),
  list: stripeMethod$i({
    method: "GET",
    fullPath: "/v1/products",
    methodType: "list"
  }),
  del: stripeMethod$i({ method: "DELETE", fullPath: "/v1/products/{id}" }),
  createFeature: stripeMethod$i({
    method: "POST",
    fullPath: "/v1/products/{product}/features"
  }),
  deleteFeature: stripeMethod$i({
    method: "DELETE",
    fullPath: "/v1/products/{product}/features/{id}"
  }),
  listFeatures: stripeMethod$i({
    method: "GET",
    fullPath: "/v1/products/{product}/features",
    methodType: "list"
  }),
  retrieveFeature: stripeMethod$i({
    method: "GET",
    fullPath: "/v1/products/{product}/features/{id}"
  }),
  search: stripeMethod$i({
    method: "GET",
    fullPath: "/v1/products/search",
    methodType: "search"
  })
});
const stripeMethod$h = StripeResource.method;
const PromotionCodes = StripeResource.extend({
  create: stripeMethod$h({ method: "POST", fullPath: "/v1/promotion_codes" }),
  retrieve: stripeMethod$h({
    method: "GET",
    fullPath: "/v1/promotion_codes/{promotion_code}"
  }),
  update: stripeMethod$h({
    method: "POST",
    fullPath: "/v1/promotion_codes/{promotion_code}"
  }),
  list: stripeMethod$h({
    method: "GET",
    fullPath: "/v1/promotion_codes",
    methodType: "list"
  })
});
const stripeMethod$g = StripeResource.method;
const Quotes = StripeResource.extend({
  create: stripeMethod$g({ method: "POST", fullPath: "/v1/quotes" }),
  retrieve: stripeMethod$g({ method: "GET", fullPath: "/v1/quotes/{quote}" }),
  update: stripeMethod$g({ method: "POST", fullPath: "/v1/quotes/{quote}" }),
  list: stripeMethod$g({
    method: "GET",
    fullPath: "/v1/quotes",
    methodType: "list"
  }),
  accept: stripeMethod$g({ method: "POST", fullPath: "/v1/quotes/{quote}/accept" }),
  cancel: stripeMethod$g({ method: "POST", fullPath: "/v1/quotes/{quote}/cancel" }),
  finalizeQuote: stripeMethod$g({
    method: "POST",
    fullPath: "/v1/quotes/{quote}/finalize"
  }),
  listComputedUpfrontLineItems: stripeMethod$g({
    method: "GET",
    fullPath: "/v1/quotes/{quote}/computed_upfront_line_items",
    methodType: "list"
  }),
  listLineItems: stripeMethod$g({
    method: "GET",
    fullPath: "/v1/quotes/{quote}/line_items",
    methodType: "list"
  }),
  pdf: stripeMethod$g({
    method: "GET",
    fullPath: "/v1/quotes/{quote}/pdf",
    host: "files.stripe.com",
    streaming: true
  })
});
const stripeMethod$f = StripeResource.method;
const Refunds = StripeResource.extend({
  create: stripeMethod$f({ method: "POST", fullPath: "/v1/refunds" }),
  retrieve: stripeMethod$f({ method: "GET", fullPath: "/v1/refunds/{refund}" }),
  update: stripeMethod$f({ method: "POST", fullPath: "/v1/refunds/{refund}" }),
  list: stripeMethod$f({
    method: "GET",
    fullPath: "/v1/refunds",
    methodType: "list"
  }),
  cancel: stripeMethod$f({
    method: "POST",
    fullPath: "/v1/refunds/{refund}/cancel"
  })
});
const stripeMethod$e = StripeResource.method;
const Reviews = StripeResource.extend({
  retrieve: stripeMethod$e({ method: "GET", fullPath: "/v1/reviews/{review}" }),
  list: stripeMethod$e({
    method: "GET",
    fullPath: "/v1/reviews",
    methodType: "list"
  }),
  approve: stripeMethod$e({
    method: "POST",
    fullPath: "/v1/reviews/{review}/approve"
  })
});
const stripeMethod$d = StripeResource.method;
const SetupAttempts = StripeResource.extend({
  list: stripeMethod$d({
    method: "GET",
    fullPath: "/v1/setup_attempts",
    methodType: "list"
  })
});
const stripeMethod$c = StripeResource.method;
const SetupIntents = StripeResource.extend({
  create: stripeMethod$c({ method: "POST", fullPath: "/v1/setup_intents" }),
  retrieve: stripeMethod$c({
    method: "GET",
    fullPath: "/v1/setup_intents/{intent}"
  }),
  update: stripeMethod$c({
    method: "POST",
    fullPath: "/v1/setup_intents/{intent}"
  }),
  list: stripeMethod$c({
    method: "GET",
    fullPath: "/v1/setup_intents",
    methodType: "list"
  }),
  cancel: stripeMethod$c({
    method: "POST",
    fullPath: "/v1/setup_intents/{intent}/cancel"
  }),
  confirm: stripeMethod$c({
    method: "POST",
    fullPath: "/v1/setup_intents/{intent}/confirm"
  }),
  verifyMicrodeposits: stripeMethod$c({
    method: "POST",
    fullPath: "/v1/setup_intents/{intent}/verify_microdeposits"
  })
});
const stripeMethod$b = StripeResource.method;
const ShippingRates = StripeResource.extend({
  create: stripeMethod$b({ method: "POST", fullPath: "/v1/shipping_rates" }),
  retrieve: stripeMethod$b({
    method: "GET",
    fullPath: "/v1/shipping_rates/{shipping_rate_token}"
  }),
  update: stripeMethod$b({
    method: "POST",
    fullPath: "/v1/shipping_rates/{shipping_rate_token}"
  }),
  list: stripeMethod$b({
    method: "GET",
    fullPath: "/v1/shipping_rates",
    methodType: "list"
  })
});
const stripeMethod$a = StripeResource.method;
const Sources = StripeResource.extend({
  create: stripeMethod$a({ method: "POST", fullPath: "/v1/sources" }),
  retrieve: stripeMethod$a({ method: "GET", fullPath: "/v1/sources/{source}" }),
  update: stripeMethod$a({ method: "POST", fullPath: "/v1/sources/{source}" }),
  listSourceTransactions: stripeMethod$a({
    method: "GET",
    fullPath: "/v1/sources/{source}/source_transactions",
    methodType: "list"
  }),
  verify: stripeMethod$a({
    method: "POST",
    fullPath: "/v1/sources/{source}/verify"
  })
});
const stripeMethod$9 = StripeResource.method;
const SubscriptionItems = StripeResource.extend({
  create: stripeMethod$9({ method: "POST", fullPath: "/v1/subscription_items" }),
  retrieve: stripeMethod$9({
    method: "GET",
    fullPath: "/v1/subscription_items/{item}"
  }),
  update: stripeMethod$9({
    method: "POST",
    fullPath: "/v1/subscription_items/{item}"
  }),
  list: stripeMethod$9({
    method: "GET",
    fullPath: "/v1/subscription_items",
    methodType: "list"
  }),
  del: stripeMethod$9({
    method: "DELETE",
    fullPath: "/v1/subscription_items/{item}"
  })
});
const stripeMethod$8 = StripeResource.method;
const SubscriptionSchedules = StripeResource.extend({
  create: stripeMethod$8({
    method: "POST",
    fullPath: "/v1/subscription_schedules"
  }),
  retrieve: stripeMethod$8({
    method: "GET",
    fullPath: "/v1/subscription_schedules/{schedule}"
  }),
  update: stripeMethod$8({
    method: "POST",
    fullPath: "/v1/subscription_schedules/{schedule}"
  }),
  list: stripeMethod$8({
    method: "GET",
    fullPath: "/v1/subscription_schedules",
    methodType: "list"
  }),
  cancel: stripeMethod$8({
    method: "POST",
    fullPath: "/v1/subscription_schedules/{schedule}/cancel"
  }),
  release: stripeMethod$8({
    method: "POST",
    fullPath: "/v1/subscription_schedules/{schedule}/release"
  })
});
const stripeMethod$7 = StripeResource.method;
const Subscriptions = StripeResource.extend({
  create: stripeMethod$7({ method: "POST", fullPath: "/v1/subscriptions" }),
  retrieve: stripeMethod$7({
    method: "GET",
    fullPath: "/v1/subscriptions/{subscription_exposed_id}"
  }),
  update: stripeMethod$7({
    method: "POST",
    fullPath: "/v1/subscriptions/{subscription_exposed_id}"
  }),
  list: stripeMethod$7({
    method: "GET",
    fullPath: "/v1/subscriptions",
    methodType: "list"
  }),
  cancel: stripeMethod$7({
    method: "DELETE",
    fullPath: "/v1/subscriptions/{subscription_exposed_id}"
  }),
  deleteDiscount: stripeMethod$7({
    method: "DELETE",
    fullPath: "/v1/subscriptions/{subscription_exposed_id}/discount"
  }),
  resume: stripeMethod$7({
    method: "POST",
    fullPath: "/v1/subscriptions/{subscription}/resume"
  }),
  search: stripeMethod$7({
    method: "GET",
    fullPath: "/v1/subscriptions/search",
    methodType: "search"
  })
});
const stripeMethod$6 = StripeResource.method;
const TaxCodes = StripeResource.extend({
  retrieve: stripeMethod$6({ method: "GET", fullPath: "/v1/tax_codes/{id}" }),
  list: stripeMethod$6({
    method: "GET",
    fullPath: "/v1/tax_codes",
    methodType: "list"
  })
});
const stripeMethod$5 = StripeResource.method;
const TaxIds = StripeResource.extend({
  create: stripeMethod$5({ method: "POST", fullPath: "/v1/tax_ids" }),
  retrieve: stripeMethod$5({ method: "GET", fullPath: "/v1/tax_ids/{id}" }),
  list: stripeMethod$5({
    method: "GET",
    fullPath: "/v1/tax_ids",
    methodType: "list"
  }),
  del: stripeMethod$5({ method: "DELETE", fullPath: "/v1/tax_ids/{id}" })
});
const stripeMethod$4 = StripeResource.method;
const TaxRates = StripeResource.extend({
  create: stripeMethod$4({ method: "POST", fullPath: "/v1/tax_rates" }),
  retrieve: stripeMethod$4({ method: "GET", fullPath: "/v1/tax_rates/{tax_rate}" }),
  update: stripeMethod$4({ method: "POST", fullPath: "/v1/tax_rates/{tax_rate}" }),
  list: stripeMethod$4({
    method: "GET",
    fullPath: "/v1/tax_rates",
    methodType: "list"
  })
});
const stripeMethod$3 = StripeResource.method;
const Tokens = StripeResource.extend({
  create: stripeMethod$3({ method: "POST", fullPath: "/v1/tokens" }),
  retrieve: stripeMethod$3({ method: "GET", fullPath: "/v1/tokens/{token}" })
});
const stripeMethod$2 = StripeResource.method;
const Topups = StripeResource.extend({
  create: stripeMethod$2({ method: "POST", fullPath: "/v1/topups" }),
  retrieve: stripeMethod$2({ method: "GET", fullPath: "/v1/topups/{topup}" }),
  update: stripeMethod$2({ method: "POST", fullPath: "/v1/topups/{topup}" }),
  list: stripeMethod$2({
    method: "GET",
    fullPath: "/v1/topups",
    methodType: "list"
  }),
  cancel: stripeMethod$2({ method: "POST", fullPath: "/v1/topups/{topup}/cancel" })
});
const stripeMethod$1 = StripeResource.method;
const Transfers = StripeResource.extend({
  create: stripeMethod$1({ method: "POST", fullPath: "/v1/transfers" }),
  retrieve: stripeMethod$1({ method: "GET", fullPath: "/v1/transfers/{transfer}" }),
  update: stripeMethod$1({ method: "POST", fullPath: "/v1/transfers/{transfer}" }),
  list: stripeMethod$1({
    method: "GET",
    fullPath: "/v1/transfers",
    methodType: "list"
  }),
  createReversal: stripeMethod$1({
    method: "POST",
    fullPath: "/v1/transfers/{id}/reversals"
  }),
  listReversals: stripeMethod$1({
    method: "GET",
    fullPath: "/v1/transfers/{id}/reversals",
    methodType: "list"
  }),
  retrieveReversal: stripeMethod$1({
    method: "GET",
    fullPath: "/v1/transfers/{transfer}/reversals/{id}"
  }),
  updateReversal: stripeMethod$1({
    method: "POST",
    fullPath: "/v1/transfers/{transfer}/reversals/{id}"
  })
});
const stripeMethod = StripeResource.method;
const WebhookEndpoints = StripeResource.extend({
  create: stripeMethod({ method: "POST", fullPath: "/v1/webhook_endpoints" }),
  retrieve: stripeMethod({
    method: "GET",
    fullPath: "/v1/webhook_endpoints/{webhook_endpoint}"
  }),
  update: stripeMethod({
    method: "POST",
    fullPath: "/v1/webhook_endpoints/{webhook_endpoint}"
  }),
  list: stripeMethod({
    method: "GET",
    fullPath: "/v1/webhook_endpoints",
    methodType: "list"
  }),
  del: stripeMethod({
    method: "DELETE",
    fullPath: "/v1/webhook_endpoints/{webhook_endpoint}"
  })
});
const Apps = resourceNamespace("apps", { Secrets });
const Billing = resourceNamespace("billing", {
  Alerts,
  CreditBalanceSummary,
  CreditBalanceTransactions,
  CreditGrants,
  MeterEventAdjustments: MeterEventAdjustments$1,
  MeterEvents: MeterEvents$1,
  Meters
});
const BillingPortal = resourceNamespace("billingPortal", {
  Configurations: Configurations$1,
  Sessions: Sessions$2
});
const Checkout = resourceNamespace("checkout", {
  Sessions: Sessions$1
});
const Climate = resourceNamespace("climate", {
  Orders,
  Products: Products$1,
  Suppliers
});
const Entitlements = resourceNamespace("entitlements", {
  ActiveEntitlements,
  Features
});
const FinancialConnections = resourceNamespace("financialConnections", {
  Accounts: Accounts$1,
  Sessions,
  Transactions: Transactions$3
});
const Forwarding = resourceNamespace("forwarding", {
  Requests
});
const Identity = resourceNamespace("identity", {
  VerificationReports,
  VerificationSessions
});
const Issuing = resourceNamespace("issuing", {
  Authorizations,
  Cardholders,
  Cards,
  Disputes: Disputes$1,
  PersonalizationDesigns,
  PhysicalBundles,
  Tokens: Tokens$1,
  Transactions: Transactions$2
});
const Radar = resourceNamespace("radar", {
  EarlyFraudWarnings,
  ValueListItems,
  ValueLists
});
const Reporting = resourceNamespace("reporting", {
  ReportRuns,
  ReportTypes
});
const Sigma = resourceNamespace("sigma", {
  ScheduledQueryRuns
});
const Tax = resourceNamespace("tax", {
  Calculations,
  Registrations,
  Settings,
  Transactions: Transactions$1
});
const Terminal = resourceNamespace("terminal", {
  Configurations,
  ConnectionTokens,
  Locations,
  Readers
});
const TestHelpers = resourceNamespace("testHelpers", {
  ConfirmationTokens: ConfirmationTokens$1,
  Customers: Customers$1,
  Refunds: Refunds$1,
  TestClocks,
  Issuing: resourceNamespace("issuing", {
    Authorizations: Authorizations$1,
    Cards: Cards$1,
    PersonalizationDesigns: PersonalizationDesigns$1,
    Transactions: Transactions$4
  }),
  Terminal: resourceNamespace("terminal", {
    Readers: Readers$1
  }),
  Treasury: resourceNamespace("treasury", {
    InboundTransfers: InboundTransfers$1,
    OutboundPayments: OutboundPayments$1,
    OutboundTransfers: OutboundTransfers$1,
    ReceivedCredits: ReceivedCredits$1,
    ReceivedDebits: ReceivedDebits$1
  })
});
const Treasury = resourceNamespace("treasury", {
  CreditReversals,
  DebitReversals,
  FinancialAccounts,
  InboundTransfers,
  OutboundPayments,
  OutboundTransfers,
  ReceivedCredits,
  ReceivedDebits,
  TransactionEntries,
  Transactions
});
const V2 = resourceNamespace("v2", {
  Billing: resourceNamespace("billing", {
    MeterEventAdjustments,
    MeterEventSession,
    MeterEventStream,
    MeterEvents
  }),
  Core: resourceNamespace("core", {
    EventDestinations,
    Events: Events$1
  })
});
const resources = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Account: Accounts,
  AccountLinks,
  AccountSessions,
  Accounts,
  ApplePayDomains,
  ApplicationFees,
  Apps,
  Balance,
  BalanceTransactions,
  Billing,
  BillingPortal,
  Charges,
  Checkout,
  Climate,
  ConfirmationTokens,
  CountrySpecs,
  Coupons,
  CreditNotes,
  CustomerSessions,
  Customers,
  Disputes,
  Entitlements,
  EphemeralKeys,
  Events,
  ExchangeRates,
  FileLinks,
  Files,
  FinancialConnections,
  Forwarding,
  Identity,
  InvoiceItems,
  InvoicePayments,
  InvoiceRenderingTemplates,
  Invoices,
  Issuing,
  Mandates,
  OAuth,
  PaymentIntents,
  PaymentLinks,
  PaymentMethodConfigurations,
  PaymentMethodDomains,
  PaymentMethods,
  Payouts,
  Plans,
  Prices,
  Products,
  PromotionCodes,
  Quotes,
  Radar,
  Refunds,
  Reporting,
  Reviews,
  SetupAttempts,
  SetupIntents,
  ShippingRates,
  Sigma,
  Sources,
  SubscriptionItems,
  SubscriptionSchedules,
  Subscriptions,
  Tax,
  TaxCodes,
  TaxIds,
  TaxRates,
  Terminal,
  TestHelpers,
  Tokens,
  Topups,
  Transfers,
  Treasury,
  V2,
  WebhookEndpoints
}, Symbol.toStringTag, { value: "Module" }));
const DEFAULT_HOST = "api.stripe.com";
const DEFAULT_PORT = "443";
const DEFAULT_BASE_PATH = "/v1/";
const DEFAULT_API_VERSION = ApiVersion;
const DEFAULT_TIMEOUT = 8e4;
const MAX_NETWORK_RETRY_DELAY_SEC = 5;
const INITIAL_NETWORK_RETRY_DELAY_SEC = 0.5;
const APP_INFO_PROPERTIES = ["name", "version", "url", "partner_id"];
const ALLOWED_CONFIG_PROPERTIES = [
  "authenticator",
  "apiVersion",
  "typescript",
  "maxNetworkRetries",
  "httpAgent",
  "httpClient",
  "timeout",
  "host",
  "port",
  "protocol",
  "telemetry",
  "appInfo",
  "stripeAccount",
  "stripeContext"
];
const defaultRequestSenderFactory = (stripe) => new RequestSender(stripe, StripeResource.MAX_BUFFERED_REQUEST_METRICS);
function createStripe(platformFunctions, requestSender = defaultRequestSenderFactory) {
  Stripe2.PACKAGE_VERSION = "18.2.1";
  Stripe2.USER_AGENT = Object.assign({ bindings_version: Stripe2.PACKAGE_VERSION, lang: "node", publisher: "stripe", uname: null, typescript: false }, determineProcessUserAgentProperties());
  Stripe2.StripeResource = StripeResource;
  Stripe2.resources = resources;
  Stripe2.HttpClient = HttpClient;
  Stripe2.HttpClientResponse = HttpClientResponse;
  Stripe2.CryptoProvider = CryptoProvider;
  Stripe2.webhooks = createWebhooks(platformFunctions);
  function Stripe2(key, config = {}) {
    if (!(this instanceof Stripe2)) {
      return new Stripe2(key, config);
    }
    const props = this._getPropsFromConfig(config);
    this._platformFunctions = platformFunctions;
    Object.defineProperty(this, "_emitter", {
      value: this._platformFunctions.createEmitter(),
      enumerable: false,
      configurable: false,
      writable: false
    });
    this.VERSION = Stripe2.PACKAGE_VERSION;
    this.on = this._emitter.on.bind(this._emitter);
    this.once = this._emitter.once.bind(this._emitter);
    this.off = this._emitter.removeListener.bind(this._emitter);
    const agent = props.httpAgent || null;
    this._api = {
      host: props.host || DEFAULT_HOST,
      port: props.port || DEFAULT_PORT,
      protocol: props.protocol || "https",
      basePath: DEFAULT_BASE_PATH,
      version: props.apiVersion || DEFAULT_API_VERSION,
      timeout: validateInteger("timeout", props.timeout, DEFAULT_TIMEOUT),
      maxNetworkRetries: validateInteger("maxNetworkRetries", props.maxNetworkRetries, 2),
      agent,
      httpClient: props.httpClient || (agent ? this._platformFunctions.createNodeHttpClient(agent) : this._platformFunctions.createDefaultHttpClient()),
      dev: false,
      stripeAccount: props.stripeAccount || null,
      stripeContext: props.stripeContext || null
    };
    const typescript = props.typescript || false;
    if (typescript !== Stripe2.USER_AGENT.typescript) {
      Stripe2.USER_AGENT.typescript = typescript;
    }
    if (props.appInfo) {
      this._setAppInfo(props.appInfo);
    }
    this._prepResources();
    this._setAuthenticator(key, props.authenticator);
    this.errors = _Error;
    this.webhooks = Stripe2.webhooks;
    this._prevRequestMetrics = [];
    this._enableTelemetry = props.telemetry !== false;
    this._requestSender = requestSender(this);
    this.StripeResource = Stripe2.StripeResource;
  }
  Stripe2.errors = _Error;
  Stripe2.createNodeHttpClient = platformFunctions.createNodeHttpClient;
  Stripe2.createFetchHttpClient = platformFunctions.createFetchHttpClient;
  Stripe2.createNodeCryptoProvider = platformFunctions.createNodeCryptoProvider;
  Stripe2.createSubtleCryptoProvider = platformFunctions.createSubtleCryptoProvider;
  Stripe2.prototype = {
    // Properties are set in the constructor above
    _appInfo: void 0,
    on: null,
    off: null,
    once: null,
    VERSION: null,
    StripeResource: null,
    webhooks: null,
    errors: null,
    _api: null,
    _prevRequestMetrics: null,
    _emitter: null,
    _enableTelemetry: null,
    _requestSender: null,
    _platformFunctions: null,
    rawRequest(method, path, params, options) {
      return this._requestSender._rawRequest(method, path, params, options);
    },
    /**
     * @private
     */
    _setAuthenticator(key, authenticator) {
      if (key && authenticator) {
        throw new Error("Can't specify both apiKey and authenticator");
      }
      if (!key && !authenticator) {
        throw new Error("Neither apiKey nor config.authenticator provided");
      }
      this._authenticator = key ? createApiKeyAuthenticator(key) : authenticator;
    },
    /**
     * @private
     * This may be removed in the future.
     */
    _setAppInfo(info) {
      if (info && typeof info !== "object") {
        throw new Error("AppInfo must be an object.");
      }
      if (info && !info.name) {
        throw new Error("AppInfo.name is required");
      }
      info = info || {};
      this._appInfo = APP_INFO_PROPERTIES.reduce((accum, prop) => {
        if (typeof info[prop] == "string") {
          accum = accum || {};
          accum[prop] = info[prop];
        }
        return accum;
      }, {});
    },
    /**
     * @private
     * This may be removed in the future.
     */
    _setApiField(key, value) {
      this._api[key] = value;
    },
    /**
     * @private
     * Please open or upvote an issue at github.com/stripe/stripe-node
     * if you use this, detailing your use-case.
     *
     * It may be deprecated and removed in the future.
     */
    getApiField(key) {
      return this._api[key];
    },
    setClientId(clientId) {
      this._clientId = clientId;
    },
    getClientId() {
      return this._clientId;
    },
    /**
     * @private
     * Please open or upvote an issue at github.com/stripe/stripe-node
     * if you use this, detailing your use-case.
     *
     * It may be deprecated and removed in the future.
     */
    getConstant: (c2) => {
      switch (c2) {
        case "DEFAULT_HOST":
          return DEFAULT_HOST;
        case "DEFAULT_PORT":
          return DEFAULT_PORT;
        case "DEFAULT_BASE_PATH":
          return DEFAULT_BASE_PATH;
        case "DEFAULT_API_VERSION":
          return DEFAULT_API_VERSION;
        case "DEFAULT_TIMEOUT":
          return DEFAULT_TIMEOUT;
        case "MAX_NETWORK_RETRY_DELAY_SEC":
          return MAX_NETWORK_RETRY_DELAY_SEC;
        case "INITIAL_NETWORK_RETRY_DELAY_SEC":
          return INITIAL_NETWORK_RETRY_DELAY_SEC;
      }
      return Stripe2[c2];
    },
    getMaxNetworkRetries() {
      return this.getApiField("maxNetworkRetries");
    },
    /**
     * @private
     * This may be removed in the future.
     */
    _setApiNumberField(prop, n2, defaultVal) {
      const val = validateInteger(prop, n2, defaultVal);
      this._setApiField(prop, val);
    },
    getMaxNetworkRetryDelay() {
      return MAX_NETWORK_RETRY_DELAY_SEC;
    },
    getInitialNetworkRetryDelay() {
      return INITIAL_NETWORK_RETRY_DELAY_SEC;
    },
    /**
     * @private
     * Please open or upvote an issue at github.com/stripe/stripe-node
     * if you use this, detailing your use-case.
     *
     * It may be deprecated and removed in the future.
     *
     * Gets a JSON version of a User-Agent and uses a cached version for a slight
     * speed advantage.
     */
    getClientUserAgent(cb) {
      return this.getClientUserAgentSeeded(Stripe2.USER_AGENT, cb);
    },
    /**
     * @private
     * Please open or upvote an issue at github.com/stripe/stripe-node
     * if you use this, detailing your use-case.
     *
     * It may be deprecated and removed in the future.
     *
     * Gets a JSON version of a User-Agent by encoding a seeded object and
     * fetching a uname from the system.
     */
    getClientUserAgentSeeded(seed, cb) {
      this._platformFunctions.getUname().then((uname) => {
        var _a;
        const userAgent = {};
        for (const field in seed) {
          if (!Object.prototype.hasOwnProperty.call(seed, field)) {
            continue;
          }
          userAgent[field] = encodeURIComponent((_a = seed[field]) !== null && _a !== void 0 ? _a : "null");
        }
        userAgent.uname = encodeURIComponent(uname || "UNKNOWN");
        const client = this.getApiField("httpClient");
        if (client) {
          userAgent.httplib = encodeURIComponent(client.getClientName());
        }
        if (this._appInfo) {
          userAgent.application = this._appInfo;
        }
        cb(JSON.stringify(userAgent));
      });
    },
    /**
     * @private
     * Please open or upvote an issue at github.com/stripe/stripe-node
     * if you use this, detailing your use-case.
     *
     * It may be deprecated and removed in the future.
     */
    getAppInfoAsString() {
      if (!this._appInfo) {
        return "";
      }
      let formatted = this._appInfo.name;
      if (this._appInfo.version) {
        formatted += `/${this._appInfo.version}`;
      }
      if (this._appInfo.url) {
        formatted += ` (${this._appInfo.url})`;
      }
      return formatted;
    },
    getTelemetryEnabled() {
      return this._enableTelemetry;
    },
    /**
     * @private
     * This may be removed in the future.
     */
    _prepResources() {
      for (const name in resources) {
        if (!Object.prototype.hasOwnProperty.call(resources, name)) {
          continue;
        }
        this[pascalToCamelCase(name)] = new resources[name](this);
      }
    },
    /**
     * @private
     * This may be removed in the future.
     */
    _getPropsFromConfig(config) {
      if (!config) {
        return {};
      }
      const isString2 = typeof config === "string";
      const isObject2 = config === Object(config) && !Array.isArray(config);
      if (!isObject2 && !isString2) {
        throw new Error("Config must either be an object or a string");
      }
      if (isString2) {
        return {
          apiVersion: config
        };
      }
      const values = Object.keys(config).filter((value) => !ALLOWED_CONFIG_PROPERTIES.includes(value));
      if (values.length > 0) {
        throw new Error(`Config object may only contain the following: ${ALLOWED_CONFIG_PROPERTIES.join(", ")}`);
      }
      return config;
    },
    parseThinEvent(payload, header, secret, tolerance, cryptoProvider, receivedAt) {
      return this.webhooks.constructEvent(payload, header, secret, tolerance, cryptoProvider, receivedAt);
    }
  };
  return Stripe2;
}
const Stripe = createStripe(new WebPlatformFunctions());
const plans = [
  {
    id: "initial",
    name: "Inicial",
    credits: 1,
    amount: 500,
    priceIds: [
      "price_1RVw9sCM9vOz3izsDaNqZ8Lt",
      "price_1RX3cSGuwyzgJLTInmOae3JM",
      "price_1RaFW4GuwyzgJLTIppS0jDaE"
    ]
    // Add your Stripe price IDs here
  },
  {
    id: "drawer",
    name: "Artista principiante",
    credits: 3,
    amount: 1e3,
    priceIds: ["price_1RYiEqGuwyzgJLTIyiRmfry0", "price_1RYpAKCM9vOz3izsCKDlwaov", "price_1RaFZbGuwyzgJLTIX49IwgS1", "price_1RaFh3GfMzEu6x2Ey3BjmNZk"]
  },
  {
    id: "artist",
    name: "Desenhista",
    credits: 10,
    amount: 2500,
    priceIds: [
      "price_1RVwLBCM9vOz3izsGtGBUCYG",
      "price_1RX3c4GuwyzgJLTIR4hkOrAp",
      "price_1RaFanGuwyzgJLTIyoMtEgmt"
    ]
    // Add your Stripe price IDs here
  },
  {
    id: "professional",
    name: "Profissional",
    amount: 4500,
    credits: 30,
    priceIds: [
      "price_1RVwMFCM9vOz3izsW4HX9Xgh",
      "price_1RX3bhGuwyzgJLTI5iUmKmCY",
      "price_1RaFboGuwyzgJLTI3TFkpG92"
    ]
    // Add your Stripe price IDs here
  }
];
const COUNTRY_CURRENCY_MAP = {
  // European countries - EUR
  "AT": "eur",
  // Austria
  "BE": "eur",
  // Belgium
  "CY": "eur",
  // Cyprus
  "EE": "eur",
  // Estonia
  "FI": "eur",
  // Finland
  "FR": "eur",
  // France
  "DE": "eur",
  // Germany
  "GR": "eur",
  // Greece
  "IE": "eur",
  // Ireland
  "IT": "eur",
  // Italy
  "LV": "eur",
  // Latvia
  "LT": "eur",
  // Lithuania
  "LU": "eur",
  // Luxembourg
  "MT": "eur",
  // Malta
  "NL": "eur",
  // Netherlands
  "PT": "eur",
  // Portugal
  "SK": "eur",
  // Slovakia
  "SI": "eur",
  // Slovenia
  "ES": "eur",
  // Spain
  // Brazil - BRL
  "BR": "brl"
  // Brazil
};
function getCurrencyFromCountry(countryCode) {
  return COUNTRY_CURRENCY_MAP[countryCode.toUpperCase()] || "usd";
}
async function pricingLoader({ context, request }) {
  const stripe = new Stripe(context.cloudflare.env.STRIPE_API_KEY);
  const cfCountry = context.cloudflare.cf?.country;
  const cfIpCountry = request.headers.get("cf-ipcountry");
  const finalCountry = cfCountry || cfIpCountry || "US";
  const userCurrency = getCurrencyFromCountry(finalCountry);
  const products = await stripe.products.list({
    active: true,
    expand: ["data.default_price"]
  }).then((products2) => products2.data.map((product) => ({
    id: product.id,
    name: product.name,
    description: product.description,
    defaultPriceId: typeof product.default_price === "string" ? product.default_price : product.default_price?.id
  })));
  const priceList = await stripe.prices.list({
    expand: ["data.product", "data.currency_options"],
    active: true,
    type: "one_time",
    currency: userCurrency
  }).then((prices2) => prices2.data.map((price) => {
    return {
      id: price.id,
      productId: typeof price.product === "string" ? price.product : price.product.id,
      unitAmount: price.unit_amount,
      currency: price.currency,
      currencyOptions: price.currency_options
    };
  }));
  const prices = priceList.map((price) => ({
    ...price,
    unitAmount: price.currencyOptions?.[userCurrency]?.unit_amount || price.unitAmount,
    currency: userCurrency,
    product: products.find((product) => product.id === price.productId)
  }));
  const basePlan = products.find((product) => product.name === plans[0].name);
  const initialPlan = products.find((product) => product.name === plans[1].name);
  const plusPlan = products.find((product) => product.name === plans[2].name);
  const proPlan = products.find((product) => product.name === plans[3].name);
  const basePrice = prices.find((price) => price.productId === basePlan?.id);
  const initialPrice = prices.find((price) => price.productId === initialPlan?.id);
  const plusPrice = prices.find((price) => price.productId === plusPlan?.id);
  const proPrice = prices.find((price) => price.productId === proPlan?.id);
  const availablePlans = [
    { plan: plans[0], price: basePrice, product: basePlan },
    { plan: plans[1], price: initialPrice, product: initialPlan },
    { plan: plans[2], price: plusPrice, product: plusPlan, popular: true },
    { plan: plans[3], price: proPrice, product: proPlan }
  ].filter((item) => item.price && item.product);
  return {
    plans: availablePlans,
    currency: userCurrency
  };
}
const loader = async ({
  context,
  request,
  params
}) => {
  return {
    plans: pricingLoader({
      context,
      request
    })
  };
};
const LandingPage = withComponentProps(function LandingPage2() {
  const {
    t: t2,
    language
  } = useLanguage();
  const handleGetStartedClick = () => {
    window.location.href = "https://app.mylinearts.com";
  };
  const handleHowItWorksClick = (e2) => {
    e2.preventDefault();
    const section = document.getElementById("how-it-works");
    if (section) {
      section.scrollIntoView({
        behavior: "smooth"
      });
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
    className: "overflow-x-hidden",
    children: [/* @__PURE__ */ jsxRuntimeExports.jsxs("section", {
      className: "relative py-20 md:py-32 bg-linear-to-br from-primary-50 via-white to-secondary-50 overflow-hidden",
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
        className: "container mx-auto px-4 sm:px-6 lg:px-8 relative z-10",
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
          className: "flex flex-col lg:flex-row items-center",
          children: [/* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
            className: "lg:w-1/2 mb-12 lg:mb-0",
            children: [/* @__PURE__ */ jsxRuntimeExports.jsxs("h1", {
              className: "text-4xl sm:text-5xl md:text-6xl font-bold text-gray-900 mb-6 leading-tight",
              children: [t2("landing.hero.title"), " ", /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
                className: "text-primary-600",
                children: t2("landing.hero.titleHighlight")
              })]
            }), /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
              className: "text-xl text-gray-700 mb-8 max-w-lg",
              children: t2("landing.hero.subtitle")
            }), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
              className: "flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4",
              children: [/* @__PURE__ */ jsxRuntimeExports.jsxs("button", {
                onClick: handleGetStartedClick,
                className: "btn btn-primary flex items-center justify-center",
                children: [t2("nav.getStarted"), /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowRight, {
                  className: "ml-2 h-5 w-5"
                })]
              }), /* @__PURE__ */ jsxRuntimeExports.jsx("button", {
                onClick: handleHowItWorksClick,
                className: "btn btn-outline flex items-center justify-center",
                children: t2("nav.howItWorks")
              })]
            })]
          }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
            className: "lg:w-1/2 w-full",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
              className: "relative",
              children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                className: "absolute -top-10 -left-2 z-20",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                  className: "p-2 bg-white rounded-full shadow-lg",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Sparkles, {
                    className: "h-8 w-8 text-primary-500"
                  })
                })
              }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                className: "absolute -bottom-0 -right-6 z-20",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                  className: "p-2 bg-white rounded-full shadow-lg",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(Image, {
                    className: "h-8 w-8 text-secondary-500"
                  })
                })
              }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                className: "relative w-full h-[400px] md:h-[500px] lg:h-[600px]",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(se, {
                  itemOne: /* @__PURE__ */ jsxRuntimeExports.jsx("img", {
                    src: "/family-before.webp",
                    alt: "Original photo",
                    className: "object-cover w-full h-full"
                  }),
                  itemTwo: /* @__PURE__ */ jsxRuntimeExports.jsx("img", {
                    src: "/family-after.webp",
                    alt: "Original photo",
                    className: "object-cover w-full h-full"
                  }),
                  className: "h-full"
                })
              })]
            })
          })]
        })
      }), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
        className: "absolute top-0 left-0 w-full h-full overflow-hidden pointer-events-none",
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
          className: "absolute top-1/4 left-10 w-64 h-64 bg-primary-200 rounded-full mix-blend-multiply opacity-20"
        }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
          className: "absolute bottom-1/4 right-10 w-80 h-80 bg-secondary-200 rounded-full mix-blend-multiply opacity-20"
        })]
      })]
    }), /* @__PURE__ */ jsxRuntimeExports.jsx("section", {
      className: "py-20 bg-white",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
        className: "container mx-auto px-4 sm:px-6 lg:px-8",
        children: [/* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
          className: "text-center mb-16",
          children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h2", {
            className: "text-3xl md:text-4xl font-bold text-gray-900 mb-4",
            children: t2("landing.seeTheMagic")
          }), /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
            className: "text-xl text-gray-600 max-w-2xl mx-auto",
            children: t2("landing.seeTheMagicSubtitle")
          })]
        }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
          className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-2 gap-8",
          children: mockBeforeAfterImages.map((image, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
            className: "flex flex-col",
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx(se, {
              itemOne: /* @__PURE__ */ jsxRuntimeExports.jsx("img", {
                src: image.before,
                alt: "Original photo"
              }),
              itemTwo: /* @__PURE__ */ jsxRuntimeExports.jsx("img", {
                src: image.after,
                alt: "Original photo"
              })
            }), /* @__PURE__ */ jsxRuntimeExports.jsx("h3", {
              className: "text-xl font-bold text-gray-800 my-2",
              children: image.title[language]
            }), /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
              className: "text-gray-600",
              children: image.description[language]
            })]
          }, image.id))
        })]
      })
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(HowItWorks, {}), /* @__PURE__ */ jsxRuntimeExports.jsx(Benefits, {}), /* @__PURE__ */ jsxRuntimeExports.jsx(AboutUs, {}), /* @__PURE__ */ jsxRuntimeExports.jsx(Pricing, {}), /* @__PURE__ */ jsxRuntimeExports.jsx(SocialMedia, {}), /* @__PURE__ */ jsxRuntimeExports.jsx(FAQ, {}), /* @__PURE__ */ jsxRuntimeExports.jsx("section", {
      className: "py-20 bg-linear-to-br from-primary-100 to-secondary-50 paper-texture",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
        className: "container mx-auto px-4 sm:px-6 lg:px-8",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
          className: "max-w-4xl mx-auto",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
            className: "grid grid-cols-1 lg:grid-cols-2 gap-12 items-center",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
              children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h2", {
                className: "text-3xl md:text-4xl font-bold text-gray-900 mb-6",
                children: t2("landing.cta.title")
              }), /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
                className: "text-lg text-gray-700 mb-8",
                children: t2("landing.cta.subtitle")
              }), /* @__PURE__ */ jsxRuntimeExports.jsxs("button", {
                onClick: handleGetStartedClick,
                className: "btn btn-primary inline-flex items-center",
                children: [t2("landing.cta.button"), /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowRight, {
                  className: "ml-2 h-5 w-5"
                })]
              })]
            })
          })
        })
      })
    })]
  });
});
const route8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: LandingPage,
  loader
}, Symbol.toStringTag, { value: "Module" }));
const SEOHead = ({ title, description, keywords }) => {
  const { language } = useLanguage();
  const location2 = useLocation();
  const isEnglish = language === "en";
  const baseUrl = "https://mylinearts.com";
  const currentUrl = `${baseUrl}${location2.pathname}`;
  const seoData = {
    "pt-BR": {
      title: title || "MylineArts | Crie Livros de Colorir Personalizados com IA - Estilo Boobie Goods",
      description: description || "Transforme suas fotos em livros de colorir personalizados com IA. Inspirado no sucesso viral do Boobie Goods, criamos páginas únicas para colorir das suas memórias favoritas. Sem habilidades artísticas necessárias!",
      keywords: keywords || "livro de colorir personalizado, boobie goods, páginas para colorir personalizadas, arte com IA, foto para desenho, livro de colorir família, presente personalizado, criador de livro de colorir, arte personalizada, memórias em desenhos, gerador de arte linear",
      ogTitle: title || "MylineArts | Crie Livros de Colorir Personalizados com IA - Estilo Boobie Goods",
      ogDescription: description || "Transforme suas fotos em livros de colorir personalizados com IA. Inspirado no sucesso viral do Boobie Goods, criamos páginas únicas para colorir das suas memórias favoritas. Sem habilidades artísticas necessárias!",
      twitterTitle: title || "MylineArts | Crie Livros de Colorir Personalizados com IA - Estilo Boobie Goods",
      twitterDescription: description || "Transforme suas fotos em livros de colorir personalizados com IA. Inspirado no sucesso viral do Boobie Goods, criamos páginas únicas para colorir das suas memórias favoritas.",
      locale: "pt_BR",
      language: "Portuguese",
      hreflang: "pt-br",
      price: "5.00",
      currency: "BRL"
    },
    "en": {
      title: title || "MylineArts | Create Custom AI Coloring Books - Boobie Goods Style",
      description: description || "Transform your photos into personalized coloring books with AI. Inspired by the viral Boobie Goods success, we create unique coloring pages from your favorite memories. No artistic skills needed!",
      keywords: keywords || "custom coloring book, boobie goods, personalized coloring pages, AI art, photo to drawing, family coloring book, personalized gift, coloring book creator, custom art, memories to drawings, line art generator",
      ogTitle: title || "MylineArts | Create Custom AI Coloring Books - Boobie Goods Style",
      ogDescription: description || "Transform your photos into personalized coloring books with AI. Inspired by the viral Boobie Goods success, we create unique coloring pages from your favorite memories. No artistic skills needed!",
      twitterTitle: title || "MylineArts | Create Custom AI Coloring Books - Boobie Goods Style",
      twitterDescription: description || "Transform your photos into personalized coloring books with AI. Inspired by the viral Boobie Goods success, we create unique coloring pages from your favorite memories.",
      locale: "en_US",
      language: "English",
      hreflang: "en",
      price: "2.00",
      currency: "USD"
    }
  };
  const currentSEO = seoData[language] || seoData["en"];
  const structuredData = {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "MylineArts",
    "description": currentSEO.description,
    "url": baseUrl,
    "applicationCategory": "DesignApplication",
    "operatingSystem": "Web",
    "offers": {
      "@type": "Offer",
      "price": currentSEO.price,
      "priceCurrency": currentSEO.currency,
      "description": isEnglish ? "Credits to transform photos into coloring pages" : "Créditos para transformar fotos em páginas para colorir"
    },
    "creator": {
      "@type": "Organization",
      "name": "MylineArts",
      "url": baseUrl
    },
    "keywords": currentSEO.keywords,
    "inLanguage": isEnglish ? "en-US" : "pt-BR",
    "potentialAction": {
      "@type": "UseAction",
      "target": "https://app.mylinearts.com"
    },
    "aggregateRating": {
      "@type": "AggregateRating",
      "ratingValue": "4.8",
      "reviewCount": "127",
      "bestRating": "5",
      "worstRating": "1"
    },
    "review": [
      {
        "@type": "Review",
        "author": {
          "@type": "Person",
          "name": isEnglish ? "Sarah Johnson" : "Maria Silva"
        },
        "reviewRating": {
          "@type": "Rating",
          "ratingValue": "5"
        },
        "reviewBody": isEnglish ? "My kids absolutely love coloring their own photos! It's become a wonderful family activity that brings us together." : "Meus filhos adoram colorir suas próprias fotos! Virou uma atividade familiar maravilhosa que nos une."
      }
    ]
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Helmet, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: currentSEO.title }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { name: "title", content: currentSEO.title }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { name: "description", content: currentSEO.description }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { name: "keywords", content: currentSEO.keywords }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { name: "author", content: "MylineArts" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { name: "robots", content: "index, follow" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { name: "language", content: currentSEO.language }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { name: "revisit-after", content: "7 days" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { property: "og:type", content: "website" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { property: "og:url", content: currentUrl }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { property: "og:title", content: currentSEO.ogTitle }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { property: "og:description", content: currentSEO.ogDescription }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { property: "og:image", content: `${baseUrl}/logo.png` }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { property: "og:image:width", content: "1200" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { property: "og:image:height", content: "630" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { property: "og:site_name", content: "MylineArts" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { property: "og:locale", content: currentSEO.locale }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { property: "og:locale:alternate", content: isEnglish ? "pt_BR" : "en_US" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { property: "twitter:card", content: "summary_large_image" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { property: "twitter:url", content: currentUrl }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { property: "twitter:title", content: currentSEO.twitterTitle }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { property: "twitter:description", content: currentSEO.twitterDescription }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { property: "twitter:image", content: `${baseUrl}/logo.png` }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("meta", { property: "twitter:creator", content: "@mylinearts" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("link", { rel: "canonical", href: currentUrl }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("link", { rel: "alternate", hrefLang: "en", href: `${baseUrl}/en` }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("link", { rel: "alternate", hrefLang: "pt-br", href: baseUrl }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("link", { rel: "alternate", hrefLang: "x-default", href: `${baseUrl}/en` }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("script", { type: "application/ld+json", children: JSON.stringify(structuredData) })
  ] });
};
const blogPosts = [
  {
    id: "1",
    title: "Boobie Goods: o guia completo para desenhos para colorir e imprimir",
    description: "Descubra o mundo dos Boobie Goods: desenhos para colorir, dicas de impressão, ideias criativas e como criar seus próprios desenhos personalizados.",
    date: "14 de junho, 2025",
    readTime: "8 min de leitura",
    author: {
      name: "Stefanie Szabo",
      image: "/blog/1/ste.jpeg"
    },
    image: "/blog/1/banner.jpeg",
    slug: "boobie-goods-guia-completo"
  }
  // Add more blog posts here as they are created
];
const BlogListPage = () => {
  const {
    language
  } = useLanguage();
  const location2 = useLocation();
  const getLanguagePrefix = () => {
    return location2.pathname.startsWith("/en") ? "/en" : "";
  };
  reactExports.useEffect(() => {
    ha.capture("blog_list_viewed", {
      total_posts: blogPosts.length,
      language
    });
  }, [language]);
  const handleBlogPostClick = (post) => {
    ha.capture("blog_post_clicked", {
      post_id: post.id,
      post_title: post.title,
      post_slug: post.slug,
      post_author: post.author.name,
      post_date: post.date,
      language
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
    className: "max-w-6xl mx-auto px-4 py-12",
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SEOHead, {
      title: language === "en" ? "Blog | MyLineArts - Articles about Art and Creativity" : "Blog | MyLineArts - Artigos sobre Arte e Criatividade",
      description: language === "en" ? "Explore our articles about art, creativity, education and much more. Tips, tutorials and inspiration for your artistic journey." : "Explore nossos artigos sobre arte, criatividade, educação e muito mais. Dicas, tutoriais e inspiração para sua jornada artística.",
      keywords: language === "en" ? "mylinearts blog, art articles, creativity, art education, art tips, art tutorials" : "blog mylinearts, artigos sobre arte, criatividade, educação artística, dicas de arte, tutoriais de arte"
    }), /* @__PURE__ */ jsxRuntimeExports.jsxs("header", {
      className: "text-center mb-16",
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h1", {
        className: "text-4xl font-bold mb-4",
        children: "Blog"
      }), /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
        className: "text-xl text-gray-600 max-w-2xl mx-auto",
        children: language === "en" ? "Discover articles, tips and inspiration for your creative journey" : "Descubra artigos, dicas e inspiração para sua jornada criativa"
      })]
    }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8",
      children: blogPosts.map((post) => /* @__PURE__ */ jsxRuntimeExports.jsx("article", {
        className: "bg-white rounded-lg shadow-md overflow-hidden hover:shadow-lg transition-shadow",
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Link, {
          to: `${getLanguagePrefix()}/blog/${post.slug}`,
          onClick: () => handleBlogPostClick(post),
          children: [/* @__PURE__ */ jsxRuntimeExports.jsx("img", {
            src: post.image,
            alt: post.title,
            className: "w-full h-48 object-cover"
          }), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
            className: "p-6",
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h2", {
              className: "text-xl font-semibold mb-3 line-clamp-2",
              children: post.title
            }), /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
              className: "text-gray-600 mb-4 line-clamp-2",
              children: post.description
            }), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
              className: "flex items-center justify-between text-sm text-gray-500",
              children: [/* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                className: "flex items-center",
                children: [/* @__PURE__ */ jsxRuntimeExports.jsx("img", {
                  src: post.author.image,
                  alt: post.author.name,
                  className: "w-8 h-8 rounded-full mr-2"
                }), /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
                  children: post.author.name
                })]
              }), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                className: "flex items-center space-x-4",
                children: [/* @__PURE__ */ jsxRuntimeExports.jsx("time", {
                  dateTime: post.date,
                  children: post.date
                }), /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
                  children: post.readTime
                })]
              })]
            })]
          })]
        })
      }, post.id))
    }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      className: "mt-16 text-center",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
        className: "text-gray-600",
        children: language === "en" ? "More articles coming soon! Stay tuned for new publications." : "Mais artigos em breve! Fique ligado para novas publicações."
      })
    })]
  });
};
const BlogListPage$1 = withComponentProps(BlogListPage);
const route9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: BlogListPage$1
}, Symbol.toStringTag, { value: "Module" }));
const BlogPostPage = () => {
  const {
    language
  } = useLanguage();
  const location2 = useLocation();
  const {
    slug
  } = useParams();
  const getLanguagePrefix = () => {
    return location2.pathname.startsWith("/en") ? "/en" : "";
  };
  const handleBackClick = () => {
    ha.capture("blog_back_button_clicked", {
      post_title: "Boobie Goods: o guia completo para desenhos para colorir e imprimir",
      language
    });
  };
  const handleCTAClick = (ctaName) => {
    ha.capture("blog_cta_clicked", {
      post_title: "Boobie Goods: o guia completo para desenhos para colorir e imprimir",
      cta_name: ctaName,
      language
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
    className: "max-w-4xl mx-auto px-4 py-8",
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      className: "mb-8",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Link, {
        to: `${getLanguagePrefix()}/blog`,
        className: "inline-flex items-center text-blue-600 hover:text-blue-800 transition-colors",
        onClick: handleBackClick,
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx("svg", {
          className: "w-5 h-5 mr-2",
          fill: "none",
          stroke: "currentColor",
          viewBox: "0 0 24 24",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
            strokeLinecap: "round",
            strokeLinejoin: "round",
            strokeWidth: 2,
            d: "M10 19l-7-7m0 0l7-7m-7 7h18"
          })
        }), language === "en" ? "Back to blog" : "Voltar para o blog"]
      })
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(SEOHead, {
      title: language === "en" ? "Boobie Goods: The Complete Guide to Coloring Drawings and Printing | MylineArts" : "Boobie Goods: O Guia Completo para Desenhos para Colorir e Imprimir | MylineArts",
      description: language === "en" ? "Discover the world of Boobie Goods: coloring drawings, printing tips, creative ideas and how to create your own personalized drawings. A complete guide for parents and educators." : "Descubra o mundo dos Boobie Goods: desenhos para colorir, dicas de impressão, ideias criativas e como criar seus próprios desenhos personalizados. Um guia completo para pais e educadores.",
      keywords: language === "en" ? "boobie goods, coloring drawings, boobie goods to print, boobie goods generator, children's drawing generator, children's activities, creative education, drawings to print" : "boobie goods, desenhos para colorir, boobie goods para imprimir, gerador de boobie goods, gerador de desenho infantil, atividades infantis, educação criativa, desenhos para imprimir"
    }), /* @__PURE__ */ jsxRuntimeExports.jsxs("article", {
      className: "prose lg:prose-xl",
      children: [/* @__PURE__ */ jsxRuntimeExports.jsxs("header", {
        className: "mb-12",
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h1", {
          className: "text-4xl font-bold text-center mb-4",
          children: language === "en" ? "Boobie Goods: the complete guide to coloring drawings and printing 🎨" : "Boobie Goods: o guia completo para desenhos para colorir e imprimir 🎨"
        }), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
          className: "text-gray-600 mb-8",
          children: [/* @__PURE__ */ jsxRuntimeExports.jsx("time", {
            dateTime: "2024-03-20",
            children: "14 de junho, 2025"
          }), " • ", language === "en" ? "8 min read" : "8 min de leitura", /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
            className: "flex items-center mt-4",
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx("img", {
              src: "/blog/1/ste.jpeg",
              alt: language === "en" ? "Author: Stefanie Szabo" : "Autora: Stefanie Szabo",
              className: "w-10 h-10 rounded-full mr-3"
            }), /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
              className: "text-gray-800 font-medium",
              children: language === "en" ? "Posted by Stefanie Szabo" : "Postado por Stefanie Szabo"
            })]
          })]
        }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
          className: "mb-8",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", {
            src: "/blog/1/banner.jpeg",
            alt: language === "en" ? "Boobie Goods - Coloring Drawings" : "Boobie Goods - Desenhos para Colorir",
            className: "w-full h-128 object-cover rounded-lg shadow-lg"
          })
        })]
      }), /* @__PURE__ */ jsxRuntimeExports.jsxs("section", {
        className: "mb-12",
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h2", {
          className: "text-2xl font-bold mb-4",
          children: language === "en" ? "What are Boobie Goods? 🤔" : "O que são Boobie Goods? 🤔"
        }), /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
          className: "text-lg mb-4",
          children: language === "en" ? "Boobie Goods are unique and charming drawings that have won the hearts of children and adults around the world. Originating from a creative trend that mixes simplicity with charm, these drawings have become a valuable tool for education, therapy and fun." : "Boobie Goods são desenhos únicos e encantadores que conquistaram o coração de crianças e adultos em todo o mundo. Originários de uma tendência criativa que mistura simplicidade com charme, esses desenhos se tornaram uma ferramenta valiosa para educação, terapia e diversão."
        }), /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
          className: "text-lg mb-4",
          children: language === "en" ? "What makes Boobie Goods special is their ability to convey emotions and tell stories through simple and expressive strokes. They are perfect for coloring, personalizing and using in various educational and recreational contexts." : "O que torna os Boobie Goods especiais é sua capacidade de transmitir emoções e contar histórias através de traços simples e expressivos. Eles são perfeitos para colorir, personalizar e usar em diversos contextos educacionais e recreativos."
        }), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
          className: "bg-blue-50 p-6 rounded-lg my-8",
          children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h3", {
            className: "text-xl font-bold mb-4",
            children: language === "en" ? "Create your own Boobie Goods with MyLineArts 🎨" : "Crie seus próprios Boobie Goods com MyLineArts 🎨"
          }), /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
            className: "mb-4",
            children: language === "en" ? "With MyLineArts, you can transform your photos into personalized Boobie Goods-style drawings! Our platform uses artificial intelligence to create unique drawings that preserve the essence and emotions of your favorite memories." : "Com o MyLineArts, você pode transformar suas fotos em desenhos estilo Boobie Goods personalizados! Nossa plataforma utiliza inteligência artificial para criar desenhos únicos que preservam a essência e as emoções das suas memórias favoritas."
          }), /* @__PURE__ */ jsxRuntimeExports.jsx(Link, {
            to: `${getLanguagePrefix()}/`,
            className: "inline-block bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition-colors",
            onClick: () => handleCTAClick("criar_boobie_goods_agora"),
            children: language === "en" ? "Create My Boobie Goods Now" : "Criar Meu Boobie Goods Agora"
          })]
        })]
      }), /* @__PURE__ */ jsxRuntimeExports.jsxs("section", {
        className: "mb-12",
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h2", {
          className: "text-2xl font-bold mb-4",
          children: "Benefícios dos desenhos para colorir 🎯"
        }), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
          className: "grid grid-cols-1 md:grid-cols-2 gap-8 mb-8",
          children: [/* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h3", {
              className: "text-xl font-semibold mb-3",
              children: "Desenvolvimento infantil"
            }), /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", {
              className: "list-disc pl-6 space-y-2",
              children: [/* @__PURE__ */ jsxRuntimeExports.jsx("li", {
                children: "Melhora a coordenação motora fina"
              }), /* @__PURE__ */ jsxRuntimeExports.jsx("li", {
                children: "Desenvolve a criatividade e imaginação"
              }), /* @__PURE__ */ jsxRuntimeExports.jsx("li", {
                children: "Fortalece a concentração e foco"
              }), /* @__PURE__ */ jsxRuntimeExports.jsx("li", {
                children: "Ajuda no reconhecimento de cores e formas"
              })]
            })]
          }), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h3", {
              className: "text-xl font-semibold mb-3",
              children: "Aspectos terapêuticos"
            }), /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", {
              className: "list-disc pl-6 space-y-2",
              children: [/* @__PURE__ */ jsxRuntimeExports.jsx("li", {
                children: "Reduz o estresse e ansiedade"
              }), /* @__PURE__ */ jsxRuntimeExports.jsx("li", {
                children: "Promove relaxamento e bem-estar"
              }), /* @__PURE__ */ jsxRuntimeExports.jsx("li", {
                children: "Estimula a expressão emocional"
              }), /* @__PURE__ */ jsxRuntimeExports.jsx("li", {
                children: "Auxilia no desenvolvimento da paciência"
              })]
            })]
          })]
        }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
          className: "flex gap-4 my-8",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", {
            src: "/blog/1/taj.jpeg",
            alt: "Desenhos coloridos",
            className: "w-full h-96 object-cover object-top-left rounded-lg shadow-md"
          })
        })]
      }), /* @__PURE__ */ jsxRuntimeExports.jsxs("section", {
        className: "mb-12",
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h2", {
          className: "text-2xl font-bold mb-4",
          children: "Boobie Goods para adultos: arte e terapia 🎨"
        }), /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
          className: "text-lg mb-4",
          children: "Os Boobie Goods não são apenas para crianças! Adultos em todo o mundo estão descobrindo os benefícios terapêuticos e criativos desses desenhos. Com o MyLineArts, você pode transformar suas próprias fotos em desenhos personalizados, criando uma experiência única de arte e memória."
        }), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
          className: "grid grid-cols-1 md:grid-cols-3 gap-6 mb-8",
          children: [/* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
            className: "bg-white p-4 rounded-lg shadow-md",
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h3", {
              className: "text-lg font-semibold mb-2",
              children: "Arte terapêutica"
            }), /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
              children: "Use os desenhos como uma forma de relaxamento e expressão pessoal, transformando momentos especiais em arte."
            })]
          }), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
            className: "bg-white p-4 rounded-lg shadow-md",
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h3", {
              className: "text-lg font-semibold mb-2",
              children: "Decoração personalizada"
            }), /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
              children: "Crie quadros e murais únicos com seus próprios Boobie Goods, adicionando um toque pessoal à sua casa."
            })]
          }), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
            className: "bg-white p-4 rounded-lg shadow-md",
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h3", {
              className: "text-lg font-semibold mb-2",
              children: "Presentes especiais"
            }), /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
              children: "Transforme memórias em presentes únicos para amigos e familiares, criando conexões emocionais através da arte."
            })]
          })]
        }), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
          className: "bg-yellow-50 p-6 rounded-lg my-8",
          children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h3", {
            className: "text-xl font-bold mb-4",
            children: "Crie seus próprios Boobie Goods 🎯"
          }), /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
            className: "mb-4",
            children: "Com o MyLineArts, você pode transformar qualquer foto em um desenho estilo Boobie Goods. Nossa tecnologia de IA preserva as características únicas e as emoções das suas fotos, criando desenhos que são verdadeiramente seus."
          }), /* @__PURE__ */ jsxRuntimeExports.jsx(Link, {
            to: "/",
            className: "inline-block bg-yellow-500 text-white px-6 py-3 rounded-lg hover:bg-yellow-600 transition-colors",
            onClick: () => handleCTAClick("experimente_agora"),
            children: "Experimente Agora"
          })]
        })]
      }), /* @__PURE__ */ jsxRuntimeExports.jsxs("section", {
        className: "mb-12",
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h2", {
          className: "text-2xl font-bold mb-4",
          children: "Como imprimir e usar os desenhos 📝"
        }), /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
          className: "text-lg mb-4",
          children: "Imprimir seus Boobie Goods favoritos é mais fácil do que você imagina! Aqui está um guia passo a passo:"
        }), /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", {
          className: "list-decimal pl-6 space-y-4 mb-8",
          children: [/* @__PURE__ */ jsxRuntimeExports.jsxs("li", {
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx("strong", {
              children: "Escolha o papel ideal:"
            }), " Para melhores resultados, use papel sulfite A4 de boa qualidade. Para projetos especiais, você pode experimentar papéis mais grossos ou texturizados."]
          }), /* @__PURE__ */ jsxRuntimeExports.jsxs("li", {
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx("strong", {
              children: "Configurações de impressão:"
            }), ' Ajuste as configurações da sua impressora para "Alta Qualidade" e selecione o modo "Colorido" mesmo para desenhos em preto e branco.']
          }), /* @__PURE__ */ jsxRuntimeExports.jsxs("li", {
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx("strong", {
              children: "Escolha as cores:"
            }), " Lápis de cor, canetinhas, giz de cera ou aquarela - cada material oferece um resultado único. Experimente diferentes técnicas!"]
          })]
        }), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
          className: "bg-blue-50 p-6 rounded-lg my-8",
          children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h3", {
            className: "text-xl font-bold mb-4",
            children: "Dica pro 💡"
          }), /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
            children: "Para desenhos que serão expostos ou guardados por muito tempo, considere usar papel mais resistente e materiais de colorir de qualidade profissional. Isso garantirá que sua arte dure por muitos anos!"
          })]
        })]
      }), /* @__PURE__ */ jsxRuntimeExports.jsxs("section", {
        className: "mb-12",
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h2", {
          className: "text-2xl font-bold mb-4",
          children: "Ideias criativas para usar os desenhos 🎨"
        }), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
          className: "grid grid-cols-1 md:grid-cols-3 gap-6 mb-8",
          children: [/* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
            className: "bg-white p-4 rounded-lg shadow-md",
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h3", {
              className: "text-lg font-semibold mb-2",
              children: "Decoração"
            }), /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
              children: "Crie um mural personalizado ou decore cadernos e agendas com seus desenhos favoritos."
            })]
          }), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
            className: "bg-white p-4 rounded-lg shadow-md",
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h3", {
              className: "text-lg font-semibold mb-2",
              children: "Presentes"
            }), /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
              children: "Transforme os desenhos em cartões, marcadores de livro ou embrulhos personalizados."
            })]
          }), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
            className: "bg-white p-4 rounded-lg shadow-md",
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h3", {
              className: "text-lg font-semibold mb-2",
              children: "Educação"
            }), /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
              children: "Use os desenhos para ensinar cores, números, letras e até mesmo conceitos mais complexos."
            })]
          })]
        }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
          className: "flex gap-4 my-8",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", {
            src: "/blog/1/mulher.jpeg",
            alt: "Uso educacional",
            className: "w-full h-96 object-bottom-right rounded-lg shadow-md"
          })
        })]
      }), /* @__PURE__ */ jsxRuntimeExports.jsxs("section", {
        className: "mb-12",
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h2", {
          className: "text-2xl font-bold mb-4",
          children: "Criando seus próprios desenhos com MyLineArts 🎯"
        }), /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
          className: "text-lg mb-4",
          children: "O MyLineArts torna mais fácil do que nunca criar seus próprios Boobie Goods personalizados! Nossa plataforma utiliza tecnologia de ponta para transformar suas fotos em desenhos únicos que preservam a essência e as emoções das suas memórias."
        }), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
          className: "bg-yellow-50 p-6 rounded-lg my-8",
          children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h3", {
            className: "text-xl font-bold mb-4",
            children: "Como começar 🚀"
          }), /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", {
            className: "list-decimal pl-6 space-y-2",
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx("li", {
              children: "Escolha suas fotos favoritas"
            }), /* @__PURE__ */ jsxRuntimeExports.jsx("li", {
              children: "Selecione o estilo que mais combina com sua visão"
            }), /* @__PURE__ */ jsxRuntimeExports.jsx("li", {
              children: "Deixe nossa IA criar seu desenho único"
            }), /* @__PURE__ */ jsxRuntimeExports.jsx("li", {
              children: "Baixe e imprima seu Boobie Goods personalizado"
            })]
          }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
            className: "mt-6",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Link, {
              to: "/",
              className: "inline-block bg-yellow-500 text-white px-6 py-3 rounded-lg hover:bg-yellow-600 transition-colors",
              onClick: () => handleCTAClick("criar_desenho_agora"),
              children: "Criar Meu Desenho Agora"
            })
          })]
        })]
      }), /* @__PURE__ */ jsxRuntimeExports.jsxs("section", {
        className: "mb-12",
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h2", {
          className: "text-2xl font-bold mb-4",
          children: "Dicas para professores e pais 👨‍🏫"
        }), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
          className: "grid grid-cols-1 md:grid-cols-2 gap-8",
          children: [/* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h3", {
              className: "text-xl font-semibold mb-3",
              children: "Atividades em sala de aula"
            }), /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", {
              className: "list-disc pl-6 space-y-2",
              children: [/* @__PURE__ */ jsxRuntimeExports.jsx("li", {
                children: "Crie um projeto de arte colaborativo"
              }), /* @__PURE__ */ jsxRuntimeExports.jsx("li", {
                children: "Use os desenhos para contar histórias"
              }), /* @__PURE__ */ jsxRuntimeExports.jsx("li", {
                children: "Desenvolva exercícios de coordenação"
              }), /* @__PURE__ */ jsxRuntimeExports.jsx("li", {
                children: "Promova discussões sobre cores e formas"
              })]
            })]
          }), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h3", {
              className: "text-xl font-semibold mb-3",
              children: "Atividades em casa"
            }), /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", {
              className: "list-disc pl-6 space-y-2",
              children: [/* @__PURE__ */ jsxRuntimeExports.jsx("li", {
                children: "Organize sessões de colorir em família"
              }), /* @__PURE__ */ jsxRuntimeExports.jsx("li", {
                children: "Crie um álbum de recordações"
              }), /* @__PURE__ */ jsxRuntimeExports.jsx("li", {
                children: "Desenvolva projetos de arte sazonais"
              }), /* @__PURE__ */ jsxRuntimeExports.jsx("li", {
                children: "Use os desenhos para decorar o quarto"
              })]
            })]
          })]
        }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
          className: "flex gap-4 my-8",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", {
            src: "/blog/1/crianca.jpeg",
            alt: "Atividades em família",
            className: "w-full h-96 object-cover object-top-left rounded-lg shadow-md"
          })
        })]
      }), /* @__PURE__ */ jsxRuntimeExports.jsxs("section", {
        className: "mb-12",
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h2", {
          className: "text-2xl font-bold mb-4",
          children: "Conclusão 🌟"
        }), /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
          className: "text-lg mb-4",
          children: "Os Boobie Goods são mais do que simples desenhos para colorir - são ferramentas poderosas para desenvolvimento, criatividade e diversão. Com o MyLineArts, você pode transformar suas próprias fotos em desenhos únicos que preservam suas memórias especiais."
        }), /* @__PURE__ */ jsxRuntimeExports.jsxs("p", {
          className: "text-lg mb-4",
          children: ["Que tal começar sua jornada criativa hoje? ", /* @__PURE__ */ jsxRuntimeExports.jsx(Link, {
            to: "/",
            className: "text-blue-600 hover:text-blue-800",
            onClick: () => handleCTAClick("criar_primeiro_boobie_goods"),
            children: "Crie seu primeiro Boobie Goods personalizado"
          }), " e descubra um mundo de possibilidades!"]
        })]
      }), /* @__PURE__ */ jsxRuntimeExports.jsx("footer", {
        className: "border-t pt-8 mt-12",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
          className: "text-right",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
            className: "text-gray-600",
            children: "Atualizado em: 14 de junho, 2025"
          })
        })
      })]
    })]
  });
};
const BlogPostPage$1 = withComponentProps(BlogPostPage);
const route10 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: BlogPostPage$1
}, Symbol.toStringTag, { value: "Module" }));
const LayoutGroupContext = reactExports.createContext({});
function useConstant(init) {
  const ref2 = reactExports.useRef(null);
  if (ref2.current === null) {
    ref2.current = init();
  }
  return ref2.current;
}
const isBrowser = typeof window !== "undefined";
const useIsomorphicLayoutEffect = isBrowser ? reactExports.useLayoutEffect : reactExports.useEffect;
const PresenceContext = /* @__PURE__ */ reactExports.createContext(null);
function addUniqueItem(arr, item) {
  if (arr.indexOf(item) === -1)
    arr.push(item);
}
function removeItem(arr, item) {
  const index = arr.indexOf(item);
  if (index > -1)
    arr.splice(index, 1);
}
const clamp = (min2, max2, v2) => {
  if (v2 > max2)
    return max2;
  if (v2 < min2)
    return min2;
  return v2;
};
let invariant = () => {
};
const MotionGlobalConfig = {};
const isNumericalString = (v2) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v2);
function isObject(value) {
  return typeof value === "object" && value !== null;
}
const isZeroValueString = (v2) => /^0[^.\s]+$/u.test(v2);
// @__NO_SIDE_EFFECTS__
function memo(callback) {
  let result;
  return () => {
    if (result === void 0)
      result = callback();
    return result;
  };
}
const noop = /* @__NO_SIDE_EFFECTS__ */ (any) => any;
const combineFunctions = (a2, b2) => (v2) => b2(a2(v2));
const pipe = (...transformers) => transformers.reduce(combineFunctions);
const progress = /* @__NO_SIDE_EFFECTS__ */ (from, to2, value) => {
  const toFromDifference = to2 - from;
  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
};
class SubscriptionManager {
  constructor() {
    this.subscriptions = [];
  }
  add(handler) {
    addUniqueItem(this.subscriptions, handler);
    return () => removeItem(this.subscriptions, handler);
  }
  notify(a2, b2, c2) {
    const numSubscriptions = this.subscriptions.length;
    if (!numSubscriptions)
      return;
    if (numSubscriptions === 1) {
      this.subscriptions[0](a2, b2, c2);
    } else {
      for (let i2 = 0; i2 < numSubscriptions; i2++) {
        const handler = this.subscriptions[i2];
        handler && handler(a2, b2, c2);
      }
    }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const secondsToMilliseconds = /* @__NO_SIDE_EFFECTS__ */ (seconds) => seconds * 1e3;
const millisecondsToSeconds = /* @__NO_SIDE_EFFECTS__ */ (milliseconds) => milliseconds / 1e3;
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}
const calcBezier = (t2, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t2 + (3 * a2 - 6 * a1)) * t2 + 3 * a1) * t2;
const subdivisionPrecision = 1e-7;
const subdivisionMaxIterations = 12;
function binarySubdivide(x2, lowerBound, upperBound, mX1, mX2) {
  let currentX;
  let currentT;
  let i2 = 0;
  do {
    currentT = lowerBound + (upperBound - lowerBound) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - x2;
    if (currentX > 0) {
      upperBound = currentT;
    } else {
      lowerBound = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i2 < subdivisionMaxIterations);
  return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return noop;
  const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
  return (t2) => t2 === 0 || t2 === 1 ? t2 : calcBezier(getTForX(t2), mY1, mY2);
}
const mirrorEasing = (easing) => (p2) => p2 <= 0.5 ? easing(2 * p2) / 2 : (2 - easing(2 * (1 - p2))) / 2;
const reverseEasing = (easing) => (p2) => 1 - easing(1 - p2);
const backOut = /* @__PURE__ */ cubicBezier(0.33, 1.53, 0.69, 0.99);
const backIn = /* @__PURE__ */ reverseEasing(backOut);
const backInOut = /* @__PURE__ */ mirrorEasing(backIn);
const anticipate = (p2) => (p2 *= 2) < 1 ? 0.5 * backIn(p2) : 0.5 * (2 - Math.pow(2, -10 * (p2 - 1)));
const circIn = (p2) => 1 - Math.sin(Math.acos(p2));
const circOut = reverseEasing(circIn);
const circInOut = mirrorEasing(circIn);
const easeIn = /* @__PURE__ */ cubicBezier(0.42, 0, 1, 1);
const easeOut = /* @__PURE__ */ cubicBezier(0, 0, 0.58, 1);
const easeInOut = /* @__PURE__ */ cubicBezier(0.42, 0, 0.58, 1);
const isEasingArray = (ease2) => {
  return Array.isArray(ease2) && typeof ease2[0] !== "number";
};
const isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === "number";
const easingLookup = {
  linear: noop,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate
};
const isValidEasing = (easing) => {
  return typeof easing === "string";
};
const easingDefinitionToFunction = (definition) => {
  if (isBezierDefinition(definition)) {
    invariant(definition.length === 4);
    const [x1, y1, x2, y2] = definition;
    return cubicBezier(x1, y1, x2, y2);
  } else if (isValidEasing(definition)) {
    return easingLookup[definition];
  }
  return definition;
};
const stepsOrder = [
  "setup",
  // Compute
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "preUpdate",
  // Compute
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
];
const statsBuffer = {
  value: null
};
function createRenderStep(runNextFrame, stepName) {
  let thisFrame = /* @__PURE__ */ new Set();
  let nextFrame = /* @__PURE__ */ new Set();
  let isProcessing = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  let latestFrameData = {
    delta: 0,
    timestamp: 0,
    isProcessing: false
  };
  let numCalls = 0;
  function triggerCallback(callback) {
    if (toKeepAlive.has(callback)) {
      step.schedule(callback);
      runNextFrame();
    }
    numCalls++;
    callback(latestFrameData);
  }
  const step = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing;
      const queue = addToCurrentFrame ? thisFrame : nextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (!queue.has(callback))
        queue.add(callback);
      return callback;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (callback) => {
      nextFrame.delete(callback);
      toKeepAlive.delete(callback);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (frameData2) => {
      latestFrameData = frameData2;
      if (isProcessing) {
        flushNextFrame = true;
        return;
      }
      isProcessing = true;
      [thisFrame, nextFrame] = [nextFrame, thisFrame];
      thisFrame.forEach(triggerCallback);
      if (stepName && statsBuffer.value) {
        statsBuffer.value.frameloop[stepName].push(numCalls);
      }
      numCalls = 0;
      thisFrame.clear();
      isProcessing = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData2);
      }
    }
  };
  return step;
}
const maxElapsed = 40;
function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
  let runNextFrame = false;
  let useDefaultElapsed = true;
  const state = {
    delta: 0,
    timestamp: 0,
    isProcessing: false
  };
  const flagRunNextFrame = () => runNextFrame = true;
  const steps = stepsOrder.reduce((acc, key) => {
    acc[key] = createRenderStep(flagRunNextFrame, allowKeepAlive ? key : void 0);
    return acc;
  }, {});
  const { setup, read, resolveKeyframes, preUpdate, update, preRender, render, postRender } = steps;
  const processBatch = () => {
    const timestamp = MotionGlobalConfig.useManualTiming ? state.timestamp : performance.now();
    runNextFrame = false;
    if (!MotionGlobalConfig.useManualTiming) {
      state.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);
    }
    state.timestamp = timestamp;
    state.isProcessing = true;
    setup.process(state);
    read.process(state);
    resolveKeyframes.process(state);
    preUpdate.process(state);
    update.process(state);
    preRender.process(state);
    render.process(state);
    postRender.process(state);
    state.isProcessing = false;
    if (runNextFrame && allowKeepAlive) {
      useDefaultElapsed = false;
      scheduleNextBatch(processBatch);
    }
  };
  const wake = () => {
    runNextFrame = true;
    useDefaultElapsed = true;
    if (!state.isProcessing) {
      scheduleNextBatch(processBatch);
    }
  };
  const schedule = stepsOrder.reduce((acc, key) => {
    const step = steps[key];
    acc[key] = (process2, keepAlive = false, immediate = false) => {
      if (!runNextFrame)
        wake();
      return step.schedule(process2, keepAlive, immediate);
    };
    return acc;
  }, {});
  const cancel = (process2) => {
    for (let i2 = 0; i2 < stepsOrder.length; i2++) {
      steps[stepsOrder[i2]].cancel(process2);
    }
  };
  return { schedule, cancel, state, steps };
}
const { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps } = /* @__PURE__ */ createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop, true);
let now;
function clearTime() {
  now = void 0;
}
const time = {
  now: () => {
    if (now === void 0) {
      time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now());
    }
    return now;
  },
  set: (newTime) => {
    now = newTime;
    queueMicrotask(clearTime);
  }
};
const checkStringStartsWith = (token) => (key) => typeof key === "string" && key.startsWith(token);
const isCSSVariableName = /* @__PURE__ */ checkStringStartsWith("--");
const startsAsVariableToken = /* @__PURE__ */ checkStringStartsWith("var(--");
const isCSSVariableToken = (value) => {
  const startsWithToken = startsAsVariableToken(value);
  if (!startsWithToken)
    return false;
  return singleCssVariableRegex.test(value.split("/*")[0].trim());
};
const singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;
const number = {
  test: (v2) => typeof v2 === "number",
  parse: parseFloat,
  transform: (v2) => v2
};
const alpha = {
  ...number,
  transform: (v2) => clamp(0, 1, v2)
};
const scale = {
  ...number,
  default: 1
};
const sanitize = (v2) => Math.round(v2 * 1e5) / 1e5;
const floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function isNullish(v2) {
  return v2 == null;
}
const singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;
const isColorString = (type2, testProp) => (v2) => {
  return Boolean(typeof v2 === "string" && singleColorRegex.test(v2) && v2.startsWith(type2) || testProp && !isNullish(v2) && Object.prototype.hasOwnProperty.call(v2, testProp));
};
const splitColor = (aName, bName, cName) => (v2) => {
  if (typeof v2 !== "string")
    return v2;
  const [a2, b2, c2, alpha2] = v2.match(floatRegex);
  return {
    [aName]: parseFloat(a2),
    [bName]: parseFloat(b2),
    [cName]: parseFloat(c2),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
};
const clampRgbUnit = (v2) => clamp(0, 255, v2);
const rgbUnit = {
  ...number,
  transform: (v2) => Math.round(clampRgbUnit(v2))
};
const rgba = {
  test: /* @__PURE__ */ isColorString("rgb", "red"),
  parse: /* @__PURE__ */ splitColor("red", "green", "blue"),
  transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
};
function parseHex(v2) {
  let r2 = "";
  let g2 = "";
  let b2 = "";
  let a2 = "";
  if (v2.length > 5) {
    r2 = v2.substring(1, 3);
    g2 = v2.substring(3, 5);
    b2 = v2.substring(5, 7);
    a2 = v2.substring(7, 9);
  } else {
    r2 = v2.substring(1, 2);
    g2 = v2.substring(2, 3);
    b2 = v2.substring(3, 4);
    a2 = v2.substring(4, 5);
    r2 += r2;
    g2 += g2;
    b2 += b2;
    a2 += a2;
  }
  return {
    red: parseInt(r2, 16),
    green: parseInt(g2, 16),
    blue: parseInt(b2, 16),
    alpha: a2 ? parseInt(a2, 16) / 255 : 1
  };
}
const hex = {
  test: /* @__PURE__ */ isColorString("#"),
  parse: parseHex,
  transform: rgba.transform
};
const createUnitType = /* @__NO_SIDE_EFFECTS__ */ (unit) => ({
  test: (v2) => typeof v2 === "string" && v2.endsWith(unit) && v2.split(" ").length === 1,
  parse: parseFloat,
  transform: (v2) => `${v2}${unit}`
});
const degrees = /* @__PURE__ */ createUnitType("deg");
const percent = /* @__PURE__ */ createUnitType("%");
const px = /* @__PURE__ */ createUnitType("px");
const vh = /* @__PURE__ */ createUnitType("vh");
const vw = /* @__PURE__ */ createUnitType("vw");
const progressPercentage = /* @__PURE__ */ (() => ({
  ...percent,
  parse: (v2) => percent.parse(v2) / 100,
  transform: (v2) => percent.transform(v2 * 100)
}))();
const hsla = {
  test: /* @__PURE__ */ isColorString("hsl", "hue"),
  parse: /* @__PURE__ */ splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
    return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
  }
};
const color = {
  test: (v2) => rgba.test(v2) || hex.test(v2) || hsla.test(v2),
  parse: (v2) => {
    if (rgba.test(v2)) {
      return rgba.parse(v2);
    } else if (hsla.test(v2)) {
      return hsla.parse(v2);
    } else {
      return hex.parse(v2);
    }
  },
  transform: (v2) => {
    return typeof v2 === "string" ? v2 : v2.hasOwnProperty("red") ? rgba.transform(v2) : hsla.transform(v2);
  },
  getAnimatableNone: (v2) => {
    const parsed = color.parse(v2);
    parsed.alpha = 0;
    return color.transform(parsed);
  }
};
const colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function test(v2) {
  return isNaN(v2) && typeof v2 === "string" && (v2.match(floatRegex)?.length || 0) + (v2.match(colorRegex)?.length || 0) > 0;
}
const NUMBER_TOKEN = "number";
const COLOR_TOKEN = "color";
const VAR_TOKEN = "var";
const VAR_FUNCTION_TOKEN = "var(";
const SPLIT_TOKEN = "${}";
const complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function analyseComplexValue(value) {
  const originalValue = value.toString();
  const values = [];
  const indexes = {
    color: [],
    number: [],
    var: []
  };
  const types2 = [];
  let i2 = 0;
  const tokenised = originalValue.replace(complexRegex, (parsedValue) => {
    if (color.test(parsedValue)) {
      indexes.color.push(i2);
      types2.push(COLOR_TOKEN);
      values.push(color.parse(parsedValue));
    } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {
      indexes.var.push(i2);
      types2.push(VAR_TOKEN);
      values.push(parsedValue);
    } else {
      indexes.number.push(i2);
      types2.push(NUMBER_TOKEN);
      values.push(parseFloat(parsedValue));
    }
    ++i2;
    return SPLIT_TOKEN;
  });
  const split = tokenised.split(SPLIT_TOKEN);
  return { values, split, indexes, types: types2 };
}
function parseComplexValue(v2) {
  return analyseComplexValue(v2).values;
}
function createTransformer(source) {
  const { split, types: types2 } = analyseComplexValue(source);
  const numSections = split.length;
  return (v2) => {
    let output = "";
    for (let i2 = 0; i2 < numSections; i2++) {
      output += split[i2];
      if (v2[i2] !== void 0) {
        const type2 = types2[i2];
        if (type2 === NUMBER_TOKEN) {
          output += sanitize(v2[i2]);
        } else if (type2 === COLOR_TOKEN) {
          output += color.transform(v2[i2]);
        } else {
          output += v2[i2];
        }
      }
    }
    return output;
  };
}
const convertNumbersToZero = (v2) => typeof v2 === "number" ? 0 : color.test(v2) ? color.getAnimatableNone(v2) : v2;
function getAnimatableNone$1(v2) {
  const parsed = parseComplexValue(v2);
  const transformer = createTransformer(v2);
  return transformer(parsed.map(convertNumbersToZero));
}
const complex = {
  test,
  parse: parseComplexValue,
  createTransformer,
  getAnimatableNone: getAnimatableNone$1
};
function hueToRgb(p2, q2, t2) {
  if (t2 < 0)
    t2 += 1;
  if (t2 > 1)
    t2 -= 1;
  if (t2 < 1 / 6)
    return p2 + (q2 - p2) * 6 * t2;
  if (t2 < 1 / 2)
    return q2;
  if (t2 < 2 / 3)
    return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
  return p2;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red = 0;
  let green = 0;
  let blue = 0;
  if (!saturation) {
    red = green = blue = lightness;
  } else {
    const q2 = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
    const p2 = 2 * lightness - q2;
    red = hueToRgb(p2, q2, hue + 1 / 3);
    green = hueToRgb(p2, q2, hue);
    blue = hueToRgb(p2, q2, hue - 1 / 3);
  }
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue * 255),
    alpha: alpha2
  };
}
function mixImmediate(a2, b2) {
  return (p2) => p2 > 0 ? b2 : a2;
}
const mixNumber$1 = (from, to2, progress2) => {
  return from + (to2 - from) * progress2;
};
const mixLinearColor = (from, to2, v2) => {
  const fromExpo = from * from;
  const expo = v2 * (to2 * to2 - fromExpo) + fromExpo;
  return expo < 0 ? 0 : Math.sqrt(expo);
};
const colorTypes = [hex, rgba, hsla];
const getColorType = (v2) => colorTypes.find((type2) => type2.test(v2));
function asRGBA(color2) {
  const type2 = getColorType(color2);
  if (!Boolean(type2))
    return false;
  let model = type2.parse(color2);
  if (type2 === hsla) {
    model = hslaToRgba(model);
  }
  return model;
}
const mixColor = (from, to2) => {
  const fromRGBA = asRGBA(from);
  const toRGBA = asRGBA(to2);
  if (!fromRGBA || !toRGBA) {
    return mixImmediate(from, to2);
  }
  const blended = { ...fromRGBA };
  return (v2) => {
    blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v2);
    blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v2);
    blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v2);
    blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v2);
    return rgba.transform(blended);
  };
};
const invisibleValues = /* @__PURE__ */ new Set(["none", "hidden"]);
function mixVisibility(origin, target) {
  if (invisibleValues.has(origin)) {
    return (p2) => p2 <= 0 ? origin : target;
  } else {
    return (p2) => p2 >= 1 ? target : origin;
  }
}
function mixNumber(a2, b2) {
  return (p2) => mixNumber$1(a2, b2, p2);
}
function getMixer(a2) {
  if (typeof a2 === "number") {
    return mixNumber;
  } else if (typeof a2 === "string") {
    return isCSSVariableToken(a2) ? mixImmediate : color.test(a2) ? mixColor : mixComplex;
  } else if (Array.isArray(a2)) {
    return mixArray;
  } else if (typeof a2 === "object") {
    return color.test(a2) ? mixColor : mixObject;
  }
  return mixImmediate;
}
function mixArray(a2, b2) {
  const output = [...a2];
  const numValues = output.length;
  const blendValue = a2.map((v2, i2) => getMixer(v2)(v2, b2[i2]));
  return (p2) => {
    for (let i2 = 0; i2 < numValues; i2++) {
      output[i2] = blendValue[i2](p2);
    }
    return output;
  };
}
function mixObject(a2, b2) {
  const output = { ...a2, ...b2 };
  const blendValue = {};
  for (const key in output) {
    if (a2[key] !== void 0 && b2[key] !== void 0) {
      blendValue[key] = getMixer(a2[key])(a2[key], b2[key]);
    }
  }
  return (v2) => {
    for (const key in blendValue) {
      output[key] = blendValue[key](v2);
    }
    return output;
  };
}
function matchOrder(origin, target) {
  const orderedOrigin = [];
  const pointers = { color: 0, var: 0, number: 0 };
  for (let i2 = 0; i2 < target.values.length; i2++) {
    const type2 = target.types[i2];
    const originIndex = origin.indexes[type2][pointers[type2]];
    const originValue = origin.values[originIndex] ?? 0;
    orderedOrigin[i2] = originValue;
    pointers[type2]++;
  }
  return orderedOrigin;
}
const mixComplex = (origin, target) => {
  const template = complex.createTransformer(target);
  const originStats = analyseComplexValue(origin);
  const targetStats = analyseComplexValue(target);
  const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;
  if (canInterpolate) {
    if (invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length) {
      return mixVisibility(origin, target);
    }
    return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
  } else {
    return mixImmediate(origin, target);
  }
};
function mix(from, to2, p2) {
  if (typeof from === "number" && typeof to2 === "number" && typeof p2 === "number") {
    return mixNumber$1(from, to2, p2);
  }
  const mixer = getMixer(from);
  return mixer(from, to2);
}
const frameloopDriver = (update) => {
  const passTimestamp = ({ timestamp }) => update(timestamp);
  return {
    start: (keepAlive = true) => frame.update(passTimestamp, keepAlive),
    stop: () => cancelFrame(passTimestamp),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => frameData.isProcessing ? frameData.timestamp : time.now()
  };
};
const generateLinearEasing = (easing, duration, resolution = 10) => {
  let points = "";
  const numPoints = Math.max(Math.round(duration / resolution), 2);
  for (let i2 = 0; i2 < numPoints; i2++) {
    points += Math.round(easing(i2 / (numPoints - 1)) * 1e4) / 1e4 + ", ";
  }
  return `linear(${points.substring(0, points.length - 2)})`;
};
const maxGeneratorDuration = 2e4;
function calcGeneratorDuration(generator) {
  let duration = 0;
  const timeStep = 50;
  let state = generator.next(duration);
  while (!state.done && duration < maxGeneratorDuration) {
    duration += timeStep;
    state = generator.next(duration);
  }
  return duration >= maxGeneratorDuration ? Infinity : duration;
}
function createGeneratorEasing(options, scale2 = 100, createGenerator) {
  const generator = createGenerator({ ...options, keyframes: [0, scale2] });
  const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
  return {
    type: "keyframes",
    ease: (progress2) => {
      return generator.next(duration * progress2).value / scale2;
    },
    duration: /* @__PURE__ */ millisecondsToSeconds(duration)
  };
}
const velocitySampleDuration = 5;
function calcGeneratorVelocity(resolveValue, t2, current) {
  const prevT = Math.max(t2 - velocitySampleDuration, 0);
  return velocityPerSecond(current - resolveValue(prevT), t2 - prevT);
}
const springDefaults = {
  // Default spring physics
  stiffness: 100,
  damping: 10,
  mass: 1,
  velocity: 0,
  // Default duration/bounce-based options
  duration: 800,
  // in ms
  bounce: 0.3,
  visualDuration: 0.3,
  // in seconds
  // Rest thresholds
  restSpeed: {
    granular: 0.01,
    default: 2
  },
  restDelta: {
    granular: 5e-3,
    default: 0.5
  },
  // Limits
  minDuration: 0.01,
  // in seconds
  maxDuration: 10,
  // in seconds
  minDamping: 0.05,
  maxDamping: 1
};
const safeMin = 1e-3;
function findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass }) {
  let envelope;
  let derivative;
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);
  duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, /* @__PURE__ */ millisecondsToSeconds(duration));
  if (dampingRatio < 1) {
    envelope = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const a2 = exponentialDecay - velocity;
      const b2 = calcAngularFreq(undampedFreq2, dampingRatio);
      const c2 = Math.exp(-delta);
      return safeMin - a2 / b2 * c2;
    };
    derivative = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const d2 = delta * velocity + velocity;
      const e2 = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
      const f2 = Math.exp(-delta);
      const g2 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
      return factor * ((d2 - e2) * f2) / g2;
    };
  } else {
    envelope = (undampedFreq2) => {
      const a2 = Math.exp(-undampedFreq2 * duration);
      const b2 = (undampedFreq2 - velocity) * duration + 1;
      return -safeMin + a2 * b2;
    };
    derivative = (undampedFreq2) => {
      const a2 = Math.exp(-undampedFreq2 * duration);
      const b2 = (velocity - undampedFreq2) * (duration * duration);
      return a2 * b2;
    };
  }
  const initialGuess = 5 / duration;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration = /* @__PURE__ */ secondsToMilliseconds(duration);
  if (isNaN(undampedFreq)) {
    return {
      stiffness: springDefaults.stiffness,
      damping: springDefaults.damping,
      duration
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
const rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i2 = 1; i2 < rootIterations; i2++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}
const durationKeys = ["duration", "bounce"];
const physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys) {
  return keys.some((key) => options[key] !== void 0);
}
function getSpringOptions(options) {
  let springOptions = {
    velocity: springDefaults.velocity,
    stiffness: springDefaults.stiffness,
    damping: springDefaults.damping,
    mass: springDefaults.mass,
    isResolvedFromDuration: false,
    ...options
  };
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    if (options.visualDuration) {
      const visualDuration = options.visualDuration;
      const root2 = 2 * Math.PI / (visualDuration * 1.2);
      const stiffness = root2 * root2;
      const damping = 2 * clamp(0.05, 1, 1 - (options.bounce || 0)) * Math.sqrt(stiffness);
      springOptions = {
        ...springOptions,
        mass: springDefaults.mass,
        stiffness,
        damping
      };
    } else {
      const derived = findSpring(options);
      springOptions = {
        ...springOptions,
        ...derived,
        mass: springDefaults.mass
      };
      springOptions.isResolvedFromDuration = true;
    }
  }
  return springOptions;
}
function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {
  const options = typeof optionsOrVisualDuration !== "object" ? {
    visualDuration: optionsOrVisualDuration,
    keyframes: [0, 1],
    bounce
  } : optionsOrVisualDuration;
  let { restSpeed, restDelta } = options;
  const origin = options.keyframes[0];
  const target = options.keyframes[options.keyframes.length - 1];
  const state = { done: false, value: origin };
  const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration } = getSpringOptions({
    ...options,
    velocity: -/* @__PURE__ */ millisecondsToSeconds(options.velocity || 0)
  });
  const initialVelocity = velocity || 0;
  const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
  const initialDelta = target - origin;
  const undampedAngularFreq = /* @__PURE__ */ millisecondsToSeconds(Math.sqrt(stiffness / mass));
  const isGranularScale = Math.abs(initialDelta) < 5;
  restSpeed || (restSpeed = isGranularScale ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default);
  restDelta || (restDelta = isGranularScale ? springDefaults.restDelta.granular : springDefaults.restDelta.default);
  let resolveSpring;
  if (dampingRatio < 1) {
    const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
    resolveSpring = (t2) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t2) + initialDelta * Math.cos(angularFreq * t2));
    };
  } else if (dampingRatio === 1) {
    resolveSpring = (t2) => target - Math.exp(-undampedAngularFreq * t2) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t2);
  } else {
    const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
    resolveSpring = (t2) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
      const freqForT = Math.min(dampedAngularFreq * t2, 300);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
    };
  }
  const generator = {
    calculatedDuration: isResolvedFromDuration ? duration || null : null,
    next: (t2) => {
      const current = resolveSpring(t2);
      if (!isResolvedFromDuration) {
        let currentVelocity = t2 === 0 ? initialVelocity : 0;
        if (dampingRatio < 1) {
          currentVelocity = t2 === 0 ? /* @__PURE__ */ secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t2, current);
        }
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state.done = t2 >= duration;
      }
      state.value = state.done ? target : current;
      return state;
    },
    toString: () => {
      const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
      const easing = generateLinearEasing((progress2) => generator.next(calculatedDuration * progress2).value, calculatedDuration, 30);
      return calculatedDuration + "ms " + easing;
    },
    toTransition: () => {
    }
  };
  return generator;
}
spring.applyToOptions = (options) => {
  const generatorOptions = createGeneratorEasing(options, 100, spring);
  options.ease = generatorOptions.ease;
  options.duration = /* @__PURE__ */ secondsToMilliseconds(generatorOptions.duration);
  options.type = "keyframes";
  return options;
};
function inertia({ keyframes: keyframes2, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min: min2, max: max2, restDelta = 0.5, restSpeed }) {
  const origin = keyframes2[0];
  const state = {
    done: false,
    value: origin
  };
  const isOutOfBounds = (v2) => min2 !== void 0 && v2 < min2 || max2 !== void 0 && v2 > max2;
  const nearestBoundary = (v2) => {
    if (min2 === void 0)
      return max2;
    if (max2 === void 0)
      return min2;
    return Math.abs(min2 - v2) < Math.abs(max2 - v2) ? min2 : max2;
  };
  let amplitude = power * velocity;
  const ideal = origin + amplitude;
  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  if (target !== ideal)
    amplitude = target - origin;
  const calcDelta = (t2) => -amplitude * Math.exp(-t2 / timeConstant);
  const calcLatest = (t2) => target + calcDelta(t2);
  const applyFriction = (t2) => {
    const delta = calcDelta(t2);
    const latest = calcLatest(t2);
    state.done = Math.abs(delta) <= restDelta;
    state.value = state.done ? target : latest;
  };
  let timeReachedBoundary;
  let spring$1;
  const checkCatchBoundary = (t2) => {
    if (!isOutOfBounds(state.value))
      return;
    timeReachedBoundary = t2;
    spring$1 = spring({
      keyframes: [state.value, nearestBoundary(state.value)],
      velocity: calcGeneratorVelocity(calcLatest, t2, state.value),
      // TODO: This should be passing * 1000
      damping: bounceDamping,
      stiffness: bounceStiffness,
      restDelta,
      restSpeed
    });
  };
  checkCatchBoundary(0);
  return {
    calculatedDuration: null,
    next: (t2) => {
      let hasUpdatedFrame = false;
      if (!spring$1 && timeReachedBoundary === void 0) {
        hasUpdatedFrame = true;
        applyFriction(t2);
        checkCatchBoundary(t2);
      }
      if (timeReachedBoundary !== void 0 && t2 >= timeReachedBoundary) {
        return spring$1.next(t2 - timeReachedBoundary);
      } else {
        !hasUpdatedFrame && applyFriction(t2);
        return state;
      }
    }
  };
}
function createMixers(output, ease2, customMixer) {
  const mixers = [];
  const mixerFactory = customMixer || MotionGlobalConfig.mix || mix;
  const numMixers = output.length - 1;
  for (let i2 = 0; i2 < numMixers; i2++) {
    let mixer = mixerFactory(output[i2], output[i2 + 1]);
    if (ease2) {
      const easingFunction = Array.isArray(ease2) ? ease2[i2] || noop : ease2;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function interpolate(input, output, { clamp: isClamp = true, ease: ease2, mixer } = {}) {
  const inputLength = input.length;
  invariant(inputLength === output.length);
  if (inputLength === 1)
    return () => output[0];
  if (inputLength === 2 && output[0] === output[1])
    return () => output[1];
  const isZeroDeltaRange = input[0] === input[1];
  if (input[0] > input[inputLength - 1]) {
    input = [...input].reverse();
    output = [...output].reverse();
  }
  const mixers = createMixers(output, ease2, mixer);
  const numMixers = mixers.length;
  const interpolator = (v2) => {
    if (isZeroDeltaRange && v2 < input[0])
      return output[0];
    let i2 = 0;
    if (numMixers > 1) {
      for (; i2 < input.length - 2; i2++) {
        if (v2 < input[i2 + 1])
          break;
      }
    }
    const progressInRange = /* @__PURE__ */ progress(input[i2], input[i2 + 1], v2);
    return mixers[i2](progressInRange);
  };
  return isClamp ? (v2) => interpolator(clamp(input[0], input[inputLength - 1], v2)) : interpolator;
}
function fillOffset(offset, remaining) {
  const min2 = offset[offset.length - 1];
  for (let i2 = 1; i2 <= remaining; i2++) {
    const offsetProgress = /* @__PURE__ */ progress(0, remaining, i2);
    offset.push(mixNumber$1(min2, 1, offsetProgress));
  }
}
function defaultOffset(arr) {
  const offset = [0];
  fillOffset(offset, arr.length - 1);
  return offset;
}
function convertOffsetToTimes(offset, duration) {
  return offset.map((o2) => o2 * duration);
}
function defaultEasing(values, easing) {
  return values.map(() => easing || easeInOut).splice(0, values.length - 1);
}
function keyframes({ duration = 300, keyframes: keyframeValues, times, ease: ease2 = "easeInOut" }) {
  const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2);
  const state = {
    done: false,
    value: keyframeValues[0]
  };
  const absoluteTimes = convertOffsetToTimes(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
    duration
  );
  const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
    ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
  });
  return {
    calculatedDuration: duration,
    next: (t2) => {
      state.value = mapTimeToKeyframe(t2);
      state.done = t2 >= duration;
      return state;
    }
  };
}
const isNotNull$1 = (value) => value !== null;
function getFinalKeyframe$1(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe, speed = 1) {
  const resolvedKeyframes = keyframes2.filter(isNotNull$1);
  const useFirstKeyframe = speed < 0 || repeat && repeatType !== "loop" && repeat % 2 === 1;
  const index = useFirstKeyframe ? 0 : resolvedKeyframes.length - 1;
  return !index || finalKeyframe === void 0 ? resolvedKeyframes[index] : finalKeyframe;
}
const transitionTypeMap = {
  decay: inertia,
  inertia,
  tween: keyframes,
  keyframes,
  spring
};
function replaceTransitionType(transition) {
  if (typeof transition.type === "string") {
    transition.type = transitionTypeMap[transition.type];
  }
}
class WithPromise {
  constructor() {
    this.updateFinished();
  }
  get finished() {
    return this._finished;
  }
  updateFinished() {
    this._finished = new Promise((resolve) => {
      this.resolve = resolve;
    });
  }
  notifyFinished() {
    this.resolve();
  }
  /**
   * Allows the animation to be awaited.
   *
   * @deprecated Use `finished` instead.
   */
  then(onResolve, onReject) {
    return this.finished.then(onResolve, onReject);
  }
}
const percentToProgress = (percent2) => percent2 / 100;
class JSAnimation extends WithPromise {
  constructor(options) {
    super();
    this.state = "idle";
    this.startTime = null;
    this.isStopped = false;
    this.currentTime = 0;
    this.holdTime = null;
    this.playbackSpeed = 1;
    this.stop = () => {
      const { motionValue: motionValue2 } = this.options;
      if (motionValue2 && motionValue2.updatedAt !== time.now()) {
        this.tick(time.now());
      }
      this.isStopped = true;
      if (this.state === "idle")
        return;
      this.teardown();
      this.options.onStop?.();
    };
    this.options = options;
    this.initAnimation();
    this.play();
    if (options.autoplay === false)
      this.pause();
  }
  initAnimation() {
    const { options } = this;
    replaceTransitionType(options);
    const { type: type2 = keyframes, repeat = 0, repeatDelay = 0, repeatType, velocity = 0 } = options;
    let { keyframes: keyframes$1 } = options;
    const generatorFactory = type2 || keyframes;
    if (generatorFactory !== keyframes && typeof keyframes$1[0] !== "number") {
      this.mixKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));
      keyframes$1 = [0, 100];
    }
    const generator = generatorFactory({ ...options, keyframes: keyframes$1 });
    if (repeatType === "mirror") {
      this.mirroredGenerator = generatorFactory({
        ...options,
        keyframes: [...keyframes$1].reverse(),
        velocity: -velocity
      });
    }
    if (generator.calculatedDuration === null) {
      generator.calculatedDuration = calcGeneratorDuration(generator);
    }
    const { calculatedDuration } = generator;
    this.calculatedDuration = calculatedDuration;
    this.resolvedDuration = calculatedDuration + repeatDelay;
    this.totalDuration = this.resolvedDuration * (repeat + 1) - repeatDelay;
    this.generator = generator;
  }
  updateTime(timestamp) {
    const animationTime = Math.round(timestamp - this.startTime) * this.playbackSpeed;
    if (this.holdTime !== null) {
      this.currentTime = this.holdTime;
    } else {
      this.currentTime = animationTime;
    }
  }
  tick(timestamp, sample = false) {
    const { generator, totalDuration, mixKeyframes, mirroredGenerator, resolvedDuration, calculatedDuration } = this;
    if (this.startTime === null)
      return generator.next(0);
    const { delay: delay2 = 0, keyframes: keyframes2, repeat, repeatType, repeatDelay, type: type2, onUpdate, finalKeyframe } = this.options;
    if (this.speed > 0) {
      this.startTime = Math.min(this.startTime, timestamp);
    } else if (this.speed < 0) {
      this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);
    }
    if (sample) {
      this.currentTime = timestamp;
    } else {
      this.updateTime(timestamp);
    }
    const timeWithoutDelay = this.currentTime - delay2 * (this.playbackSpeed >= 0 ? 1 : -1);
    const isInDelayPhase = this.playbackSpeed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
    this.currentTime = Math.max(timeWithoutDelay, 0);
    if (this.state === "finished" && this.holdTime === null) {
      this.currentTime = totalDuration;
    }
    let elapsed = this.currentTime;
    let frameGenerator = generator;
    if (repeat) {
      const progress2 = Math.min(this.currentTime, totalDuration) / resolvedDuration;
      let currentIteration = Math.floor(progress2);
      let iterationProgress = progress2 % 1;
      if (!iterationProgress && progress2 >= 1) {
        iterationProgress = 1;
      }
      iterationProgress === 1 && currentIteration--;
      currentIteration = Math.min(currentIteration, repeat + 1);
      const isOddIteration = Boolean(currentIteration % 2);
      if (isOddIteration) {
        if (repeatType === "reverse") {
          iterationProgress = 1 - iterationProgress;
          if (repeatDelay) {
            iterationProgress -= repeatDelay / resolvedDuration;
          }
        } else if (repeatType === "mirror") {
          frameGenerator = mirroredGenerator;
        }
      }
      elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;
    }
    const state = isInDelayPhase ? { done: false, value: keyframes2[0] } : frameGenerator.next(elapsed);
    if (mixKeyframes) {
      state.value = mixKeyframes(state.value);
    }
    let { done } = state;
    if (!isInDelayPhase && calculatedDuration !== null) {
      done = this.playbackSpeed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;
    }
    const isAnimationFinished = this.holdTime === null && (this.state === "finished" || this.state === "running" && done);
    if (isAnimationFinished && type2 !== inertia) {
      state.value = getFinalKeyframe$1(keyframes2, this.options, finalKeyframe, this.speed);
    }
    if (onUpdate) {
      onUpdate(state.value);
    }
    if (isAnimationFinished) {
      this.finish();
    }
    return state;
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(resolve, reject) {
    return this.finished.then(resolve, reject);
  }
  get duration() {
    return /* @__PURE__ */ millisecondsToSeconds(this.calculatedDuration);
  }
  get time() {
    return /* @__PURE__ */ millisecondsToSeconds(this.currentTime);
  }
  set time(newTime) {
    newTime = /* @__PURE__ */ secondsToMilliseconds(newTime);
    this.currentTime = newTime;
    if (this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0) {
      this.holdTime = newTime;
    } else if (this.driver) {
      this.startTime = this.driver.now() - newTime / this.playbackSpeed;
    }
    this.driver?.start(false);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(newSpeed) {
    this.updateTime(time.now());
    const hasChanged = this.playbackSpeed !== newSpeed;
    this.playbackSpeed = newSpeed;
    if (hasChanged) {
      this.time = /* @__PURE__ */ millisecondsToSeconds(this.currentTime);
    }
  }
  play() {
    if (this.isStopped)
      return;
    const { driver = frameloopDriver, startTime } = this.options;
    if (!this.driver) {
      this.driver = driver((timestamp) => this.tick(timestamp));
    }
    this.options.onPlay?.();
    const now2 = this.driver.now();
    if (this.state === "finished") {
      this.updateFinished();
      this.startTime = now2;
    } else if (this.holdTime !== null) {
      this.startTime = now2 - this.holdTime;
    } else if (!this.startTime) {
      this.startTime = startTime ?? now2;
    }
    if (this.state === "finished" && this.speed < 0) {
      this.startTime += this.calculatedDuration;
    }
    this.holdTime = null;
    this.state = "running";
    this.driver.start();
  }
  pause() {
    this.state = "paused";
    this.updateTime(time.now());
    this.holdTime = this.currentTime;
  }
  complete() {
    if (this.state !== "running") {
      this.play();
    }
    this.state = "finished";
    this.holdTime = null;
  }
  finish() {
    this.notifyFinished();
    this.teardown();
    this.state = "finished";
    this.options.onComplete?.();
  }
  cancel() {
    this.holdTime = null;
    this.startTime = 0;
    this.tick(0);
    this.teardown();
    this.options.onCancel?.();
  }
  teardown() {
    this.state = "idle";
    this.stopDriver();
    this.startTime = this.holdTime = null;
  }
  stopDriver() {
    if (!this.driver)
      return;
    this.driver.stop();
    this.driver = void 0;
  }
  sample(sampleTime) {
    this.startTime = 0;
    return this.tick(sampleTime, true);
  }
  attachTimeline(timeline) {
    if (this.options.allowFlatten) {
      this.options.type = "keyframes";
      this.options.ease = "linear";
      this.initAnimation();
    }
    this.driver?.stop();
    return timeline.observe(this);
  }
}
function fillWildcards(keyframes2) {
  for (let i2 = 1; i2 < keyframes2.length; i2++) {
    keyframes2[i2] ?? (keyframes2[i2] = keyframes2[i2 - 1]);
  }
}
const radToDeg = (rad) => rad * 180 / Math.PI;
const rotate = (v2) => {
  const angle = radToDeg(Math.atan2(v2[1], v2[0]));
  return rebaseAngle(angle);
};
const matrix2dParsers = {
  x: 4,
  y: 5,
  translateX: 4,
  translateY: 5,
  scaleX: 0,
  scaleY: 3,
  scale: (v2) => (Math.abs(v2[0]) + Math.abs(v2[3])) / 2,
  rotate,
  rotateZ: rotate,
  skewX: (v2) => radToDeg(Math.atan(v2[1])),
  skewY: (v2) => radToDeg(Math.atan(v2[2])),
  skew: (v2) => (Math.abs(v2[1]) + Math.abs(v2[2])) / 2
};
const rebaseAngle = (angle) => {
  angle = angle % 360;
  if (angle < 0)
    angle += 360;
  return angle;
};
const rotateZ = rotate;
const scaleX = (v2) => Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);
const scaleY = (v2) => Math.sqrt(v2[4] * v2[4] + v2[5] * v2[5]);
const matrix3dParsers = {
  x: 12,
  y: 13,
  z: 14,
  translateX: 12,
  translateY: 13,
  translateZ: 14,
  scaleX,
  scaleY,
  scale: (v2) => (scaleX(v2) + scaleY(v2)) / 2,
  rotateX: (v2) => rebaseAngle(radToDeg(Math.atan2(v2[6], v2[5]))),
  rotateY: (v2) => rebaseAngle(radToDeg(Math.atan2(-v2[2], v2[0]))),
  rotateZ,
  rotate: rotateZ,
  skewX: (v2) => radToDeg(Math.atan(v2[4])),
  skewY: (v2) => radToDeg(Math.atan(v2[1])),
  skew: (v2) => (Math.abs(v2[1]) + Math.abs(v2[4])) / 2
};
function defaultTransformValue(name) {
  return name.includes("scale") ? 1 : 0;
}
function parseValueFromTransform(transform, name) {
  if (!transform || transform === "none") {
    return defaultTransformValue(name);
  }
  const matrix3dMatch = transform.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
  let parsers;
  let match;
  if (matrix3dMatch) {
    parsers = matrix3dParsers;
    match = matrix3dMatch;
  } else {
    const matrix2dMatch = transform.match(/^matrix\(([-\d.e\s,]+)\)$/u);
    parsers = matrix2dParsers;
    match = matrix2dMatch;
  }
  if (!match) {
    return defaultTransformValue(name);
  }
  const valueParser = parsers[name];
  const values = match[1].split(",").map(convertTransformToNumber);
  return typeof valueParser === "function" ? valueParser(values) : values[valueParser];
}
const readTransformValue = (instance, name) => {
  const { transform = "none" } = getComputedStyle(instance);
  return parseValueFromTransform(transform, name);
};
function convertTransformToNumber(value) {
  return parseFloat(value.trim());
}
const transformPropOrder = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
];
const transformProps = /* @__PURE__ */ (() => new Set(transformPropOrder))();
const isNumOrPxType = (v2) => v2 === number || v2 === px;
const transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
const nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
function removeNonTranslationalTransform(visualElement) {
  const removedTransforms = [];
  nonTranslationalTransformKeys.forEach((key) => {
    const value = visualElement.getValue(key);
    if (value !== void 0) {
      removedTransforms.push([key, value.get()]);
      value.set(key.startsWith("scale") ? 1 : 0);
    }
  });
  return removedTransforms;
}
const positionalValues = {
  // Dimensions
  width: ({ x: x2 }, { paddingLeft = "0", paddingRight = "0" }) => x2.max - x2.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
  height: ({ y: y2 }, { paddingTop = "0", paddingBottom = "0" }) => y2.max - y2.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
  top: (_bbox, { top }) => parseFloat(top),
  left: (_bbox, { left }) => parseFloat(left),
  bottom: ({ y: y2 }, { top }) => parseFloat(top) + (y2.max - y2.min),
  right: ({ x: x2 }, { left }) => parseFloat(left) + (x2.max - x2.min),
  // Transform
  x: (_bbox, { transform }) => parseValueFromTransform(transform, "x"),
  y: (_bbox, { transform }) => parseValueFromTransform(transform, "y")
};
positionalValues.translateX = positionalValues.x;
positionalValues.translateY = positionalValues.y;
const toResolve = /* @__PURE__ */ new Set();
let isScheduled = false;
let anyNeedsMeasurement = false;
let isForced = false;
function measureAllKeyframes() {
  if (anyNeedsMeasurement) {
    const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);
    const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));
    const transformsToRestore = /* @__PURE__ */ new Map();
    elementsToMeasure.forEach((element) => {
      const removedTransforms = removeNonTranslationalTransform(element);
      if (!removedTransforms.length)
        return;
      transformsToRestore.set(element, removedTransforms);
      element.render();
    });
    resolversToMeasure.forEach((resolver) => resolver.measureInitialState());
    elementsToMeasure.forEach((element) => {
      element.render();
      const restore = transformsToRestore.get(element);
      if (restore) {
        restore.forEach(([key, value]) => {
          element.getValue(key)?.set(value);
        });
      }
    });
    resolversToMeasure.forEach((resolver) => resolver.measureEndState());
    resolversToMeasure.forEach((resolver) => {
      if (resolver.suspendedScrollY !== void 0) {
        window.scrollTo(0, resolver.suspendedScrollY);
      }
    });
  }
  anyNeedsMeasurement = false;
  isScheduled = false;
  toResolve.forEach((resolver) => resolver.complete(isForced));
  toResolve.clear();
}
function readAllKeyframes() {
  toResolve.forEach((resolver) => {
    resolver.readKeyframes();
    if (resolver.needsMeasurement) {
      anyNeedsMeasurement = true;
    }
  });
}
function flushKeyframeResolvers() {
  isForced = true;
  readAllKeyframes();
  measureAllKeyframes();
  isForced = false;
}
class KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name, motionValue2, element, isAsync = false) {
    this.state = "pending";
    this.isAsync = false;
    this.needsMeasurement = false;
    this.unresolvedKeyframes = [...unresolvedKeyframes];
    this.onComplete = onComplete;
    this.name = name;
    this.motionValue = motionValue2;
    this.element = element;
    this.isAsync = isAsync;
  }
  scheduleResolve() {
    this.state = "scheduled";
    if (this.isAsync) {
      toResolve.add(this);
      if (!isScheduled) {
        isScheduled = true;
        frame.read(readAllKeyframes);
        frame.resolveKeyframes(measureAllKeyframes);
      }
    } else {
      this.readKeyframes();
      this.complete();
    }
  }
  readKeyframes() {
    const { unresolvedKeyframes, name, element, motionValue: motionValue2 } = this;
    if (unresolvedKeyframes[0] === null) {
      const currentValue = motionValue2?.get();
      const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
      if (currentValue !== void 0) {
        unresolvedKeyframes[0] = currentValue;
      } else if (element && name) {
        const valueAsRead = element.readValue(name, finalKeyframe);
        if (valueAsRead !== void 0 && valueAsRead !== null) {
          unresolvedKeyframes[0] = valueAsRead;
        }
      }
      if (unresolvedKeyframes[0] === void 0) {
        unresolvedKeyframes[0] = finalKeyframe;
      }
      if (motionValue2 && currentValue === void 0) {
        motionValue2.set(unresolvedKeyframes[0]);
      }
    }
    fillWildcards(unresolvedKeyframes);
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete(isForcedComplete = false) {
    this.state = "complete";
    this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, isForcedComplete);
    toResolve.delete(this);
  }
  cancel() {
    if (this.state === "scheduled") {
      toResolve.delete(this);
      this.state = "pending";
    }
  }
  resume() {
    if (this.state === "pending")
      this.scheduleResolve();
  }
}
const isCSSVar = (name) => name.startsWith("--");
function setStyle(element, name, value) {
  isCSSVar(name) ? element.style.setProperty(name, value) : element.style[name] = value;
}
const supportsScrollTimeline = /* @__PURE__ */ memo(() => window.ScrollTimeline !== void 0);
const supportsFlags = {};
function memoSupports(callback, supportsFlag) {
  const memoized = /* @__PURE__ */ memo(callback);
  return () => supportsFlags[supportsFlag] ?? memoized();
}
const supportsLinearEasing = /* @__PURE__ */ memoSupports(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch (e2) {
    return false;
  }
  return true;
}, "linearEasing");
const cubicBezierAsString = ([a2, b2, c2, d2]) => `cubic-bezier(${a2}, ${b2}, ${c2}, ${d2})`;
const supportedWaapiEasing = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ cubicBezierAsString([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ cubicBezierAsString([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
};
function mapEasingToNativeEasing(easing, duration) {
  if (!easing) {
    return void 0;
  } else if (typeof easing === "function") {
    return supportsLinearEasing() ? generateLinearEasing(easing, duration) : "ease-out";
  } else if (isBezierDefinition(easing)) {
    return cubicBezierAsString(easing);
  } else if (Array.isArray(easing)) {
    return easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration) || supportedWaapiEasing.easeOut);
  } else {
    return supportedWaapiEasing[easing];
  }
}
function startWaapiAnimation(element, valueName, keyframes2, { delay: delay2 = 0, duration = 300, repeat = 0, repeatType = "loop", ease: ease2 = "easeOut", times } = {}, pseudoElement = void 0) {
  const keyframeOptions = {
    [valueName]: keyframes2
  };
  if (times)
    keyframeOptions.offset = times;
  const easing = mapEasingToNativeEasing(ease2, duration);
  if (Array.isArray(easing))
    keyframeOptions.easing = easing;
  const options = {
    delay: delay2,
    duration,
    easing: !Array.isArray(easing) ? easing : "linear",
    fill: "both",
    iterations: repeat + 1,
    direction: repeatType === "reverse" ? "alternate" : "normal"
  };
  if (pseudoElement)
    options.pseudoElement = pseudoElement;
  const animation = element.animate(keyframeOptions, options);
  return animation;
}
function isGenerator(type2) {
  return typeof type2 === "function" && "applyToOptions" in type2;
}
function applyGeneratorOptions({ type: type2, ...options }) {
  if (isGenerator(type2) && supportsLinearEasing()) {
    return type2.applyToOptions(options);
  } else {
    options.duration ?? (options.duration = 300);
    options.ease ?? (options.ease = "easeOut");
  }
  return options;
}
class NativeAnimation extends WithPromise {
  constructor(options) {
    super();
    this.finishedTime = null;
    this.isStopped = false;
    if (!options)
      return;
    const { element, name, keyframes: keyframes2, pseudoElement, allowFlatten = false, finalKeyframe, onComplete } = options;
    this.isPseudoElement = Boolean(pseudoElement);
    this.allowFlatten = allowFlatten;
    this.options = options;
    invariant(typeof options.type !== "string");
    const transition = applyGeneratorOptions(options);
    this.animation = startWaapiAnimation(element, name, keyframes2, transition, pseudoElement);
    if (transition.autoplay === false) {
      this.animation.pause();
    }
    this.animation.onfinish = () => {
      this.finishedTime = this.time;
      if (!pseudoElement) {
        const keyframe = getFinalKeyframe$1(keyframes2, this.options, finalKeyframe, this.speed);
        if (this.updateMotionValue) {
          this.updateMotionValue(keyframe);
        } else {
          setStyle(element, name, keyframe);
        }
        this.animation.cancel();
      }
      onComplete?.();
      this.notifyFinished();
    };
  }
  play() {
    if (this.isStopped)
      return;
    this.animation.play();
    if (this.state === "finished") {
      this.updateFinished();
    }
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.finish?.();
  }
  cancel() {
    try {
      this.animation.cancel();
    } catch (e2) {
    }
  }
  stop() {
    if (this.isStopped)
      return;
    this.isStopped = true;
    const { state } = this;
    if (state === "idle" || state === "finished") {
      return;
    }
    if (this.updateMotionValue) {
      this.updateMotionValue();
    } else {
      this.commitStyles();
    }
    if (!this.isPseudoElement)
      this.cancel();
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * In this method, we commit styles back to the DOM before cancelling
   * the animation.
   *
   * This is designed to be overridden by NativeAnimationExtended, which
   * will create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to also correctly calculate velocity for any subsequent animation
   * while deferring the commit until the next animation frame.
   */
  commitStyles() {
    if (!this.isPseudoElement) {
      this.animation.commitStyles?.();
    }
  }
  get duration() {
    const duration = this.animation.effect?.getComputedTiming?.().duration || 0;
    return /* @__PURE__ */ millisecondsToSeconds(Number(duration));
  }
  get time() {
    return /* @__PURE__ */ millisecondsToSeconds(Number(this.animation.currentTime) || 0);
  }
  set time(newTime) {
    this.finishedTime = null;
    this.animation.currentTime = /* @__PURE__ */ secondsToMilliseconds(newTime);
  }
  /**
   * The playback speed of the animation.
   * 1 = normal speed, 2 = double speed, 0.5 = half speed.
   */
  get speed() {
    return this.animation.playbackRate;
  }
  set speed(newSpeed) {
    if (newSpeed < 0)
      this.finishedTime = null;
    this.animation.playbackRate = newSpeed;
  }
  get state() {
    return this.finishedTime !== null ? "finished" : this.animation.playState;
  }
  get startTime() {
    return Number(this.animation.startTime);
  }
  set startTime(newStartTime) {
    this.animation.startTime = newStartTime;
  }
  /**
   * Attaches a timeline to the animation, for instance the `ScrollTimeline`.
   */
  attachTimeline({ timeline, observe }) {
    if (this.allowFlatten) {
      this.animation.effect?.updateTiming({ easing: "linear" });
    }
    this.animation.onfinish = null;
    if (timeline && supportsScrollTimeline()) {
      this.animation.timeline = timeline;
      return noop;
    } else {
      return observe(this);
    }
  }
}
const unsupportedEasingFunctions = {
  anticipate,
  backInOut,
  circInOut
};
function isUnsupportedEase(key) {
  return key in unsupportedEasingFunctions;
}
function replaceStringEasing(transition) {
  if (typeof transition.ease === "string" && isUnsupportedEase(transition.ease)) {
    transition.ease = unsupportedEasingFunctions[transition.ease];
  }
}
const sampleDelta = 10;
class NativeAnimationExtended extends NativeAnimation {
  constructor(options) {
    replaceStringEasing(options);
    replaceTransitionType(options);
    super(options);
    if (options.startTime) {
      this.startTime = options.startTime;
    }
    this.options = options;
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * Rather than read commited styles back out of the DOM, we can
   * create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to calculate velocity for any subsequent animation.
   */
  updateMotionValue(value) {
    const { motionValue: motionValue2, onUpdate, onComplete, element, ...options } = this.options;
    if (!motionValue2)
      return;
    if (value !== void 0) {
      motionValue2.set(value);
      return;
    }
    const sampleAnimation = new JSAnimation({
      ...options,
      autoplay: false
    });
    const sampleTime = /* @__PURE__ */ secondsToMilliseconds(this.finishedTime ?? this.time);
    motionValue2.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);
    sampleAnimation.stop();
  }
}
const isAnimatable = (value, name) => {
  if (name === "zIndex")
    return false;
  if (typeof value === "number" || Array.isArray(value))
    return true;
  if (typeof value === "string" && // It's animatable if we have a string
  (complex.test(value) || value === "0") && // And it contains numbers and/or colors
  !value.startsWith("url(")) {
    return true;
  }
  return false;
};
function hasKeyframesChanged(keyframes2) {
  const current = keyframes2[0];
  if (keyframes2.length === 1)
    return true;
  for (let i2 = 0; i2 < keyframes2.length; i2++) {
    if (keyframes2[i2] !== current)
      return true;
  }
}
function canAnimate(keyframes2, name, type2, velocity) {
  const originKeyframe = keyframes2[0];
  if (originKeyframe === null)
    return false;
  if (name === "display" || name === "visibility")
    return true;
  const targetKeyframe = keyframes2[keyframes2.length - 1];
  const isOriginAnimatable = isAnimatable(originKeyframe, name);
  const isTargetAnimatable = isAnimatable(targetKeyframe, name);
  if (!isOriginAnimatable || !isTargetAnimatable) {
    return false;
  }
  return hasKeyframesChanged(keyframes2) || (type2 === "spring" || isGenerator(type2)) && velocity;
}
function isHTMLElement(element) {
  return isObject(element) && "offsetHeight" in element;
}
const acceleratedValues = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Could be re-enabled now we have support for linear() easing
  // "background-color"
]);
const supportsWaapi = /* @__PURE__ */ memo(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
function supportsBrowserAnimation(options) {
  const { motionValue: motionValue2, name, repeatDelay, repeatType, damping, type: type2 } = options;
  if (!isHTMLElement(motionValue2?.owner?.current)) {
    return false;
  }
  const { onUpdate, transformTemplate } = motionValue2.owner.getProps();
  return supportsWaapi() && name && acceleratedValues.has(name) && (name !== "transform" || !transformTemplate) && /**
   * If we're outputting values to onUpdate then we can't use WAAPI as there's
   * no way to read the value from WAAPI every frame.
   */
  !onUpdate && !repeatDelay && repeatType !== "mirror" && damping !== 0 && type2 !== "inertia";
}
const MAX_RESOLVE_DELAY = 40;
class AsyncMotionValueAnimation extends WithPromise {
  constructor({ autoplay = true, delay: delay2 = 0, type: type2 = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", keyframes: keyframes2, name, motionValue: motionValue2, element, ...options }) {
    super();
    this.stop = () => {
      if (this._animation) {
        this._animation.stop();
        this.stopTimeline?.();
      }
      this.keyframeResolver?.cancel();
    };
    this.createdAt = time.now();
    const optionsWithDefaults = {
      autoplay,
      delay: delay2,
      type: type2,
      repeat,
      repeatDelay,
      repeatType,
      name,
      motionValue: motionValue2,
      element,
      ...options
    };
    const KeyframeResolver$1 = element?.KeyframeResolver || KeyframeResolver;
    this.keyframeResolver = new KeyframeResolver$1(keyframes2, (resolvedKeyframes, finalKeyframe, forced) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe, optionsWithDefaults, !forced), name, motionValue2, element);
    this.keyframeResolver?.scheduleResolve();
  }
  onKeyframesResolved(keyframes2, finalKeyframe, options, sync) {
    this.keyframeResolver = void 0;
    const { name, type: type2, velocity, delay: delay2, isHandoff, onUpdate } = options;
    this.resolvedAt = time.now();
    if (!canAnimate(keyframes2, name, type2, velocity)) {
      if (MotionGlobalConfig.instantAnimations || !delay2) {
        onUpdate?.(getFinalKeyframe$1(keyframes2, options, finalKeyframe));
      }
      keyframes2[0] = keyframes2[keyframes2.length - 1];
      options.duration = 0;
      options.repeat = 0;
    }
    const startTime = sync ? !this.resolvedAt ? this.createdAt : this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt : void 0;
    const resolvedOptions = {
      startTime,
      finalKeyframe,
      ...options,
      keyframes: keyframes2
    };
    const animation = !isHandoff && supportsBrowserAnimation(resolvedOptions) ? new NativeAnimationExtended({
      ...resolvedOptions,
      element: resolvedOptions.motionValue.owner.current
    }) : new JSAnimation(resolvedOptions);
    animation.finished.then(() => this.notifyFinished()).catch(noop);
    if (this.pendingTimeline) {
      this.stopTimeline = animation.attachTimeline(this.pendingTimeline);
      this.pendingTimeline = void 0;
    }
    this._animation = animation;
  }
  get finished() {
    if (!this._animation) {
      return this._finished;
    } else {
      return this.animation.finished;
    }
  }
  then(onResolve, _onReject) {
    return this.finished.finally(onResolve).then(() => {
    });
  }
  get animation() {
    if (!this._animation) {
      this.keyframeResolver?.resume();
      flushKeyframeResolvers();
    }
    return this._animation;
  }
  get duration() {
    return this.animation.duration;
  }
  get time() {
    return this.animation.time;
  }
  set time(newTime) {
    this.animation.time = newTime;
  }
  get speed() {
    return this.animation.speed;
  }
  get state() {
    return this.animation.state;
  }
  set speed(newSpeed) {
    this.animation.speed = newSpeed;
  }
  get startTime() {
    return this.animation.startTime;
  }
  attachTimeline(timeline) {
    if (this._animation) {
      this.stopTimeline = this.animation.attachTimeline(timeline);
    } else {
      this.pendingTimeline = timeline;
    }
    return () => this.stop();
  }
  play() {
    this.animation.play();
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.complete();
  }
  cancel() {
    if (this._animation) {
      this.animation.cancel();
    }
    this.keyframeResolver?.cancel();
  }
}
const splitCSSVariableRegex = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function parseCSSVariable(current) {
  const match = splitCSSVariableRegex.exec(current);
  if (!match)
    return [,];
  const [, token1, token2, fallback] = match;
  return [`--${token1 ?? token2}`, fallback];
}
function getVariableValue(current, element, depth = 1) {
  const [token, fallback] = parseCSSVariable(current);
  if (!token)
    return;
  const resolved = window.getComputedStyle(element).getPropertyValue(token);
  if (resolved) {
    const trimmed = resolved.trim();
    return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
  }
  return isCSSVariableToken(fallback) ? getVariableValue(fallback, element, depth + 1) : fallback;
}
function getValueTransition(transition, key) {
  return transition?.[key] ?? transition?.["default"] ?? transition;
}
const positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  ...transformPropOrder
]);
const auto = {
  test: (v2) => v2 === "auto",
  parse: (v2) => v2
};
const testValueType = (v2) => (type2) => type2.test(v2);
const dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
const findDimensionValueType = (v2) => dimensionValueTypes.find(testValueType(v2));
function isNone(value) {
  if (typeof value === "number") {
    return value === 0;
  } else if (value !== null) {
    return value === "none" || value === "0" || isZeroValueString(value);
  } else {
    return true;
  }
}
const maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v2) {
  const [name, value] = v2.slice(0, -1).split("(");
  if (name === "drop-shadow")
    return v2;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v2;
  const unit = value.replace(number2, "");
  let defaultValue2 = maxDefaults.has(name) ? 1 : 0;
  if (number2 !== value)
    defaultValue2 *= 100;
  return name + "(" + defaultValue2 + unit + ")";
}
const functionRegex = /\b([a-z-]*)\(.*?\)/gu;
const filter = {
  ...complex,
  getAnimatableNone: (v2) => {
    const functions = v2.match(functionRegex);
    return functions ? functions.map(applyDefaultFilter).join(" ") : v2;
  }
};
const int = {
  ...number,
  transform: Math.round
};
const transformValueTypes = {
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px
};
const numberValueTypes = {
  // Border props
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  // Positioning props
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  // Spacing props
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  // Misc
  backgroundPositionX: px,
  backgroundPositionY: px,
  ...transformValueTypes,
  zIndex: int,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
};
const defaultValueTypes = {
  ...numberValueTypes,
  // Color props
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  // Border props
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter,
  WebkitFilter: filter
};
const getDefaultValueType = (key) => defaultValueTypes[key];
function getAnimatableNone(key, value) {
  let defaultValueType = getDefaultValueType(key);
  if (defaultValueType !== filter)
    defaultValueType = complex;
  return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
}
const invalidTemplates = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {
  let i2 = 0;
  let animatableTemplate = void 0;
  while (i2 < unresolvedKeyframes.length && !animatableTemplate) {
    const keyframe = unresolvedKeyframes[i2];
    if (typeof keyframe === "string" && !invalidTemplates.has(keyframe) && analyseComplexValue(keyframe).values.length) {
      animatableTemplate = unresolvedKeyframes[i2];
    }
    i2++;
  }
  if (animatableTemplate && name) {
    for (const noneIndex of noneKeyframeIndexes) {
      unresolvedKeyframes[noneIndex] = getAnimatableNone(name, animatableTemplate);
    }
  }
}
class DOMKeyframesResolver extends KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name, motionValue2, element) {
    super(unresolvedKeyframes, onComplete, name, motionValue2, element, true);
  }
  readKeyframes() {
    const { unresolvedKeyframes, element, name } = this;
    if (!element || !element.current)
      return;
    super.readKeyframes();
    for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
      let keyframe = unresolvedKeyframes[i2];
      if (typeof keyframe === "string") {
        keyframe = keyframe.trim();
        if (isCSSVariableToken(keyframe)) {
          const resolved = getVariableValue(keyframe, element.current);
          if (resolved !== void 0) {
            unresolvedKeyframes[i2] = resolved;
          }
          if (i2 === unresolvedKeyframes.length - 1) {
            this.finalKeyframe = keyframe;
          }
        }
      }
    }
    this.resolveNoneKeyframes();
    if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {
      return;
    }
    const [origin, target] = unresolvedKeyframes;
    const originType = findDimensionValueType(origin);
    const targetType = findDimensionValueType(target);
    if (originType === targetType)
      return;
    if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {
      for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
        const value = unresolvedKeyframes[i2];
        if (typeof value === "string") {
          unresolvedKeyframes[i2] = parseFloat(value);
        }
      }
    } else if (positionalValues[name]) {
      this.needsMeasurement = true;
    }
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes, name } = this;
    const noneKeyframeIndexes = [];
    for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
      if (unresolvedKeyframes[i2] === null || isNone(unresolvedKeyframes[i2])) {
        noneKeyframeIndexes.push(i2);
      }
    }
    if (noneKeyframeIndexes.length) {
      makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);
    }
  }
  measureInitialState() {
    const { element, unresolvedKeyframes, name } = this;
    if (!element || !element.current)
      return;
    if (name === "height") {
      this.suspendedScrollY = window.pageYOffset;
    }
    this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
    unresolvedKeyframes[0] = this.measuredOrigin;
    const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
    if (measureKeyframe !== void 0) {
      element.getValue(name, measureKeyframe).jump(measureKeyframe, false);
    }
  }
  measureEndState() {
    const { element, name, unresolvedKeyframes } = this;
    if (!element || !element.current)
      return;
    const value = element.getValue(name);
    value && value.jump(this.measuredOrigin, false);
    const finalKeyframeIndex = unresolvedKeyframes.length - 1;
    const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
    unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
    if (finalKeyframe !== null && this.finalKeyframe === void 0) {
      this.finalKeyframe = finalKeyframe;
    }
    if (this.removedTransforms?.length) {
      this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
        element.getValue(unsetTransformName).set(unsetTransformValue);
      });
    }
    this.resolveNoneKeyframes();
  }
}
function resolveElements(elementOrSelector, scope, selectorCache) {
  if (elementOrSelector instanceof EventTarget) {
    return [elementOrSelector];
  } else if (typeof elementOrSelector === "string") {
    let root2 = document;
    const elements = selectorCache?.[elementOrSelector] ?? root2.querySelectorAll(elementOrSelector);
    return elements ? Array.from(elements) : [];
  }
  return Array.from(elementOrSelector);
}
const getValueAsType = (value, type2) => {
  return type2 && typeof value === "number" ? type2.transform(value) : value;
};
const MAX_VELOCITY_DELTA = 30;
const isFloat = (value) => {
  return !isNaN(parseFloat(value));
};
class MotionValue {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   */
  constructor(init, options = {}) {
    this.canTrackVelocity = null;
    this.events = {};
    this.updateAndNotify = (v2, render = true) => {
      const currentTime = time.now();
      if (this.updatedAt !== currentTime) {
        this.setPrevFrameValue();
      }
      this.prev = this.current;
      this.setCurrent(v2);
      if (this.current !== this.prev) {
        this.events.change?.notify(this.current);
        if (this.dependents) {
          for (const dependent of this.dependents) {
            dependent.dirty();
          }
        }
      }
      if (render) {
        this.events.renderRequest?.notify(this.current);
      }
    };
    this.hasAnimated = false;
    this.setCurrent(init);
    this.owner = options.owner;
  }
  setCurrent(current) {
    this.current = current;
    this.updatedAt = time.now();
    if (this.canTrackVelocity === null && current !== void 0) {
      this.canTrackVelocity = isFloat(this.current);
    }
  }
  setPrevFrameValue(prevFrameValue = this.current) {
    this.prevFrameValue = prevFrameValue;
    this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(subscription) {
    return this.on("change", subscription);
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    const unsubscribe = this.events[eventName].add(callback);
    if (eventName === "change") {
      return () => {
        unsubscribe();
        frame.read(() => {
          if (!this.events.change.getSize()) {
            this.stop();
          }
        });
      };
    }
    return unsubscribe;
  }
  clearListeners() {
    for (const eventManagers in this.events) {
      this.events[eventManagers].clear();
    }
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   */
  attach(passiveEffect, stopPassiveEffect) {
    this.passiveEffect = passiveEffect;
    this.stopPassiveEffect = stopPassiveEffect;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(v2, render = true) {
    if (!render || !this.passiveEffect) {
      this.updateAndNotify(v2, render);
    } else {
      this.passiveEffect(v2, this.updateAndNotify);
    }
  }
  setWithVelocity(prev, current, delta) {
    this.set(current);
    this.prev = void 0;
    this.prevFrameValue = prev;
    this.prevUpdatedAt = this.updatedAt - delta;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(v2, endAnimation = true) {
    this.updateAndNotify(v2);
    this.prev = v2;
    this.prevUpdatedAt = this.prevFrameValue = void 0;
    endAnimation && this.stop();
    if (this.stopPassiveEffect)
      this.stopPassiveEffect();
  }
  dirty() {
    this.events.change?.notify(this.current);
  }
  addDependent(dependent) {
    if (!this.dependents) {
      this.dependents = /* @__PURE__ */ new Set();
    }
    this.dependents.add(dependent);
  }
  removeDependent(dependent) {
    if (this.dependents) {
      this.dependents.delete(dependent);
    }
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const currentTime = time.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {
      return 0;
    }
    const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
    return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   */
  start(startAnimation) {
    this.stop();
    return new Promise((resolve) => {
      this.hasAnimated = true;
      this.animation = startAnimation(resolve);
      if (this.events.animationStart) {
        this.events.animationStart.notify();
      }
    }).then(() => {
      if (this.events.animationComplete) {
        this.events.animationComplete.notify();
      }
      this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    if (this.animation) {
      this.animation.stop();
      if (this.events.animationCancel) {
        this.events.animationCancel.notify();
      }
    }
    this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.dependents?.clear();
    this.events.destroy?.notify();
    this.clearListeners();
    this.stop();
    if (this.stopPassiveEffect) {
      this.stopPassiveEffect();
    }
  }
}
function motionValue(init, options) {
  return new MotionValue(init, options);
}
const { schedule: microtask } = /* @__PURE__ */ createRenderBatcher(queueMicrotask, false);
const isDragging = {
  x: false,
  y: false
};
function isDragActive() {
  return isDragging.x || isDragging.y;
}
function setDragLock(axis) {
  if (axis === "x" || axis === "y") {
    if (isDragging[axis]) {
      return null;
    } else {
      isDragging[axis] = true;
      return () => {
        isDragging[axis] = false;
      };
    }
  } else {
    if (isDragging.x || isDragging.y) {
      return null;
    } else {
      isDragging.x = isDragging.y = true;
      return () => {
        isDragging.x = isDragging.y = false;
      };
    }
  }
}
function setupGesture(elementOrSelector, options) {
  const elements = resolveElements(elementOrSelector);
  const gestureAbortController = new AbortController();
  const eventOptions = {
    passive: true,
    ...options,
    signal: gestureAbortController.signal
  };
  const cancel = () => gestureAbortController.abort();
  return [elements, eventOptions, cancel];
}
function isValidHover(event) {
  return !(event.pointerType === "touch" || isDragActive());
}
function hover(elementOrSelector, onHoverStart, options = {}) {
  const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);
  const onPointerEnter = (enterEvent) => {
    if (!isValidHover(enterEvent))
      return;
    const { target } = enterEvent;
    const onHoverEnd = onHoverStart(target, enterEvent);
    if (typeof onHoverEnd !== "function" || !target)
      return;
    const onPointerLeave = (leaveEvent) => {
      if (!isValidHover(leaveEvent))
        return;
      onHoverEnd(leaveEvent);
      target.removeEventListener("pointerleave", onPointerLeave);
    };
    target.addEventListener("pointerleave", onPointerLeave, eventOptions);
  };
  elements.forEach((element) => {
    element.addEventListener("pointerenter", onPointerEnter, eventOptions);
  });
  return cancel;
}
const isNodeOrChild = (parent, child) => {
  if (!child) {
    return false;
  } else if (parent === child) {
    return true;
  } else {
    return isNodeOrChild(parent, child.parentElement);
  }
};
const isPrimaryPointer = (event) => {
  if (event.pointerType === "mouse") {
    return typeof event.button !== "number" || event.button <= 0;
  } else {
    return event.isPrimary !== false;
  }
};
const focusableElements = /* @__PURE__ */ new Set([
  "BUTTON",
  "INPUT",
  "SELECT",
  "TEXTAREA",
  "A"
]);
function isElementKeyboardAccessible(element) {
  return focusableElements.has(element.tagName) || element.tabIndex !== -1;
}
const isPressing = /* @__PURE__ */ new WeakSet();
function filterEvents(callback) {
  return (event) => {
    if (event.key !== "Enter")
      return;
    callback(event);
  };
}
function firePointerEvent(target, type2) {
  target.dispatchEvent(new PointerEvent("pointer" + type2, { isPrimary: true, bubbles: true }));
}
const enableKeyboardPress = (focusEvent, eventOptions) => {
  const element = focusEvent.currentTarget;
  if (!element)
    return;
  const handleKeydown = filterEvents(() => {
    if (isPressing.has(element))
      return;
    firePointerEvent(element, "down");
    const handleKeyup = filterEvents(() => {
      firePointerEvent(element, "up");
    });
    const handleBlur = () => firePointerEvent(element, "cancel");
    element.addEventListener("keyup", handleKeyup, eventOptions);
    element.addEventListener("blur", handleBlur, eventOptions);
  });
  element.addEventListener("keydown", handleKeydown, eventOptions);
  element.addEventListener("blur", () => element.removeEventListener("keydown", handleKeydown), eventOptions);
};
function isValidPressEvent(event) {
  return isPrimaryPointer(event) && !isDragActive();
}
function press(targetOrSelector, onPressStart, options = {}) {
  const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options);
  const startPress = (startEvent) => {
    const target = startEvent.currentTarget;
    if (!isValidPressEvent(startEvent))
      return;
    isPressing.add(target);
    const onPressEnd = onPressStart(target, startEvent);
    const onPointerEnd = (endEvent, success) => {
      window.removeEventListener("pointerup", onPointerUp);
      window.removeEventListener("pointercancel", onPointerCancel);
      if (isPressing.has(target)) {
        isPressing.delete(target);
      }
      if (!isValidPressEvent(endEvent)) {
        return;
      }
      if (typeof onPressEnd === "function") {
        onPressEnd(endEvent, { success });
      }
    };
    const onPointerUp = (upEvent) => {
      onPointerEnd(upEvent, target === window || target === document || options.useGlobalTarget || isNodeOrChild(target, upEvent.target));
    };
    const onPointerCancel = (cancelEvent) => {
      onPointerEnd(cancelEvent, false);
    };
    window.addEventListener("pointerup", onPointerUp, eventOptions);
    window.addEventListener("pointercancel", onPointerCancel, eventOptions);
  };
  targets.forEach((target) => {
    const pointerDownTarget = options.useGlobalTarget ? window : target;
    pointerDownTarget.addEventListener("pointerdown", startPress, eventOptions);
    if (isHTMLElement(target)) {
      target.addEventListener("focus", (event) => enableKeyboardPress(event, eventOptions));
      if (!isElementKeyboardAccessible(target) && !target.hasAttribute("tabindex")) {
        target.tabIndex = 0;
      }
    }
  });
  return cancelEvents;
}
function isSVGElement(element) {
  return isObject(element) && "ownerSVGElement" in element;
}
function isSVGSVGElement(element) {
  return isSVGElement(element) && element.tagName === "svg";
}
const isMotionValue = (value) => Boolean(value && value.getVelocity);
const valueTypes = [...dimensionValueTypes, color, complex];
const findValueType = (v2) => valueTypes.find(testValueType(v2));
const MotionConfigContext = reactExports.createContext({
  transformPagePoint: (p2) => p2,
  isStatic: false,
  reducedMotion: "never"
});
function usePresence(subscribe = true) {
  const context = reactExports.useContext(PresenceContext);
  if (context === null)
    return [true, null];
  const { isPresent, onExitComplete, register } = context;
  const id2 = reactExports.useId();
  reactExports.useEffect(() => {
    if (subscribe) {
      return register(id2);
    }
  }, [subscribe]);
  const safeToRemove = reactExports.useCallback(() => subscribe && onExitComplete && onExitComplete(id2), [id2, onExitComplete, subscribe]);
  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
}
const LazyContext = reactExports.createContext({ strict: false });
const featureProps = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
};
const featureDefinitions = {};
for (const key in featureProps) {
  featureDefinitions[key] = {
    isEnabled: (props) => featureProps[key].some((name) => !!props[name])
  };
}
function loadFeatures(features) {
  for (const key in features) {
    featureDefinitions[key] = {
      ...featureDefinitions[key],
      ...features[key]
    };
  }
}
const validMotionProps = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function isValidMotionProp(key) {
  return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || key.startsWith("onLayout") || validMotionProps.has(key);
}
let shouldForward = (key) => !isValidMotionProp(key);
function loadExternalIsValidProp(isValidProp) {
  if (typeof isValidProp !== "function")
    return;
  shouldForward = (key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
}
try {
  loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
} catch {
}
function filterProps(props, isDom, forwardMotionProps) {
  const filteredProps = {};
  for (const key in props) {
    if (key === "values" && typeof props.values === "object")
      continue;
    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners
    props["draggable"] && key.startsWith("onDrag")) {
      filteredProps[key] = props[key];
    }
  }
  return filteredProps;
}
function createDOMMotionComponentProxy(componentFactory) {
  if (typeof Proxy === "undefined") {
    return componentFactory;
  }
  const componentCache = /* @__PURE__ */ new Map();
  const deprecatedFactoryFunction = (...args) => {
    return componentFactory(...args);
  };
  return new Proxy(deprecatedFactoryFunction, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (_target, key) => {
      if (key === "create")
        return componentFactory;
      if (!componentCache.has(key)) {
        componentCache.set(key, componentFactory(key));
      }
      return componentCache.get(key);
    }
  });
}
const MotionContext = /* @__PURE__ */ reactExports.createContext({});
function isAnimationControls(v2) {
  return v2 !== null && typeof v2 === "object" && typeof v2.start === "function";
}
function isVariantLabel(v2) {
  return typeof v2 === "string" || Array.isArray(v2);
}
const variantPriorityOrder = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
];
const variantProps = ["initial", ...variantPriorityOrder];
function isControllingVariants(props) {
  return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));
}
function isVariantNode(props) {
  return Boolean(isControllingVariants(props) || props.variants);
}
function getCurrentTreeVariants(props, context) {
  if (isControllingVariants(props)) {
    const { initial, animate } = props;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate) ? animate : void 0
    };
  }
  return props.inherit !== false ? context : {};
}
function useCreateMotionContext(props) {
  const { initial, animate } = getCurrentTreeVariants(props, reactExports.useContext(MotionContext));
  return reactExports.useMemo(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}
const motionComponentSymbol = Symbol.for("motionComponentSymbol");
function isRefObject(ref2) {
  return ref2 && typeof ref2 === "object" && Object.prototype.hasOwnProperty.call(ref2, "current");
}
function useMotionRef(visualState, visualElement, externalRef) {
  return reactExports.useCallback(
    (instance) => {
      if (instance) {
        visualState.onMount && visualState.onMount(instance);
      }
      if (visualElement) {
        if (instance) {
          visualElement.mount(instance);
        } else {
          visualElement.unmount();
        }
      }
      if (externalRef) {
        if (typeof externalRef === "function") {
          externalRef(instance);
        } else if (isRefObject(externalRef)) {
          externalRef.current = instance;
        }
      }
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [visualElement]
  );
}
const camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase();
const optimizedAppearDataId = "framerAppearId";
const optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
const SwitchLayoutGroupContext = reactExports.createContext({});
function useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {
  const { visualElement: parent } = reactExports.useContext(MotionContext);
  const lazyContext = reactExports.useContext(LazyContext);
  const presenceContext = reactExports.useContext(PresenceContext);
  const reducedMotionConfig = reactExports.useContext(MotionConfigContext).reducedMotion;
  const visualElementRef = reactExports.useRef(null);
  createVisualElement = createVisualElement || lazyContext.renderer;
  if (!visualElementRef.current && createVisualElement) {
    visualElementRef.current = createVisualElement(Component, {
      visualState,
      parent,
      props,
      presenceContext,
      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
      reducedMotionConfig
    });
  }
  const visualElement = visualElementRef.current;
  const initialLayoutGroupConfig = reactExports.useContext(SwitchLayoutGroupContext);
  if (visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === "html" || visualElement.type === "svg")) {
    createProjectionNode$1(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
  }
  const isMounted = reactExports.useRef(false);
  reactExports.useInsertionEffect(() => {
    if (visualElement && isMounted.current) {
      visualElement.update(props, presenceContext);
    }
  });
  const optimisedAppearId = props[optimizedAppearDataAttribute];
  const wantsHandoff = reactExports.useRef(Boolean(optimisedAppearId) && !window.MotionHandoffIsComplete?.(optimisedAppearId) && window.MotionHasOptimisedAnimation?.(optimisedAppearId));
  useIsomorphicLayoutEffect(() => {
    if (!visualElement)
      return;
    isMounted.current = true;
    window.MotionIsMounted = true;
    visualElement.updateFeatures();
    microtask.render(visualElement.render);
    if (wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
  });
  reactExports.useEffect(() => {
    if (!visualElement)
      return;
    if (!wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
    if (wantsHandoff.current) {
      queueMicrotask(() => {
        window.MotionHandoffMarkAsComplete?.(optimisedAppearId);
      });
      wantsHandoff.current = false;
    }
  });
  return visualElement;
}
function createProjectionNode$1(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {
  const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot, layoutCrossfade } = props;
  visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(visualElement.parent));
  visualElement.projection.setOptions({
    layoutId,
    layout: layout2,
    alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
    visualElement,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof layout2 === "string" ? layout2 : "both",
    initialPromotionConfig,
    crossfade: layoutCrossfade,
    layoutScroll,
    layoutRoot
  });
}
function getClosestProjectingNode(visualElement) {
  if (!visualElement)
    return void 0;
  return visualElement.options.allowProjection !== false ? visualElement.projection : getClosestProjectingNode(visualElement.parent);
}
function createRendererMotionComponent({ preloadedFeatures, createVisualElement, useRender, useVisualState, Component }) {
  preloadedFeatures && loadFeatures(preloadedFeatures);
  function MotionComponent(props, externalRef) {
    let MeasureLayout2;
    const configAndProps = {
      ...reactExports.useContext(MotionConfigContext),
      ...props,
      layoutId: useLayoutId(props)
    };
    const { isStatic } = configAndProps;
    const context = useCreateMotionContext(props);
    const visualState = useVisualState(props, isStatic);
    if (!isStatic && isBrowser) {
      useStrictMode();
      const layoutProjection = getProjectionFunctionality(configAndProps);
      MeasureLayout2 = layoutProjection.MeasureLayout;
      context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);
    }
    return jsxRuntimeExports.jsxs(MotionContext.Provider, { value: context, children: [MeasureLayout2 && context.visualElement ? jsxRuntimeExports.jsx(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps }) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)] });
  }
  MotionComponent.displayName = `motion.${typeof Component === "string" ? Component : `create(${Component.displayName ?? Component.name ?? ""})`}`;
  const ForwardRefMotionComponent = reactExports.forwardRef(MotionComponent);
  ForwardRefMotionComponent[motionComponentSymbol] = Component;
  return ForwardRefMotionComponent;
}
function useLayoutId({ layoutId }) {
  const layoutGroupId = reactExports.useContext(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}
function useStrictMode(configAndProps, preloadedFeatures) {
  reactExports.useContext(LazyContext).strict;
}
function getProjectionFunctionality(props) {
  const { drag: drag2, layout: layout2 } = featureDefinitions;
  if (!drag2 && !layout2)
    return {};
  const combined = { ...drag2, ...layout2 };
  return {
    MeasureLayout: drag2?.isEnabled(props) || layout2?.isEnabled(props) ? combined.MeasureLayout : void 0,
    ProjectionNode: combined.ProjectionNode
  };
}
const scaleCorrectors = {};
function addScaleCorrector(correctors) {
  for (const key in correctors) {
    scaleCorrectors[key] = correctors[key];
    if (isCSSVariableName(key)) {
      scaleCorrectors[key].isCSSVariable = true;
    }
  }
}
function isForcedMotionValue(key, { layout: layout2, layoutId }) {
  return transformProps.has(key) || key.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
}
const translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
const numTransforms = transformPropOrder.length;
function buildTransform(latestValues, transform, transformTemplate) {
  let transformString = "";
  let transformIsDefault = true;
  for (let i2 = 0; i2 < numTransforms; i2++) {
    const key = transformPropOrder[i2];
    const value = latestValues[key];
    if (value === void 0)
      continue;
    let valueIsDefault = true;
    if (typeof value === "number") {
      valueIsDefault = value === (key.startsWith("scale") ? 1 : 0);
    } else {
      valueIsDefault = parseFloat(value) === 0;
    }
    if (!valueIsDefault || transformTemplate) {
      const valueAsType = getValueAsType(value, numberValueTypes[key]);
      if (!valueIsDefault) {
        transformIsDefault = false;
        const transformName = translateAlias[key] || key;
        transformString += `${transformName}(${valueAsType}) `;
      }
      if (transformTemplate) {
        transform[key] = valueAsType;
      }
    }
  }
  transformString = transformString.trim();
  if (transformTemplate) {
    transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);
  } else if (transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}
function buildHTMLStyles(state, latestValues, transformTemplate) {
  const { style, vars, transformOrigin } = state;
  let hasTransform2 = false;
  let hasTransformOrigin = false;
  for (const key in latestValues) {
    const value = latestValues[key];
    if (transformProps.has(key)) {
      hasTransform2 = true;
      continue;
    } else if (isCSSVariableName(key)) {
      vars[key] = value;
      continue;
    } else {
      const valueAsType = getValueAsType(value, numberValueTypes[key]);
      if (key.startsWith("origin")) {
        hasTransformOrigin = true;
        transformOrigin[key] = valueAsType;
      } else {
        style[key] = valueAsType;
      }
    }
  }
  if (!latestValues.transform) {
    if (hasTransform2 || transformTemplate) {
      style.transform = buildTransform(latestValues, state.transform, transformTemplate);
    } else if (style.transform) {
      style.transform = "none";
    }
  }
  if (hasTransformOrigin) {
    const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
    style.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}
const createHtmlRenderState = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function copyRawValuesOnly(target, source, props) {
  for (const key in source) {
    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
      target[key] = source[key];
    }
  }
}
function useInitialMotionValues({ transformTemplate }, visualState) {
  return reactExports.useMemo(() => {
    const state = createHtmlRenderState();
    buildHTMLStyles(state, visualState, transformTemplate);
    return Object.assign({}, state.vars, state.style);
  }, [visualState]);
}
function useStyle(props, visualState) {
  const styleProp = props.style || {};
  const style = {};
  copyRawValuesOnly(style, styleProp, props);
  Object.assign(style, useInitialMotionValues(props, visualState));
  return style;
}
function useHTMLProps(props, visualState) {
  const htmlProps = {};
  const style = useStyle(props, visualState);
  if (props.drag && props.dragListener !== false) {
    htmlProps.draggable = false;
    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
    style.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
  }
  if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) {
    htmlProps.tabIndex = 0;
  }
  htmlProps.style = style;
  return htmlProps;
}
const dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
const camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {
  attrs.pathLength = 1;
  const keys = useDashCase ? dashKeys : camelKeys;
  attrs[keys.offset] = px.transform(-offset);
  const pathLength = px.transform(length);
  const pathSpacing = px.transform(spacing);
  attrs[keys.array] = `${pathLength} ${pathSpacing}`;
}
function buildSVGAttrs(state, {
  attrX,
  attrY,
  attrScale,
  pathLength,
  pathSpacing = 1,
  pathOffset = 0,
  // This is object creation, which we try to avoid per-frame.
  ...latest
}, isSVGTag2, transformTemplate, styleProp) {
  buildHTMLStyles(state, latest, transformTemplate);
  if (isSVGTag2) {
    if (state.style.viewBox) {
      state.attrs.viewBox = state.style.viewBox;
    }
    return;
  }
  state.attrs = state.style;
  state.style = {};
  const { attrs, style } = state;
  if (attrs.transform) {
    style.transform = attrs.transform;
    delete attrs.transform;
  }
  if (style.transform || attrs.transformOrigin) {
    style.transformOrigin = attrs.transformOrigin ?? "50% 50%";
    delete attrs.transformOrigin;
  }
  if (style.transform) {
    style.transformBox = styleProp?.transformBox ?? "fill-box";
    delete attrs.transformBox;
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (attrScale !== void 0)
    attrs.scale = attrScale;
  if (pathLength !== void 0) {
    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
  }
}
const createSvgRenderState = () => ({
  ...createHtmlRenderState(),
  attrs: {}
});
const isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";
function useSVGProps(props, visualState, _isStatic, Component) {
  const visualProps = reactExports.useMemo(() => {
    const state = createSvgRenderState();
    buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate, props.style);
    return {
      ...state.attrs,
      style: { ...state.style }
    };
  }, [visualState]);
  if (props.style) {
    const rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props);
    visualProps.style = { ...rawStyles, ...visualProps.style };
  }
  return visualProps;
}
const lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function isSVGComponent(Component) {
  if (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component !== "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    Component.includes("-")
  ) {
    return false;
  } else if (
    /**
     * If it's in our list of lowercase SVG tags, it's an SVG component
     */
    lowercaseSVGElements.indexOf(Component) > -1 || /**
     * If it contains a capital letter, it's an SVG component
     */
    /[A-Z]/u.test(Component)
  ) {
    return true;
  }
  return false;
}
function createUseRender(forwardMotionProps = false) {
  const useRender = (Component, props, ref2, { latestValues }, isStatic) => {
    const useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;
    const visualProps = useVisualProps(props, latestValues, isStatic, Component);
    const filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps);
    const elementProps = Component !== reactExports.Fragment ? { ...filteredProps, ...visualProps, ref: ref2 } : {};
    const { children } = props;
    const renderedChildren = reactExports.useMemo(() => isMotionValue(children) ? children.get() : children, [children]);
    return reactExports.createElement(Component, {
      ...elementProps,
      children: renderedChildren
    });
  };
  return useRender;
}
function getValueState(visualElement) {
  const state = [{}, {}];
  visualElement?.values.forEach((value, key) => {
    state[0][key] = value.get();
    state[1][key] = value.getVelocity();
  });
  return state;
}
function resolveVariantFromProps(props, definition, custom, visualElement) {
  if (typeof definition === "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
  }
  if (typeof definition === "string") {
    definition = props.variants && props.variants[definition];
  }
  if (typeof definition === "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
  }
  return definition;
}
function resolveMotionValue(value) {
  return isMotionValue(value) ? value.get() : value;
}
function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, createRenderState }, props, context, presenceContext) {
  const state = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps2),
    renderState: createRenderState()
  };
  return state;
}
const makeUseVisualState = (config) => (props, isStatic) => {
  const context = reactExports.useContext(MotionContext);
  const presenceContext = reactExports.useContext(PresenceContext);
  const make = () => makeState(config, props, context, presenceContext);
  return isStatic ? make() : useConstant(make);
};
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  const values = {};
  const motionValues = scrapeMotionValues(props, {});
  for (const key in motionValues) {
    values[key] = resolveMotionValue(motionValues[key]);
  }
  let { initial, animate } = props;
  const isControllingVariants$1 = isControllingVariants(props);
  const isVariantNode$1 = isVariantNode(props);
  if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
    if (initial === void 0)
      initial = context.initial;
    if (animate === void 0)
      animate = context.animate;
  }
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
  const variantToSet = isInitialAnimationBlocked ? animate : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
    const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    for (let i2 = 0; i2 < list.length; i2++) {
      const resolved = resolveVariantFromProps(props, list[i2]);
      if (resolved) {
        const { transitionEnd, transition, ...target } = resolved;
        for (const key in target) {
          let valueTarget = target[key];
          if (Array.isArray(valueTarget)) {
            const index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
            valueTarget = valueTarget[index];
          }
          if (valueTarget !== null) {
            values[key] = valueTarget;
          }
        }
        for (const key in transitionEnd) {
          values[key] = transitionEnd[key];
        }
      }
    }
  }
  return values;
}
function scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {
  const { style } = props;
  const newValues = {};
  for (const key in style) {
    if (isMotionValue(style[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props) || visualElement?.getValue(key)?.liveStyle !== void 0) {
      newValues[key] = style[key];
    }
  }
  return newValues;
}
const htmlMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
    createRenderState: createHtmlRenderState
  })
};
function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
  const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
  for (const key in props) {
    if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
      const targetKey = transformPropOrder.indexOf(key) !== -1 ? "attr" + key.charAt(0).toUpperCase() + key.substring(1) : key;
      newValues[targetKey] = props[key];
    }
  }
  return newValues;
}
const svgMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createSvgRenderState
  })
};
function createMotionComponentFactory(preloadedFeatures, createVisualElement) {
  return function createMotionComponent2(Component, { forwardMotionProps } = { forwardMotionProps: false }) {
    const baseConfig = isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig;
    const config = {
      ...baseConfig,
      preloadedFeatures,
      useRender: createUseRender(forwardMotionProps),
      createVisualElement,
      Component
    };
    return createRendererMotionComponent(config);
  };
}
function resolveVariant(visualElement, definition, custom) {
  const props = visualElement.getProps();
  return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, visualElement);
}
const isKeyframesTarget = (v2) => {
  return Array.isArray(v2);
};
function setMotionValue(visualElement, key, value) {
  if (visualElement.hasValue(key)) {
    visualElement.getValue(key).set(value);
  } else {
    visualElement.addValue(key, motionValue(value));
  }
}
function resolveFinalValueInKeyframes(v2) {
  return isKeyframesTarget(v2) ? v2[v2.length - 1] || 0 : v2;
}
function setTarget(visualElement, definition) {
  const resolved = resolveVariant(visualElement, definition);
  let { transitionEnd = {}, transition = {}, ...target } = resolved || {};
  target = { ...target, ...transitionEnd };
  for (const key in target) {
    const value = resolveFinalValueInKeyframes(target[key]);
    setMotionValue(visualElement, key, value);
  }
}
function isWillChangeMotionValue(value) {
  return Boolean(isMotionValue(value) && value.add);
}
function addValueToWillChange(visualElement, key) {
  const willChange = visualElement.getValue("willChange");
  if (isWillChangeMotionValue(willChange)) {
    return willChange.add(key);
  } else if (!willChange && MotionGlobalConfig.WillChange) {
    const newWillChange = new MotionGlobalConfig.WillChange("auto");
    visualElement.addValue("willChange", newWillChange);
    newWillChange.add(key);
  }
}
function getOptimisedAppearId(visualElement) {
  return visualElement.props[optimizedAppearDataAttribute];
}
const isNotNull = (value) => value !== null;
function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe) {
  const resolvedKeyframes = keyframes2.filter(isNotNull);
  const index = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
  return resolvedKeyframes[index];
}
const underDampedSpring = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
};
const criticallyDampedSpring = (target) => ({
  type: "spring",
  stiffness: 550,
  damping: target === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
});
const keyframesTransition = {
  type: "keyframes",
  duration: 0.8
};
const ease = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
};
const getDefaultTransition = (valueKey, { keyframes: keyframes2 }) => {
  if (keyframes2.length > 2) {
    return keyframesTransition;
  } else if (transformProps.has(valueKey)) {
    return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes2[1]) : underDampedSpring;
  }
  return ease;
};
function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {
  return !!Object.keys(transition).length;
}
const animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {
  const valueTransition = getValueTransition(transition, name) || {};
  const delay2 = valueTransition.delay || transition.delay || 0;
  let { elapsed = 0 } = transition;
  elapsed = elapsed - /* @__PURE__ */ secondsToMilliseconds(delay2);
  const options = {
    keyframes: Array.isArray(target) ? target : [null, target],
    ease: "easeOut",
    velocity: value.getVelocity(),
    ...valueTransition,
    delay: -elapsed,
    onUpdate: (v2) => {
      value.set(v2);
      valueTransition.onUpdate && valueTransition.onUpdate(v2);
    },
    onComplete: () => {
      onComplete();
      valueTransition.onComplete && valueTransition.onComplete();
    },
    name,
    motionValue: value,
    element: isHandoff ? void 0 : element
  };
  if (!isTransitionDefined(valueTransition)) {
    Object.assign(options, getDefaultTransition(name, options));
  }
  options.duration && (options.duration = /* @__PURE__ */ secondsToMilliseconds(options.duration));
  options.repeatDelay && (options.repeatDelay = /* @__PURE__ */ secondsToMilliseconds(options.repeatDelay));
  if (options.from !== void 0) {
    options.keyframes[0] = options.from;
  }
  let shouldSkip = false;
  if (options.type === false || options.duration === 0 && !options.repeatDelay) {
    options.duration = 0;
    if (options.delay === 0) {
      shouldSkip = true;
    }
  }
  if (MotionGlobalConfig.instantAnimations || MotionGlobalConfig.skipAnimations) {
    shouldSkip = true;
    options.duration = 0;
    options.delay = 0;
  }
  options.allowFlatten = !valueTransition.type && !valueTransition.ease;
  if (shouldSkip && !isHandoff && value.get() !== void 0) {
    const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);
    if (finalKeyframe !== void 0) {
      frame.update(() => {
        options.onUpdate(finalKeyframe);
        options.onComplete();
      });
      return;
    }
  }
  return valueTransition.isSync ? new JSAnimation(options) : new AsyncMotionValueAnimation(options);
};
function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
  const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
  needsAnimating[key] = false;
  return shouldBlock;
}
function animateTarget(visualElement, targetAndTransition, { delay: delay2 = 0, transitionOverride, type: type2 } = {}) {
  let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;
  if (transitionOverride)
    transition = transitionOverride;
  const animations2 = [];
  const animationTypeState = type2 && visualElement.animationState && visualElement.animationState.getState()[type2];
  for (const key in target) {
    const value = visualElement.getValue(key, visualElement.latestValues[key] ?? null);
    const valueTarget = target[key];
    if (valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
      continue;
    }
    const valueTransition = {
      delay: delay2,
      ...getValueTransition(transition || {}, key)
    };
    const currentValue = value.get();
    if (currentValue !== void 0 && !value.isAnimating && !Array.isArray(valueTarget) && valueTarget === currentValue && !valueTransition.velocity) {
      continue;
    }
    let isHandoff = false;
    if (window.MotionHandoffAnimation) {
      const appearId = getOptimisedAppearId(visualElement);
      if (appearId) {
        const startTime = window.MotionHandoffAnimation(appearId, key, frame);
        if (startTime !== null) {
          valueTransition.startTime = startTime;
          isHandoff = true;
        }
      }
    }
    addValueToWillChange(visualElement, key);
    value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key) ? { type: false } : valueTransition, visualElement, isHandoff));
    const animation = value.animation;
    if (animation) {
      animations2.push(animation);
    }
  }
  if (transitionEnd) {
    Promise.all(animations2).then(() => {
      frame.update(() => {
        transitionEnd && setTarget(visualElement, transitionEnd);
      });
    });
  }
  return animations2;
}
function animateVariant(visualElement, variant, options = {}) {
  const resolved = resolveVariant(visualElement, variant, options.type === "exit" ? visualElement.presenceContext?.custom : void 0);
  let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
  if (options.transitionOverride) {
    transition = options.transitionOverride;
  }
  const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();
  const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
    const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
  } : () => Promise.resolve();
  const { when } = transition;
  if (when) {
    const [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
    return first().then(() => last());
  } else {
    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
  }
}
function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
  const animations2 = [];
  const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;
  const generateStaggerDuration = staggerDirection === 1 ? (i2 = 0) => i2 * staggerChildren : (i2 = 0) => maxStaggerDuration - i2 * staggerChildren;
  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i2) => {
    child.notify("AnimationStart", variant);
    animations2.push(animateVariant(child, variant, {
      ...options,
      delay: delayChildren + generateStaggerDuration(i2)
    }).then(() => child.notify("AnimationComplete", variant)));
  });
  return Promise.all(animations2);
}
function sortByTreeOrder(a2, b2) {
  return a2.sortNodePosition(b2);
}
function animateVisualElement(visualElement, definition, options = {}) {
  visualElement.notify("AnimationStart", definition);
  let animation;
  if (Array.isArray(definition)) {
    const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));
    animation = Promise.all(animations2);
  } else if (typeof definition === "string") {
    animation = animateVariant(visualElement, definition, options);
  } else {
    const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
    animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
  }
  return animation.then(() => {
    visualElement.notify("AnimationComplete", definition);
  });
}
function shallowCompare(next, prev) {
  if (!Array.isArray(prev))
    return false;
  const prevLength = prev.length;
  if (prevLength !== next.length)
    return false;
  for (let i2 = 0; i2 < prevLength; i2++) {
    if (prev[i2] !== next[i2])
      return false;
  }
  return true;
}
const numVariantProps = variantProps.length;
function getVariantContext(visualElement) {
  if (!visualElement)
    return void 0;
  if (!visualElement.isControllingVariants) {
    const context2 = visualElement.parent ? getVariantContext(visualElement.parent) || {} : {};
    if (visualElement.props.initial !== void 0) {
      context2.initial = visualElement.props.initial;
    }
    return context2;
  }
  const context = {};
  for (let i2 = 0; i2 < numVariantProps; i2++) {
    const name = variantProps[i2];
    const prop = visualElement.props[name];
    if (isVariantLabel(prop) || prop === false) {
      context[name] = prop;
    }
  }
  return context;
}
const reversePriorityOrder = [...variantPriorityOrder].reverse();
const numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement) {
  return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));
}
function createAnimationState(visualElement) {
  let animate = animateList(visualElement);
  let state = createState();
  let isInitialRender = true;
  const buildResolvedTypeValues = (type2) => (acc, definition) => {
    const resolved = resolveVariant(visualElement, definition, type2 === "exit" ? visualElement.presenceContext?.custom : void 0);
    if (resolved) {
      const { transition, transitionEnd, ...target } = resolved;
      acc = { ...acc, ...target, ...transitionEnd };
    }
    return acc;
  };
  function setAnimateFunction(makeAnimator) {
    animate = makeAnimator(visualElement);
  }
  function animateChanges(changedActiveType) {
    const { props } = visualElement;
    const context = getVariantContext(visualElement.parent) || {};
    const animations2 = [];
    const removedKeys = /* @__PURE__ */ new Set();
    let encounteredKeys = {};
    let removedVariantIndex = Infinity;
    for (let i2 = 0; i2 < numAnimationTypes; i2++) {
      const type2 = reversePriorityOrder[i2];
      const typeState = state[type2];
      const prop = props[type2] !== void 0 ? props[type2] : context[type2];
      const propIsVariant = isVariantLabel(prop);
      const activeDelta = type2 === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false)
        removedVariantIndex = i2;
      let isInherited = prop === context[type2] && prop !== props[type2] && propIsVariant;
      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
        isInherited = false;
      }
      typeState.protectedKeys = { ...encounteredKeys };
      if (
        // If it isn't active and hasn't *just* been set as inactive
        !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
        !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
        isAnimationControls(prop) || typeof prop === "boolean"
      ) {
        continue;
      }
      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
      type2 === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
      i2 > removedVariantIndex && propIsVariant;
      let handledRemovedValues = false;
      const definitionList = Array.isArray(prop) ? prop : [prop];
      let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type2), {});
      if (activeDelta === false)
        resolvedValues = {};
      const { prevResolvedValues = {} } = typeState;
      const allKeys = {
        ...prevResolvedValues,
        ...resolvedValues
      };
      const markToAnimate = (key) => {
        shouldAnimateType = true;
        if (removedKeys.has(key)) {
          handledRemovedValues = true;
          removedKeys.delete(key);
        }
        typeState.needsAnimating[key] = true;
        const motionValue2 = visualElement.getValue(key);
        if (motionValue2)
          motionValue2.liveStyle = false;
      };
      for (const key in allKeys) {
        const next = resolvedValues[key];
        const prev = prevResolvedValues[key];
        if (encounteredKeys.hasOwnProperty(key))
          continue;
        let valueHasChanged = false;
        if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
          valueHasChanged = !shallowCompare(next, prev);
        } else {
          valueHasChanged = next !== prev;
        }
        if (valueHasChanged) {
          if (next !== void 0 && next !== null) {
            markToAnimate(key);
          } else {
            removedKeys.add(key);
          }
        } else if (next !== void 0 && removedKeys.has(key)) {
          markToAnimate(key);
        } else {
          typeState.protectedKeys[key] = true;
        }
      }
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      if (typeState.isActive) {
        encounteredKeys = { ...encounteredKeys, ...resolvedValues };
      }
      if (isInitialRender && visualElement.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      const willAnimateViaParent = isInherited && variantDidChange;
      const needsAnimating = !willAnimateViaParent || handledRemovedValues;
      if (shouldAnimateType && needsAnimating) {
        animations2.push(...definitionList.map((animation) => ({
          animation,
          options: { type: type2 }
        })));
      }
    }
    if (removedKeys.size) {
      const fallbackAnimation = {};
      if (typeof props.initial !== "boolean") {
        const initialTransition = resolveVariant(visualElement, Array.isArray(props.initial) ? props.initial[0] : props.initial);
        if (initialTransition && initialTransition.transition) {
          fallbackAnimation.transition = initialTransition.transition;
        }
      }
      removedKeys.forEach((key) => {
        const fallbackTarget = visualElement.getBaseTarget(key);
        const motionValue2 = visualElement.getValue(key);
        if (motionValue2)
          motionValue2.liveStyle = true;
        fallbackAnimation[key] = fallbackTarget ?? null;
      });
      animations2.push({ animation: fallbackAnimation });
    }
    let shouldAnimate = Boolean(animations2.length);
    if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate(animations2) : Promise.resolve();
  }
  function setActive(type2, isActive) {
    if (state[type2].isActive === isActive)
      return Promise.resolve();
    visualElement.variantChildren?.forEach((child) => child.animationState?.setActive(type2, isActive));
    state[type2].isActive = isActive;
    const animations2 = animateChanges(type2);
    for (const key in state) {
      state[key].protectedKeys = {};
    }
    return animations2;
  }
  return {
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: () => state,
    reset: () => {
      state = createState();
      isInitialRender = true;
    }
  };
}
function checkVariantsDidChange(prev, next) {
  if (typeof next === "string") {
    return next !== prev;
  } else if (Array.isArray(next)) {
    return !shallowCompare(next, prev);
  }
  return false;
}
function createTypeState(isActive = false) {
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  return {
    animate: createTypeState(true),
    whileInView: createTypeState(),
    whileHover: createTypeState(),
    whileTap: createTypeState(),
    whileDrag: createTypeState(),
    whileFocus: createTypeState(),
    exit: createTypeState()
  };
}
class Feature {
  constructor(node) {
    this.isMounted = false;
    this.node = node;
  }
  update() {
  }
}
class AnimationFeature extends Feature {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(node) {
    super(node);
    node.animationState || (node.animationState = createAnimationState(node));
  }
  updateAnimationControlsSubscription() {
    const { animate } = this.node.getProps();
    if (isAnimationControls(animate)) {
      this.unmountControls = animate.subscribe(this.node);
    }
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate } = this.node.getProps();
    const { animate: prevAnimate } = this.node.prevProps || {};
    if (animate !== prevAnimate) {
      this.updateAnimationControlsSubscription();
    }
  }
  unmount() {
    this.node.animationState.reset();
    this.unmountControls?.();
  }
}
let id$1 = 0;
class ExitAnimationFeature extends Feature {
  constructor() {
    super(...arguments);
    this.id = id$1++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent, onExitComplete } = this.node.presenceContext;
    const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || isPresent === prevIsPresent) {
      return;
    }
    const exitAnimation = this.node.animationState.setActive("exit", !isPresent);
    if (onExitComplete && !isPresent) {
      exitAnimation.then(() => {
        onExitComplete(this.id);
      });
    }
  }
  mount() {
    const { register, onExitComplete } = this.node.presenceContext || {};
    if (onExitComplete) {
      onExitComplete(this.id);
    }
    if (register) {
      this.unmount = register(this.id);
    }
  }
  unmount() {
  }
}
const animations = {
  animation: {
    Feature: AnimationFeature
  },
  exit: {
    Feature: ExitAnimationFeature
  }
};
function addDomEvent(target, eventName, handler, options = { passive: true }) {
  target.addEventListener(eventName, handler, options);
  return () => target.removeEventListener(eventName, handler);
}
function extractEventInfo(event) {
  return {
    point: {
      x: event.pageX,
      y: event.pageY
    }
  };
}
const addPointerInfo = (handler) => {
  return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
};
function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent(target, eventName, addPointerInfo(handler), options);
}
function convertBoundingBoxToBox({ top, left, right, bottom }) {
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom }
  };
}
function convertBoxToBoundingBox({ x: x2, y: y2 }) {
  return { top: y2.min, right: x2.max, bottom: y2.max, left: x2.min };
}
function transformBoxPoints(point, transformPoint2) {
  if (!transformPoint2)
    return point;
  const topLeft = transformPoint2({ x: point.left, y: point.top });
  const bottomRight = transformPoint2({ x: point.right, y: point.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
const SCALE_PRECISION = 1e-4;
const SCALE_MIN = 1 - SCALE_PRECISION;
const SCALE_MAX = 1 + SCALE_PRECISION;
const TRANSLATE_PRECISION = 0.01;
const TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;
const TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
function calcLength(axis) {
  return axis.max - axis.min;
}
function isNear(value, target, maxDistance) {
  return Math.abs(value - target) <= maxDistance;
}
function calcAxisDelta(delta, source, target, origin = 0.5) {
  delta.origin = origin;
  delta.originPoint = mixNumber$1(source.min, source.max, delta.origin);
  delta.scale = calcLength(target) / calcLength(source);
  delta.translate = mixNumber$1(target.min, target.max, delta.origin) - delta.originPoint;
  if (delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX || isNaN(delta.scale)) {
    delta.scale = 1;
  }
  if (delta.translate >= TRANSLATE_MIN && delta.translate <= TRANSLATE_MAX || isNaN(delta.translate)) {
    delta.translate = 0;
  }
}
function calcBoxDelta(delta, source, target, origin) {
  calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0);
  calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
}
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min;
  target.max = target.min + calcLength(relative);
}
function calcRelativeBox(target, relative, parent) {
  calcRelativeAxis(target.x, relative.x, parent.x);
  calcRelativeAxis(target.y, relative.y, parent.y);
}
function calcRelativeAxisPosition(target, layout2, parent) {
  target.min = layout2.min - parent.min;
  target.max = target.min + calcLength(layout2);
}
function calcRelativePosition(target, layout2, parent) {
  calcRelativeAxisPosition(target.x, layout2.x, parent.x);
  calcRelativeAxisPosition(target.y, layout2.y, parent.y);
}
const createAxisDelta = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
});
const createDelta = () => ({
  x: createAxisDelta(),
  y: createAxisDelta()
});
const createAxis = () => ({ min: 0, max: 0 });
const createBox = () => ({
  x: createAxis(),
  y: createAxis()
});
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
function hasScale({ scale: scale2, scaleX: scaleX2, scaleY: scaleY2 }) {
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX2) || !isIdentityScale(scaleY2);
}
function hasTransform(values) {
  return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY || values.skewX || values.skewY;
}
function has2DTranslate(values) {
  return is2DTranslate(values.x) || is2DTranslate(values.y);
}
function is2DTranslate(value) {
  return value && value !== "0%";
}
function scalePoint(point, scale2, originPoint) {
  const distanceFromOrigin = point - originPoint;
  const scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
  if (boxScale !== void 0) {
    point = scalePoint(point, boxScale, originPoint);
  }
  return scalePoint(point, scale2, originPoint) + translate;
}
function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, { x: x2, y: y2 }) {
  applyAxisDelta(box.x, x2.translate, x2.scale, x2.originPoint);
  applyAxisDelta(box.y, y2.translate, y2.scale, y2.originPoint);
}
const TREE_SCALE_SNAP_MIN = 0.999999999999;
const TREE_SCALE_SNAP_MAX = 1.0000000000001;
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
  const treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  let node;
  let delta;
  for (let i2 = 0; i2 < treeLength; i2++) {
    node = treePath[i2];
    delta = node.projectionDelta;
    const { visualElement } = node.options;
    if (visualElement && visualElement.props.style && visualElement.props.style.display === "contents") {
      continue;
    }
    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
      transformBox(box, {
        x: -node.scroll.offset.x,
        y: -node.scroll.offset.y
      });
    }
    if (delta) {
      treeScale.x *= delta.x.scale;
      treeScale.y *= delta.y.scale;
      applyBoxDelta(box, delta);
    }
    if (isSharedTransition && hasTransform(node.latestValues)) {
      transformBox(box, node.latestValues);
    }
  }
  if (treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN) {
    treeScale.x = 1;
  }
  if (treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN) {
    treeScale.y = 1;
  }
}
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2;
  axis.max = axis.max + distance2;
}
function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {
  const originPoint = mixNumber$1(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
}
function transformBox(box, transform) {
  transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);
  transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);
}
function measureViewportBox(instance, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
}
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  const viewportBox = measureViewportBox(element, transformPagePoint);
  const { scroll } = rootProjectionNode2;
  if (scroll) {
    translateAxis(viewportBox.x, scroll.offset.x);
    translateAxis(viewportBox.y, scroll.offset.y);
  }
  return viewportBox;
}
const getContextWindow = ({ current }) => {
  return current ? current.ownerDocument.defaultView : null;
};
const distance = (a2, b2) => Math.abs(a2 - b2);
function distance2D(a2, b2) {
  const xDelta = distance(a2.x, b2.x);
  const yDelta = distance(a2.y, b2.y);
  return Math.sqrt(xDelta ** 2 + yDelta ** 2);
}
class PanSession {
  constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false } = {}) {
    this.startEvent = null;
    this.lastMoveEvent = null;
    this.lastMoveEventInfo = null;
    this.handlers = {};
    this.contextWindow = window;
    this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
      const isPanStarted = this.startEvent !== null;
      const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= 3;
      if (!isPanStarted && !isDistancePastThreshold)
        return;
      const { point: point2 } = info2;
      const { timestamp: timestamp2 } = frameData;
      this.history.push({ ...point2, timestamp: timestamp2 });
      const { onStart, onMove } = this.handlers;
      if (!isPanStarted) {
        onStart && onStart(this.lastMoveEvent, info2);
        this.startEvent = this.lastMoveEvent;
      }
      onMove && onMove(this.lastMoveEvent, info2);
    };
    this.handlePointerMove = (event2, info2) => {
      this.lastMoveEvent = event2;
      this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
      frame.update(this.updatePoint, true);
    };
    this.handlePointerUp = (event2, info2) => {
      this.end();
      const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
      if (this.dragSnapToOrigin)
        resumeAnimation && resumeAnimation();
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
      if (this.startEvent && onEnd) {
        onEnd(event2, panInfo);
      }
      onSessionEnd && onSessionEnd(event2, panInfo);
    };
    if (!isPrimaryPointer(event))
      return;
    this.dragSnapToOrigin = dragSnapToOrigin;
    this.handlers = handlers;
    this.transformPagePoint = transformPagePoint;
    this.contextWindow = contextWindow || window;
    const info = extractEventInfo(event);
    const initialInfo = transformPoint(info, this.transformPagePoint);
    const { point } = initialInfo;
    const { timestamp } = frameData;
    this.history = [{ ...point, timestamp }];
    const { onSessionStart } = handlers;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
    this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(handlers) {
    this.handlers = handlers;
  }
  end() {
    this.removeListeners && this.removeListeners();
    cancelFrame(this.updatePoint);
  }
}
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a2, b2) {
  return { x: a2.x - b2.x, y: a2.y - b2.y };
}
function getPanInfo({ point }, history) {
  return {
    point,
    delta: subtractPoint(point, lastDevicePoint(history)),
    offset: subtractPoint(point, startDevicePoint(history)),
    velocity: getVelocity(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity(history, timeDelta) {
  if (history.length < 2) {
    return { x: 0, y: 0 };
  }
  let i2 = history.length - 1;
  let timestampedPoint = null;
  const lastPoint = lastDevicePoint(history);
  while (i2 >= 0) {
    timestampedPoint = history[i2];
    if (lastPoint.timestamp - timestampedPoint.timestamp > /* @__PURE__ */ secondsToMilliseconds(timeDelta)) {
      break;
    }
    i2--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0 };
  }
  const time2 = /* @__PURE__ */ millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
  if (time2 === 0) {
    return { x: 0, y: 0 };
  }
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time2,
    y: (lastPoint.y - timestampedPoint.y) / time2
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}
function applyConstraints(point, { min: min2, max: max2 }, elastic) {
  if (min2 !== void 0 && point < min2) {
    point = elastic ? mixNumber$1(min2, point, elastic.min) : Math.max(point, min2);
  } else if (max2 !== void 0 && point > max2) {
    point = elastic ? mixNumber$1(max2, point, elastic.max) : Math.min(point, max2);
  }
  return point;
}
function calcRelativeAxisConstraints(axis, min2, max2) {
  return {
    min: min2 !== void 0 ? axis.min + min2 : void 0,
    max: max2 !== void 0 ? axis.max + max2 - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  let min2 = constraintsAxis.min - layoutAxis.min;
  let max2 = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    [min2, max2] = [max2, min2];
  }
  return { min: min2, max: max2 };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcOrigin(source, target) {
  let origin = 0.5;
  const sourceLength = calcLength(source);
  const targetLength = calcLength(target);
  if (targetLength > sourceLength) {
    origin = /* @__PURE__ */ progress(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin = /* @__PURE__ */ progress(source.min, source.max - targetLength, target.min);
  }
  return clamp(0, 1, origin);
}
function rebaseAxisConstraints(layout2, constraints) {
  const relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout2.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout2.min;
  }
  return relativeConstraints;
}
const defaultElastic = 0.35;
function resolveDragElastic(dragElastic = defaultElastic) {
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label) {
  return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
}
const elementDragControls = /* @__PURE__ */ new WeakMap();
class VisualElementDragControls {
  constructor(visualElement) {
    this.openDragLock = null;
    this.isDragging = false;
    this.currentDirection = null;
    this.originPoint = { x: 0, y: 0 };
    this.constraints = false;
    this.hasMutatedConstraints = false;
    this.elastic = createBox();
    this.visualElement = visualElement;
  }
  start(originEvent, { snapToCursor = false } = {}) {
    const { presenceContext } = this.visualElement;
    if (presenceContext && presenceContext.isPresent === false)
      return;
    const onSessionStart = (event) => {
      const { dragSnapToOrigin: dragSnapToOrigin2 } = this.getProps();
      dragSnapToOrigin2 ? this.pauseAnimation() : this.stopAnimation();
      if (snapToCursor) {
        this.snapToCursor(extractEventInfo(event).point);
      }
    };
    const onStart = (event, info) => {
      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
      if (drag2 && !dragPropagation) {
        if (this.openDragLock)
          this.openDragLock();
        this.openDragLock = setDragLock(drag2);
        if (!this.openDragLock)
          return;
      }
      this.isDragging = true;
      this.currentDirection = null;
      this.resolveConstraints();
      if (this.visualElement.projection) {
        this.visualElement.projection.isAnimationBlocked = true;
        this.visualElement.projection.target = void 0;
      }
      eachAxis((axis) => {
        let current = this.getAxisMotionValue(axis).get() || 0;
        if (percent.test(current)) {
          const { projection } = this.visualElement;
          if (projection && projection.layout) {
            const measuredAxis = projection.layout.layoutBox[axis];
            if (measuredAxis) {
              const length = calcLength(measuredAxis);
              current = length * (parseFloat(current) / 100);
            }
          }
        }
        this.originPoint[axis] = current;
      });
      if (onDragStart) {
        frame.postRender(() => onDragStart(event, info));
      }
      addValueToWillChange(this.visualElement, "transform");
      const { animationState } = this.visualElement;
      animationState && animationState.setActive("whileDrag", true);
    };
    const onMove = (event, info) => {
      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
      if (!dragPropagation && !this.openDragLock)
        return;
      const { offset } = info;
      if (dragDirectionLock && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(offset);
        if (this.currentDirection !== null) {
          onDirectionLock && onDirectionLock(this.currentDirection);
        }
        return;
      }
      this.updateAxis("x", info.point, offset);
      this.updateAxis("y", info.point, offset);
      this.visualElement.render();
      onDrag && onDrag(event, info);
    };
    const onSessionEnd = (event, info) => this.stop(event, info);
    const resumeAnimation = () => eachAxis((axis) => this.getAnimationState(axis) === "paused" && this.getAxisMotionValue(axis).animation?.play());
    const { dragSnapToOrigin } = this.getProps();
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onSessionEnd,
      resumeAnimation
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin,
      contextWindow: getContextWindow(this.visualElement)
    });
  }
  stop(event, info) {
    const isDragging2 = this.isDragging;
    this.cancel();
    if (!isDragging2)
      return;
    const { velocity } = info;
    this.startAnimation(velocity);
    const { onDragEnd } = this.getProps();
    if (onDragEnd) {
      frame.postRender(() => onDragEnd(event, info));
    }
  }
  cancel() {
    this.isDragging = false;
    const { projection, animationState } = this.visualElement;
    if (projection) {
      projection.isAnimationBlocked = false;
    }
    this.panSession && this.panSession.end();
    this.panSession = void 0;
    const { dragPropagation } = this.getProps();
    if (!dragPropagation && this.openDragLock) {
      this.openDragLock();
      this.openDragLock = null;
    }
    animationState && animationState.setActive("whileDrag", false);
  }
  updateAxis(axis, _point, offset) {
    const { drag: drag2 } = this.getProps();
    if (!offset || !shouldDrag(axis, drag2, this.currentDirection))
      return;
    const axisValue = this.getAxisMotionValue(axis);
    let next = this.originPoint[axis] + offset[axis];
    if (this.constraints && this.constraints[axis]) {
      next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);
    }
    axisValue.set(next);
  }
  resolveConstraints() {
    const { dragConstraints, dragElastic } = this.getProps();
    const layout2 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : this.visualElement.projection?.layout;
    const prevConstraints = this.constraints;
    if (dragConstraints && isRefObject(dragConstraints)) {
      if (!this.constraints) {
        this.constraints = this.resolveRefConstraints();
      }
    } else {
      if (dragConstraints && layout2) {
        this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints);
      } else {
        this.constraints = false;
      }
    }
    this.elastic = resolveDragElastic(dragElastic);
    if (prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints) {
      eachAxis((axis) => {
        if (this.constraints !== false && this.getAxisMotionValue(axis)) {
          this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]);
        }
      });
    }
  }
  resolveRefConstraints() {
    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
    if (!constraints || !isRefObject(constraints))
      return false;
    const constraintsElement = constraints.current;
    const { projection } = this.visualElement;
    if (!projection || !projection.layout)
      return false;
    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
    if (onMeasureDragConstraints) {
      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints;
      if (userConstraints) {
        measuredConstraints = convertBoundingBoxToBox(userConstraints);
      }
    }
    return measuredConstraints;
  }
  startAnimation(velocity) {
    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
    const constraints = this.constraints || {};
    const momentumAnimations = eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, this.currentDirection)) {
        return;
      }
      let transition = constraints && constraints[axis] || {};
      if (dragSnapToOrigin)
        transition = { min: 0, max: 0 };
      const bounceStiffness = dragElastic ? 200 : 1e6;
      const bounceDamping = dragElastic ? 40 : 1e7;
      const inertia2 = {
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...dragTransition,
        ...transition
      };
      return this.startAxisValueAnimation(axis, inertia2);
    });
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  }
  startAxisValueAnimation(axis, transition) {
    const axisValue = this.getAxisMotionValue(axis);
    addValueToWillChange(this.visualElement, axis);
    return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));
  }
  stopAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).stop());
  }
  pauseAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).animation?.pause());
  }
  getAnimationState(axis) {
    return this.getAxisMotionValue(axis).animation?.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(axis) {
    const dragKey = `_drag${axis.toUpperCase()}`;
    const props = this.visualElement.getProps();
    const externalMotionValue = props[dragKey];
    return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
  }
  snapToCursor(point) {
    eachAxis((axis) => {
      const { drag: drag2 } = this.getProps();
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      const { projection } = this.visualElement;
      const axisValue = this.getAxisMotionValue(axis);
      if (projection && projection.layout) {
        const { min: min2, max: max2 } = projection.layout.layoutBox[axis];
        axisValue.set(point[axis] - mixNumber$1(min2, max2, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: drag2, dragConstraints } = this.getProps();
    const { projection } = this.visualElement;
    if (!isRefObject(dragConstraints) || !projection || !this.constraints)
      return;
    this.stopAnimation();
    const boxProgress = { x: 0, y: 0 };
    eachAxis((axis) => {
      const axisValue = this.getAxisMotionValue(axis);
      if (axisValue && this.constraints !== false) {
        const latest = axisValue.get();
        boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);
      }
    });
    const { transformTemplate } = this.visualElement.getProps();
    this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
    projection.root && projection.root.updateScroll();
    projection.updateLayout();
    this.resolveConstraints();
    eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, null))
        return;
      const axisValue = this.getAxisMotionValue(axis);
      const { min: min2, max: max2 } = this.constraints[axis];
      axisValue.set(mixNumber$1(min2, max2, boxProgress[axis]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    elementDragControls.set(this.visualElement, this);
    const element = this.visualElement.current;
    const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
      const { drag: drag2, dragListener = true } = this.getProps();
      drag2 && dragListener && this.start(event);
    });
    const measureDragConstraints = () => {
      const { dragConstraints } = this.getProps();
      if (isRefObject(dragConstraints) && dragConstraints.current) {
        this.constraints = this.resolveRefConstraints();
      }
    };
    const { projection } = this.visualElement;
    const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
    if (projection && !projection.layout) {
      projection.root && projection.root.updateScroll();
      projection.updateLayout();
    }
    frame.read(measureDragConstraints);
    const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
    const stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta, hasLayoutChanged }) => {
      if (this.isDragging && hasLayoutChanged) {
        eachAxis((axis) => {
          const motionValue2 = this.getAxisMotionValue(axis);
          if (!motionValue2)
            return;
          this.originPoint[axis] += delta[axis].translate;
          motionValue2.set(motionValue2.get() + delta[axis].translate);
        });
        this.visualElement.render();
      }
    });
    return () => {
      stopResizeListener();
      stopPointerListener();
      stopMeasureLayoutListener();
      stopLayoutUpdateListener && stopLayoutUpdateListener();
    };
  }
  getProps() {
    const props = this.visualElement.getProps();
    const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;
    return {
      ...props,
      drag: drag2,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum
    };
  }
}
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
function getCurrentDirection(offset, lockThreshold = 10) {
  let direction = null;
  if (Math.abs(offset.y) > lockThreshold) {
    direction = "y";
  } else if (Math.abs(offset.x) > lockThreshold) {
    direction = "x";
  }
  return direction;
}
class DragGesture extends Feature {
  constructor(node) {
    super(node);
    this.removeGroupControls = noop;
    this.removeListeners = noop;
    this.controls = new VisualElementDragControls(node);
  }
  mount() {
    const { dragControls } = this.node.getProps();
    if (dragControls) {
      this.removeGroupControls = dragControls.subscribe(this.controls);
    }
    this.removeListeners = this.controls.addListeners() || noop;
  }
  unmount() {
    this.removeGroupControls();
    this.removeListeners();
  }
}
const asyncHandler = (handler) => (event, info) => {
  if (handler) {
    frame.postRender(() => handler(event, info));
  }
};
class PanGesture extends Feature {
  constructor() {
    super(...arguments);
    this.removePointerDownListener = noop;
  }
  onPointerDown(pointerDownEvent) {
    this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: getContextWindow(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
    return {
      onSessionStart: asyncHandler(onPanSessionStart),
      onStart: asyncHandler(onPanStart),
      onMove: onPan,
      onEnd: (event, info) => {
        delete this.session;
        if (onPanEnd) {
          frame.postRender(() => onPanEnd(event, info));
        }
      }
    };
  }
  mount() {
    this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener();
    this.session && this.session.end();
  }
}
const globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: true,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: false
};
function pixelsToPercent(pixels, axis) {
  if (axis.max === axis.min)
    return 0;
  return pixels / (axis.max - axis.min) * 100;
}
const correctBorderRadius = {
  correct: (latest, node) => {
    if (!node.target)
      return latest;
    if (typeof latest === "string") {
      if (px.test(latest)) {
        latest = parseFloat(latest);
      } else {
        return latest;
      }
    }
    const x2 = pixelsToPercent(latest, node.target.x);
    const y2 = pixelsToPercent(latest, node.target.y);
    return `${x2}% ${y2}%`;
  }
};
const correctBoxShadow = {
  correct: (latest, { treeScale, projectionDelta }) => {
    const original = latest;
    const shadow = complex.parse(latest);
    if (shadow.length > 5)
      return original;
    const template = complex.createTransformer(latest);
    const offset = typeof shadow[0] !== "number" ? 1 : 0;
    const xScale = projectionDelta.x.scale * treeScale.x;
    const yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset] /= xScale;
    shadow[1 + offset] /= yScale;
    const averageScale = mixNumber$1(xScale, yScale, 0.5);
    if (typeof shadow[2 + offset] === "number")
      shadow[2 + offset] /= averageScale;
    if (typeof shadow[3 + offset] === "number")
      shadow[3 + offset] /= averageScale;
    return template(shadow);
  }
};
class MeasureLayoutWithContext extends reactExports.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
    const { projection } = visualElement;
    addScaleCorrector(defaultScaleCorrectors);
    if (projection) {
      if (layoutGroup.group)
        layoutGroup.group.add(projection);
      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
        switchLayoutGroup.register(projection);
      }
      projection.root.didUpdate();
      projection.addEventListener("animationComplete", () => {
        this.safeToRemove();
      });
      projection.setOptions({
        ...projection.options,
        onExitComplete: () => this.safeToRemove()
      });
    }
    globalProjectionState.hasEverUpdated = true;
  }
  getSnapshotBeforeUpdate(prevProps) {
    const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props;
    const { projection } = visualElement;
    if (!projection)
      return null;
    projection.isPresent = isPresent;
    if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0 || prevProps.isPresent !== isPresent) {
      projection.willUpdate();
    } else {
      this.safeToRemove();
    }
    if (prevProps.isPresent !== isPresent) {
      if (isPresent) {
        projection.promote();
      } else if (!projection.relegate()) {
        frame.postRender(() => {
          const stack = projection.getStack();
          if (!stack || !stack.members.length) {
            this.safeToRemove();
          }
        });
      }
    }
    return null;
  }
  componentDidUpdate() {
    const { projection } = this.props.visualElement;
    if (projection) {
      projection.root.didUpdate();
      microtask.postRender(() => {
        if (!projection.currentAnimation && projection.isLead()) {
          this.safeToRemove();
        }
      });
    }
  }
  componentWillUnmount() {
    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
    const { projection } = visualElement;
    if (projection) {
      projection.scheduleCheckAfterUnmount();
      if (layoutGroup && layoutGroup.group)
        layoutGroup.group.remove(projection);
      if (promoteContext && promoteContext.deregister)
        promoteContext.deregister(projection);
    }
  }
  safeToRemove() {
    const { safeToRemove } = this.props;
    safeToRemove && safeToRemove();
  }
  render() {
    return null;
  }
}
function MeasureLayout(props) {
  const [isPresent, safeToRemove] = usePresence();
  const layoutGroup = reactExports.useContext(LayoutGroupContext);
  return jsxRuntimeExports.jsx(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext), isPresent, safeToRemove });
}
const defaultScaleCorrectors = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
};
function animateSingleValue(value, keyframes2, options) {
  const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
  motionValue$1.start(animateMotionValue("", motionValue$1, keyframes2, options));
  return motionValue$1.animation;
}
const compareByDepth = (a2, b2) => a2.depth - b2.depth;
class FlatTree {
  constructor() {
    this.children = [];
    this.isDirty = false;
  }
  add(child) {
    addUniqueItem(this.children, child);
    this.isDirty = true;
  }
  remove(child) {
    removeItem(this.children, child);
    this.isDirty = true;
  }
  forEach(callback) {
    this.isDirty && this.children.sort(compareByDepth);
    this.isDirty = false;
    this.children.forEach(callback);
  }
}
function delay(callback, timeout) {
  const start = time.now();
  const checkElapsed = ({ timestamp }) => {
    const elapsed = timestamp - start;
    if (elapsed >= timeout) {
      cancelFrame(checkElapsed);
      callback(elapsed - timeout);
    }
  };
  frame.setup(checkElapsed, true);
  return () => cancelFrame(checkElapsed);
}
const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
const numBorders = borders.length;
const asNumber = (value) => typeof value === "string" ? parseFloat(value) : value;
const isPx = (value) => typeof value === "number" || px.test(value);
function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
  if (shouldCrossfadeOpacity) {
    target.opacity = mixNumber$1(0, lead.opacity ?? 1, easeCrossfadeIn(progress2));
    target.opacityExit = mixNumber$1(follow.opacity ?? 1, 0, easeCrossfadeOut(progress2));
  } else if (isOnlyMember) {
    target.opacity = mixNumber$1(follow.opacity ?? 1, lead.opacity ?? 1, progress2);
  }
  for (let i2 = 0; i2 < numBorders; i2++) {
    const borderLabel = `border${borders[i2]}Radius`;
    let followRadius = getRadius(follow, borderLabel);
    let leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
    if (canMix) {
      target[borderLabel] = Math.max(mixNumber$1(asNumber(followRadius), asNumber(leadRadius), progress2), 0);
      if (percent.test(leadRadius) || percent.test(followRadius)) {
        target[borderLabel] += "%";
      }
    } else {
      target[borderLabel] = leadRadius;
    }
  }
  if (follow.rotate || lead.rotate) {
    target.rotate = mixNumber$1(follow.rotate || 0, lead.rotate || 0, progress2);
  }
}
function getRadius(values, radiusName) {
  return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
}
const easeCrossfadeIn = /* @__PURE__ */ compress(0, 0.5, circOut);
const easeCrossfadeOut = /* @__PURE__ */ compress(0.5, 0.95, noop);
function compress(min2, max2, easing) {
  return (p2) => {
    if (p2 < min2)
      return 0;
    if (p2 > max2)
      return 1;
    return easing(/* @__PURE__ */ progress(min2, max2, p2));
  };
}
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x);
  copyAxisInto(box.y, originBox.y);
}
function copyAxisDeltaInto(delta, originDelta) {
  delta.translate = originDelta.translate;
  delta.scale = originDelta.scale;
  delta.originPoint = originDelta.originPoint;
  delta.origin = originDelta.origin;
}
function removePointDelta(point, translate, scale2, originPoint, boxScale) {
  point -= translate;
  point = scalePoint(point, 1 / scale2, originPoint);
  if (boxScale !== void 0) {
    point = scalePoint(point, 1 / boxScale, originPoint);
  }
  return point;
}
function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
  if (percent.test(translate)) {
    translate = parseFloat(translate);
    const relativeProgress = mixNumber$1(sourceAxis.min, sourceAxis.max, translate / 100);
    translate = relativeProgress - sourceAxis.min;
  }
  if (typeof translate !== "number")
    return;
  let originPoint = mixNumber$1(originAxis.min, originAxis.max, origin);
  if (axis === originAxis)
    originPoint -= translate;
  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {
  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
}
const xKeys = ["x", "scaleX", "originX"];
const yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);
  removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
}
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
function axisEquals(a2, b2) {
  return a2.min === b2.min && a2.max === b2.max;
}
function boxEquals(a2, b2) {
  return axisEquals(a2.x, b2.x) && axisEquals(a2.y, b2.y);
}
function axisEqualsRounded(a2, b2) {
  return Math.round(a2.min) === Math.round(b2.min) && Math.round(a2.max) === Math.round(b2.max);
}
function boxEqualsRounded(a2, b2) {
  return axisEqualsRounded(a2.x, b2.x) && axisEqualsRounded(a2.y, b2.y);
}
function aspectRatio(box) {
  return calcLength(box.x) / calcLength(box.y);
}
function axisDeltaEquals(a2, b2) {
  return a2.translate === b2.translate && a2.scale === b2.scale && a2.originPoint === b2.originPoint;
}
class NodeStack {
  constructor() {
    this.members = [];
  }
  add(node) {
    addUniqueItem(this.members, node);
    node.scheduleRender();
  }
  remove(node) {
    removeItem(this.members, node);
    if (node === this.prevLead) {
      this.prevLead = void 0;
    }
    if (node === this.lead) {
      const prevLead = this.members[this.members.length - 1];
      if (prevLead) {
        this.promote(prevLead);
      }
    }
  }
  relegate(node) {
    const indexOfNode = this.members.findIndex((member) => node === member);
    if (indexOfNode === 0)
      return false;
    let prevLead;
    for (let i2 = indexOfNode; i2 >= 0; i2--) {
      const member = this.members[i2];
      if (member.isPresent !== false) {
        prevLead = member;
        break;
      }
    }
    if (prevLead) {
      this.promote(prevLead);
      return true;
    } else {
      return false;
    }
  }
  promote(node, preserveFollowOpacity) {
    const prevLead = this.lead;
    if (node === prevLead)
      return;
    this.prevLead = prevLead;
    this.lead = node;
    node.show();
    if (prevLead) {
      prevLead.instance && prevLead.scheduleRender();
      node.scheduleRender();
      node.resumeFrom = prevLead;
      if (preserveFollowOpacity) {
        node.resumeFrom.preserveOpacity = true;
      }
      if (prevLead.snapshot) {
        node.snapshot = prevLead.snapshot;
        node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
      }
      if (node.root && node.root.isUpdating) {
        node.isLayoutDirty = true;
      }
      const { crossfade } = node.options;
      if (crossfade === false) {
        prevLead.hide();
      }
    }
  }
  exitAnimationComplete() {
    this.members.forEach((node) => {
      const { options, resumingFrom } = node;
      options.onExitComplete && options.onExitComplete();
      if (resumingFrom) {
        resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
      }
    });
  }
  scheduleRender() {
    this.members.forEach((node) => {
      node.instance && node.scheduleRender(false);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    if (this.lead && this.lead.snapshot) {
      this.lead.snapshot = void 0;
    }
  }
}
function buildProjectionTransform(delta, treeScale, latestTransform) {
  let transform = "";
  const xTranslate = delta.x.translate / treeScale.x;
  const yTranslate = delta.y.translate / treeScale.y;
  const zTranslate = latestTransform?.z || 0;
  if (xTranslate || yTranslate || zTranslate) {
    transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;
  }
  if (treeScale.x !== 1 || treeScale.y !== 1) {
    transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
  }
  if (latestTransform) {
    const { transformPerspective, rotate: rotate2, rotateX, rotateY, skewX, skewY } = latestTransform;
    if (transformPerspective)
      transform = `perspective(${transformPerspective}px) ${transform}`;
    if (rotate2)
      transform += `rotate(${rotate2}deg) `;
    if (rotateX)
      transform += `rotateX(${rotateX}deg) `;
    if (rotateY)
      transform += `rotateY(${rotateY}deg) `;
    if (skewX)
      transform += `skewX(${skewX}deg) `;
    if (skewY)
      transform += `skewY(${skewY}deg) `;
  }
  const elementScaleX = delta.x.scale * treeScale.x;
  const elementScaleY = delta.y.scale * treeScale.y;
  if (elementScaleX !== 1 || elementScaleY !== 1) {
    transform += `scale(${elementScaleX}, ${elementScaleY})`;
  }
  return transform || "none";
}
const transformAxes = ["", "X", "Y", "Z"];
const hiddenVisibility = { visibility: "hidden" };
const animationTarget = 1e3;
let id = 0;
function resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {
  const { latestValues } = visualElement;
  if (latestValues[key]) {
    values[key] = latestValues[key];
    visualElement.setStaticValue(key, 0);
    if (sharedAnimationValues) {
      sharedAnimationValues[key] = 0;
    }
  }
}
function cancelTreeOptimisedTransformAnimations(projectionNode) {
  projectionNode.hasCheckedOptimisedAppear = true;
  if (projectionNode.root === projectionNode)
    return;
  const { visualElement } = projectionNode.options;
  if (!visualElement)
    return;
  const appearId = getOptimisedAppearId(visualElement);
  if (window.MotionHasOptimisedAnimation(appearId, "transform")) {
    const { layout: layout2, layoutId } = projectionNode.options;
    window.MotionCancelOptimisedAnimation(appearId, "transform", frame, !(layout2 || layoutId));
  }
  const { parent } = projectionNode;
  if (parent && !parent.hasCheckedOptimisedAppear) {
    cancelTreeOptimisedTransformAnimations(parent);
  }
}
function createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
  return class ProjectionNode {
    constructor(latestValues = {}, parent = defaultParent?.()) {
      this.id = id++;
      this.animationId = 0;
      this.children = /* @__PURE__ */ new Set();
      this.options = {};
      this.isTreeAnimating = false;
      this.isAnimationBlocked = false;
      this.isLayoutDirty = false;
      this.isProjectionDirty = false;
      this.isSharedProjectionDirty = false;
      this.isTransformDirty = false;
      this.updateManuallyBlocked = false;
      this.updateBlockedByResize = false;
      this.isUpdating = false;
      this.isSVG = false;
      this.needsReset = false;
      this.shouldResetTransform = false;
      this.hasCheckedOptimisedAppear = false;
      this.treeScale = { x: 1, y: 1 };
      this.eventHandlers = /* @__PURE__ */ new Map();
      this.hasTreeAnimated = false;
      this.updateScheduled = false;
      this.scheduleUpdate = () => this.update();
      this.projectionUpdateScheduled = false;
      this.checkUpdateFailed = () => {
        if (this.isUpdating) {
          this.isUpdating = false;
          this.clearAllSnapshots();
        }
      };
      this.updateProjection = () => {
        this.projectionUpdateScheduled = false;
        this.nodes.forEach(propagateDirtyNodes);
        this.nodes.forEach(resolveTargetDelta);
        this.nodes.forEach(calcProjection);
        this.nodes.forEach(cleanDirtyNodes);
      };
      this.resolvedRelativeTargetAt = 0;
      this.hasProjected = false;
      this.isVisible = true;
      this.animationProgress = 0;
      this.sharedNodes = /* @__PURE__ */ new Map();
      this.latestValues = latestValues;
      this.root = parent ? parent.root || parent : this;
      this.path = parent ? [...parent.path, parent] : [];
      this.parent = parent;
      this.depth = parent ? parent.depth + 1 : 0;
      for (let i2 = 0; i2 < this.path.length; i2++) {
        this.path[i2].shouldResetTransform = true;
      }
      if (this.root === this)
        this.nodes = new FlatTree();
    }
    addEventListener(name, handler) {
      if (!this.eventHandlers.has(name)) {
        this.eventHandlers.set(name, new SubscriptionManager());
      }
      return this.eventHandlers.get(name).add(handler);
    }
    notifyListeners(name, ...args) {
      const subscriptionManager = this.eventHandlers.get(name);
      subscriptionManager && subscriptionManager.notify(...args);
    }
    hasListeners(name) {
      return this.eventHandlers.has(name);
    }
    /**
     * Lifecycles
     */
    mount(instance) {
      if (this.instance)
        return;
      this.isSVG = isSVGElement(instance) && !isSVGSVGElement(instance);
      this.instance = instance;
      const { layoutId, layout: layout2, visualElement } = this.options;
      if (visualElement && !visualElement.current) {
        visualElement.mount(instance);
      }
      this.root.nodes.add(this);
      this.parent && this.parent.children.add(this);
      if (this.root.hasTreeAnimated && (layout2 || layoutId)) {
        this.isLayoutDirty = true;
      }
      if (attachResizeListener) {
        let cancelDelay;
        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
        attachResizeListener(instance, () => {
          this.root.updateBlockedByResize = true;
          cancelDelay && cancelDelay();
          cancelDelay = delay(resizeUnblockUpdate, 250);
          if (globalProjectionState.hasAnimatedSinceResize) {
            globalProjectionState.hasAnimatedSinceResize = false;
            this.nodes.forEach(finishAnimation);
          }
        });
      }
      if (layoutId) {
        this.root.registerSharedNode(layoutId, this);
      }
      if (this.options.animate !== false && visualElement && (layoutId || layout2)) {
        this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeLayoutChanged, layout: newLayout }) => {
          if (this.isTreeAnimationBlocked()) {
            this.target = void 0;
            this.relativeTarget = void 0;
            return;
          }
          const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
          const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
          const hasTargetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout);
          const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeLayoutChanged;
          if (this.options.layoutRoot || this.resumeFrom || hasOnlyRelativeTargetChanged || hasLayoutChanged && (hasTargetChanged || !this.currentAnimation)) {
            if (this.resumeFrom) {
              this.resumingFrom = this.resumeFrom;
              this.resumingFrom.resumingFrom = void 0;
            }
            const animationOptions = {
              ...getValueTransition(layoutTransition, "layout"),
              onPlay: onLayoutAnimationStart,
              onComplete: onLayoutAnimationComplete
            };
            if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
              animationOptions.delay = 0;
              animationOptions.type = false;
            }
            this.startAnimation(animationOptions);
            this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
          } else {
            if (!hasLayoutChanged) {
              finishAnimation(this);
            }
            if (this.isLead() && this.options.onExitComplete) {
              this.options.onExitComplete();
            }
          }
          this.targetLayout = newLayout;
        });
      }
    }
    unmount() {
      this.options.layoutId && this.willUpdate();
      this.root.nodes.remove(this);
      const stack = this.getStack();
      stack && stack.remove(this);
      this.parent && this.parent.children.delete(this);
      this.instance = void 0;
      this.eventHandlers.clear();
      cancelFrame(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = true;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = false;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
    }
    // Note: currently only running on root node
    startUpdate() {
      if (this.isUpdateBlocked())
        return;
      this.isUpdating = true;
      this.nodes && this.nodes.forEach(resetSkewAndRotation);
      this.animationId++;
    }
    getTransformTemplate() {
      const { visualElement } = this.options;
      return visualElement && visualElement.getProps().transformTemplate;
    }
    willUpdate(shouldNotifyListeners = true) {
      this.root.hasTreeAnimated = true;
      if (this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear) {
        cancelTreeOptimisedTransformAnimations(this);
      }
      !this.root.isUpdating && this.root.startUpdate();
      if (this.isLayoutDirty)
        return;
      this.isLayoutDirty = true;
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node = this.path[i2];
        node.shouldResetTransform = true;
        node.updateScroll("snapshot");
        if (node.options.layoutRoot) {
          node.willUpdate(false);
        }
      }
      const { layoutId, layout: layout2 } = this.options;
      if (layoutId === void 0 && !layout2)
        return;
      const transformTemplate = this.getTransformTemplate();
      this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
      this.updateSnapshot();
      shouldNotifyListeners && this.notifyListeners("willUpdate");
    }
    update() {
      this.updateScheduled = false;
      const updateWasBlocked = this.isUpdateBlocked();
      if (updateWasBlocked) {
        this.unblockUpdate();
        this.clearAllSnapshots();
        this.nodes.forEach(clearMeasurements);
        return;
      }
      if (!this.isUpdating) {
        this.nodes.forEach(clearIsLayoutDirty);
      }
      this.isUpdating = false;
      this.nodes.forEach(resetTransformStyle);
      this.nodes.forEach(updateLayout);
      this.nodes.forEach(notifyLayoutUpdate);
      this.clearAllSnapshots();
      const now2 = time.now();
      frameData.delta = clamp(0, 1e3 / 60, now2 - frameData.timestamp);
      frameData.timestamp = now2;
      frameData.isProcessing = true;
      frameSteps.update.process(frameData);
      frameSteps.preRender.process(frameData);
      frameSteps.render.process(frameData);
      frameData.isProcessing = false;
    }
    didUpdate() {
      if (!this.updateScheduled) {
        this.updateScheduled = true;
        microtask.read(this.scheduleUpdate);
      }
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot);
      this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      if (!this.projectionUpdateScheduled) {
        this.projectionUpdateScheduled = true;
        frame.preRender(this.updateProjection, false, true);
      }
    }
    scheduleCheckAfterUnmount() {
      frame.postRender(() => {
        if (this.isLayoutDirty) {
          this.root.didUpdate();
        } else {
          this.root.checkUpdateFailed();
        }
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      if (this.snapshot || !this.instance)
        return;
      this.snapshot = this.measure();
      if (this.snapshot && !calcLength(this.snapshot.measuredBox.x) && !calcLength(this.snapshot.measuredBox.y)) {
        this.snapshot = void 0;
      }
    }
    updateLayout() {
      if (!this.instance)
        return;
      this.updateScroll();
      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
        return;
      }
      if (this.resumeFrom && !this.resumeFrom.instance) {
        for (let i2 = 0; i2 < this.path.length; i2++) {
          const node = this.path[i2];
          node.updateScroll();
        }
      }
      const prevLayout = this.layout;
      this.layout = this.measure(false);
      this.layoutCorrected = createBox();
      this.isLayoutDirty = false;
      this.projectionDelta = void 0;
      this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement } = this.options;
      visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
    }
    updateScroll(phase = "measure") {
      let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
        needsMeasurement = false;
      }
      if (needsMeasurement && this.instance) {
        const isRoot = checkIsScrollRoot(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase,
          isRoot,
          offset: measureScroll(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : isRoot
        };
      }
    }
    resetTransform() {
      if (!resetTransform)
        return;
      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout;
      const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
      const transformTemplate = this.getTransformTemplate();
      const transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
      const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      if (isResetRequested && this.instance && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
        resetTransform(this.instance, transformTemplateValue);
        this.shouldResetTransform = false;
        this.scheduleRender();
      }
    }
    measure(removeTransform = true) {
      const pageBox = this.measurePageBox();
      let layoutBox = this.removeElementScroll(pageBox);
      if (removeTransform) {
        layoutBox = this.removeTransform(layoutBox);
      }
      roundBox(layoutBox);
      return {
        animationId: this.root.animationId,
        measuredBox: pageBox,
        layoutBox,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement } = this.options;
      if (!visualElement)
        return createBox();
      const box = visualElement.measureViewportBox();
      const wasInScrollRoot = this.scroll?.wasRoot || this.path.some(checkNodeWasScrollRoot);
      if (!wasInScrollRoot) {
        const { scroll } = this.root;
        if (scroll) {
          translateAxis(box.x, scroll.offset.x);
          translateAxis(box.y, scroll.offset.y);
        }
      }
      return box;
    }
    removeElementScroll(box) {
      const boxWithoutScroll = createBox();
      copyBoxInto(boxWithoutScroll, box);
      if (this.scroll?.wasRoot) {
        return boxWithoutScroll;
      }
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node = this.path[i2];
        const { scroll, options } = node;
        if (node !== this.root && scroll && options.layoutScroll) {
          if (scroll.wasRoot) {
            copyBoxInto(boxWithoutScroll, box);
          }
          translateAxis(boxWithoutScroll.x, scroll.offset.x);
          translateAxis(boxWithoutScroll.y, scroll.offset.y);
        }
      }
      return boxWithoutScroll;
    }
    applyTransform(box, transformOnly = false) {
      const withTransforms = createBox();
      copyBoxInto(withTransforms, box);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node = this.path[i2];
        if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {
          transformBox(withTransforms, {
            x: -node.scroll.offset.x,
            y: -node.scroll.offset.y
          });
        }
        if (!hasTransform(node.latestValues))
          continue;
        transformBox(withTransforms, node.latestValues);
      }
      if (hasTransform(this.latestValues)) {
        transformBox(withTransforms, this.latestValues);
      }
      return withTransforms;
    }
    removeTransform(box) {
      const boxWithoutTransform = createBox();
      copyBoxInto(boxWithoutTransform, box);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node = this.path[i2];
        if (!node.instance)
          continue;
        if (!hasTransform(node.latestValues))
          continue;
        hasScale(node.latestValues) && node.updateSnapshot();
        const sourceBox = createBox();
        const nodeBox = node.measurePageBox();
        copyBoxInto(sourceBox, nodeBox);
        removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : void 0, sourceBox);
      }
      if (hasTransform(this.latestValues)) {
        removeBoxTransforms(boxWithoutTransform, this.latestValues);
      }
      return boxWithoutTransform;
    }
    setTargetDelta(delta) {
      this.targetDelta = delta;
      this.root.scheduleUpdateProjection();
      this.isProjectionDirty = true;
    }
    setOptions(options) {
      this.options = {
        ...this.options,
        ...options,
        crossfade: options.crossfade !== void 0 ? options.crossfade : true
      };
    }
    clearMeasurements() {
      this.scroll = void 0;
      this.layout = void 0;
      this.snapshot = void 0;
      this.prevTransformTemplateValue = void 0;
      this.targetDelta = void 0;
      this.target = void 0;
      this.isLayoutDirty = false;
    }
    forceRelativeParentToResolveTarget() {
      if (!this.relativeParent)
        return;
      if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
        this.relativeParent.resolveTargetDelta(true);
      }
    }
    resolveTargetDelta(forceRecalculation = false) {
      const lead = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
      this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
      this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || this.parent?.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize);
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      if (!this.layout || !(layout2 || layoutId))
        return;
      this.resolvedRelativeTargetAt = frameData.timestamp;
      if (!this.targetDelta && !this.relativeTarget) {
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      if (!this.relativeTarget && !this.targetDelta)
        return;
      if (!this.target) {
        this.target = createBox();
        this.targetWithTransforms = createBox();
      }
      if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
        this.forceRelativeParentToResolveTarget();
        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
      } else if (this.targetDelta) {
        if (Boolean(this.resumingFrom)) {
          this.target = this.applyTransform(this.layout.layoutBox);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        applyBoxDelta(this.target, this.targetDelta);
      } else {
        copyBoxInto(this.target, this.layout.layoutBox);
      }
      if (this.attemptToResolveRelativeTarget) {
        this.attemptToResolveRelativeTarget = false;
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
    }
    getClosestProjectingParent() {
      if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
        return void 0;
      }
      if (this.parent.isProjecting()) {
        return this.parent;
      } else {
        return this.parent.getClosestProjectingParent();
      }
    }
    isProjecting() {
      return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      const lead = this.getLead();
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      let canSkip = true;
      if (this.isProjectionDirty || this.parent?.isProjectionDirty) {
        canSkip = false;
      }
      if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
        canSkip = false;
      }
      if (this.resolvedRelativeTargetAt === frameData.timestamp) {
        canSkip = false;
      }
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
      if (!this.isTreeAnimating) {
        this.targetDelta = this.relativeTarget = void 0;
      }
      if (!this.layout || !(layout2 || layoutId))
        return;
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
      const prevTreeScaleX = this.treeScale.x;
      const prevTreeScaleY = this.treeScale.y;
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
      if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
        lead.target = lead.layout.layoutBox;
        lead.targetWithTransforms = createBox();
      }
      const { target } = lead;
      if (!target) {
        if (this.prevProjectionDelta) {
          this.createProjectionDeltas();
          this.scheduleRender();
        }
        return;
      }
      if (!this.projectionDelta || !this.prevProjectionDelta) {
        this.createProjectionDeltas();
      } else {
        copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);
        copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);
      }
      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
      if (this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {
        this.hasProjected = true;
        this.scheduleRender();
        this.notifyListeners("projectionUpdate", target);
      }
    }
    hide() {
      this.isVisible = false;
    }
    show() {
      this.isVisible = true;
    }
    scheduleRender(notifyAll = true) {
      this.options.visualElement?.scheduleRender();
      if (notifyAll) {
        const stack = this.getStack();
        stack && stack.scheduleRender();
      }
      if (this.resumingFrom && !this.resumingFrom.instance) {
        this.resumingFrom = void 0;
      }
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = createDelta();
      this.projectionDelta = createDelta();
      this.projectionDeltaWithTransform = createDelta();
    }
    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
      const snapshot = this.snapshot;
      const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
      const mixedValues = { ...this.latestValues };
      const targetDelta = createDelta();
      if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
        this.relativeTarget = this.relativeTargetOrigin = void 0;
      }
      this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      const relativeLayout = createBox();
      const snapshotSource = snapshot ? snapshot.source : void 0;
      const layoutSource = this.layout ? this.layout.source : void 0;
      const isSharedLayoutAnimation = snapshotSource !== layoutSource;
      const stack = this.getStack();
      const isOnlyMember = !stack || stack.members.length <= 1;
      const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      let prevRelativeTarget;
      this.mixTargetDelta = (latest) => {
        const progress2 = latest / 1e3;
        mixAxisDelta(targetDelta.x, delta.x, progress2);
        mixAxisDelta(targetDelta.y, delta.y, progress2);
        this.setTargetDelta(targetDelta);
        if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
          calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
          mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);
          if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
            this.isProjectionDirty = false;
          }
          if (!prevRelativeTarget)
            prevRelativeTarget = createBox();
          copyBoxInto(prevRelativeTarget, this.relativeTarget);
        }
        if (isSharedLayoutAnimation) {
          this.animationValues = mixedValues;
          mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
        }
        this.root.scheduleUpdateProjection();
        this.scheduleRender();
        this.animationProgress = progress2;
      };
      this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(options) {
      this.notifyListeners("animationStart");
      this.currentAnimation?.stop();
      this.resumingFrom?.currentAnimation?.stop();
      if (this.pendingAnimation) {
        cancelFrame(this.pendingAnimation);
        this.pendingAnimation = void 0;
      }
      this.pendingAnimation = frame.update(() => {
        globalProjectionState.hasAnimatedSinceResize = true;
        this.motionValue || (this.motionValue = motionValue(0));
        this.currentAnimation = animateSingleValue(this.motionValue, [0, 1e3], {
          ...options,
          velocity: 0,
          isSync: true,
          onUpdate: (latest) => {
            this.mixTargetDelta(latest);
            options.onUpdate && options.onUpdate(latest);
          },
          onStop: () => {
          },
          onComplete: () => {
            options.onComplete && options.onComplete();
            this.completeAnimation();
          }
        });
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = this.currentAnimation;
        }
        this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      if (this.resumingFrom) {
        this.resumingFrom.currentAnimation = void 0;
        this.resumingFrom.preserveOpacity = void 0;
      }
      const stack = this.getStack();
      stack && stack.exitAnimationComplete();
      this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
      this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      if (this.currentAnimation) {
        this.mixTargetDelta && this.mixTargetDelta(animationTarget);
        this.currentAnimation.stop();
      }
      this.completeAnimation();
    }
    applyTransformsToTarget() {
      const lead = this.getLead();
      let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
      if (!targetWithTransforms || !target || !layout2)
        return;
      if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
        target = this.target || createBox();
        const xLength = calcLength(this.layout.layoutBox.x);
        target.x.min = lead.target.x.min;
        target.x.max = target.x.min + xLength;
        const yLength = calcLength(this.layout.layoutBox.y);
        target.y.min = lead.target.y.min;
        target.y.max = target.y.min + yLength;
      }
      copyBoxInto(targetWithTransforms, target);
      transformBox(targetWithTransforms, latestValues);
      calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
    }
    registerSharedNode(layoutId, node) {
      if (!this.sharedNodes.has(layoutId)) {
        this.sharedNodes.set(layoutId, new NodeStack());
      }
      const stack = this.sharedNodes.get(layoutId);
      stack.add(node);
      const config = node.options.initialPromotionConfig;
      node.promote({
        transition: config ? config.transition : void 0,
        preserveFollowOpacity: config && config.shouldPreserveFollowOpacity ? config.shouldPreserveFollowOpacity(node) : void 0
      });
    }
    isLead() {
      const stack = this.getStack();
      return stack ? stack.lead === this : true;
    }
    getLead() {
      const { layoutId } = this.options;
      return layoutId ? this.getStack()?.lead || this : this;
    }
    getPrevLead() {
      const { layoutId } = this.options;
      return layoutId ? this.getStack()?.prevLead : void 0;
    }
    getStack() {
      const { layoutId } = this.options;
      if (layoutId)
        return this.root.sharedNodes.get(layoutId);
    }
    promote({ needsReset, transition, preserveFollowOpacity } = {}) {
      const stack = this.getStack();
      if (stack)
        stack.promote(this, preserveFollowOpacity);
      if (needsReset) {
        this.projectionDelta = void 0;
        this.needsReset = true;
      }
      if (transition)
        this.setOptions({ transition });
    }
    relegate() {
      const stack = this.getStack();
      if (stack) {
        return stack.relegate(this);
      } else {
        return false;
      }
    }
    resetSkewAndRotation() {
      const { visualElement } = this.options;
      if (!visualElement)
        return;
      let hasDistortingTransform = false;
      const { latestValues } = visualElement;
      if (latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) {
        hasDistortingTransform = true;
      }
      if (!hasDistortingTransform)
        return;
      const resetValues = {};
      if (latestValues.z) {
        resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
      }
      for (let i2 = 0; i2 < transformAxes.length; i2++) {
        resetDistortingTransform(`rotate${transformAxes[i2]}`, visualElement, resetValues, this.animationValues);
        resetDistortingTransform(`skew${transformAxes[i2]}`, visualElement, resetValues, this.animationValues);
      }
      visualElement.render();
      for (const key in resetValues) {
        visualElement.setStaticValue(key, resetValues[key]);
        if (this.animationValues) {
          this.animationValues[key] = resetValues[key];
        }
      }
      visualElement.scheduleRender();
    }
    getProjectionStyles(styleProp) {
      if (!this.instance || this.isSVG)
        return void 0;
      if (!this.isVisible) {
        return hiddenVisibility;
      }
      const styles = {
        visibility: ""
      };
      const transformTemplate = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = false;
        styles.opacity = "";
        styles.pointerEvents = resolveMotionValue(styleProp?.pointerEvents) || "";
        styles.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
        return styles;
      }
      const lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        const emptyStyles = {};
        if (this.options.layoutId) {
          emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
          emptyStyles.pointerEvents = resolveMotionValue(styleProp?.pointerEvents) || "";
        }
        if (this.hasProjected && !hasTransform(this.latestValues)) {
          emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none";
          this.hasProjected = false;
        }
        return emptyStyles;
      }
      const valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget();
      styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
      if (transformTemplate) {
        styles.transform = transformTemplate(valuesToRender, styles.transform);
      }
      const { x: x2, y: y2 } = this.projectionDelta;
      styles.transformOrigin = `${x2.origin * 100}% ${y2.origin * 100}% 0`;
      if (lead.animationValues) {
        styles.opacity = lead === this ? valuesToRender.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
      } else {
        styles.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
      }
      for (const key in scaleCorrectors) {
        if (valuesToRender[key] === void 0)
          continue;
        const { correct, applyTo, isCSSVariable } = scaleCorrectors[key];
        const corrected = styles.transform === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
        if (applyTo) {
          const num = applyTo.length;
          for (let i2 = 0; i2 < num; i2++) {
            styles[applyTo[i2]] = corrected;
          }
        } else {
          if (isCSSVariable) {
            this.options.visualElement.renderState.vars[key] = corrected;
          } else {
            styles[key] = corrected;
          }
        }
      }
      if (this.options.layoutId) {
        styles.pointerEvents = lead === this ? resolveMotionValue(styleProp?.pointerEvents) || "" : "none";
      }
      return styles;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((node) => node.currentAnimation?.stop());
      this.root.nodes.forEach(clearMeasurements);
      this.root.sharedNodes.clear();
    }
  };
}
function updateLayout(node) {
  node.updateLayout();
}
function notifyLayoutUpdate(node) {
  const snapshot = node.resumeFrom?.snapshot || node.snapshot;
  if (node.isLead() && node.layout && snapshot && node.hasListeners("didUpdate")) {
    const { layoutBox: layout2, measuredBox: measuredLayout } = node.layout;
    const { animationType } = node.options;
    const isShared = snapshot.source !== node.layout.source;
    if (animationType === "size") {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length = calcLength(axisSnapshot);
        axisSnapshot.min = layout2[axis].min;
        axisSnapshot.max = axisSnapshot.min + length;
      });
    } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2)) {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length = calcLength(layout2[axis]);
        axisSnapshot.max = axisSnapshot.min + length;
        if (node.relativeTarget && !node.currentAnimation) {
          node.isProjectionDirty = true;
          node.relativeTarget[axis].max = node.relativeTarget[axis].min + length;
        }
      });
    }
    const layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
    const visualDelta = createDelta();
    if (isShared) {
      calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);
    } else {
      calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
    }
    const hasLayoutChanged = !isDeltaZero(layoutDelta);
    let hasRelativeLayoutChanged = false;
    if (!node.resumeFrom) {
      const relativeParent = node.getClosestProjectingParent();
      if (relativeParent && !relativeParent.resumeFrom) {
        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
        if (parentSnapshot && parentLayout) {
          const relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
          const relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox);
          if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
            hasRelativeLayoutChanged = true;
          }
          if (relativeParent.options.layoutRoot) {
            node.relativeTarget = relativeLayout;
            node.relativeTargetOrigin = relativeSnapshot;
            node.relativeParent = relativeParent;
          }
        }
      }
    }
    node.notifyListeners("didUpdate", {
      layout: layout2,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeLayoutChanged
    });
  } else if (node.isLead()) {
    const { onExitComplete } = node.options;
    onExitComplete && onExitComplete();
  }
  node.options.transition = void 0;
}
function propagateDirtyNodes(node) {
  if (!node.parent)
    return;
  if (!node.isProjecting()) {
    node.isProjectionDirty = node.parent.isProjectionDirty;
  }
  node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty || node.parent.isProjectionDirty || node.parent.isSharedProjectionDirty));
  node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);
}
function cleanDirtyNodes(node) {
  node.isProjectionDirty = node.isSharedProjectionDirty = node.isTransformDirty = false;
}
function clearSnapshot(node) {
  node.clearSnapshot();
}
function clearMeasurements(node) {
  node.clearMeasurements();
}
function clearIsLayoutDirty(node) {
  node.isLayoutDirty = false;
}
function resetTransformStyle(node) {
  const { visualElement } = node.options;
  if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
    visualElement.notify("BeforeLayoutMeasure");
  }
  node.resetTransform();
}
function finishAnimation(node) {
  node.finishAnimation();
  node.targetDelta = node.relativeTarget = node.target = void 0;
  node.isProjectionDirty = true;
}
function resolveTargetDelta(node) {
  node.resolveTargetDelta();
}
function calcProjection(node) {
  node.calcProjection();
}
function resetSkewAndRotation(node) {
  node.resetSkewAndRotation();
}
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
function mixAxisDelta(output, delta, p2) {
  output.translate = mixNumber$1(delta.translate, 0, p2);
  output.scale = mixNumber$1(delta.scale, 1, p2);
  output.origin = delta.origin;
  output.originPoint = delta.originPoint;
}
function mixAxis(output, from, to2, p2) {
  output.min = mixNumber$1(from.min, to2.min, p2);
  output.max = mixNumber$1(from.max, to2.max, p2);
}
function mixBox(output, from, to2, p2) {
  mixAxis(output.x, from.x, to2.x, p2);
  mixAxis(output.y, from.y, to2.y, p2);
}
function hasOpacityCrossfade(node) {
  return node.animationValues && node.animationValues.opacityExit !== void 0;
}
const defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
const userAgentContains = (string) => typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string);
const roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop;
function roundAxis(axis) {
  axis.min = roundPoint(axis.min);
  axis.max = roundPoint(axis.max);
}
function roundBox(box) {
  roundAxis(box.x);
  roundAxis(box.y);
}
function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
  return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
}
function checkNodeWasScrollRoot(node) {
  return node !== node.root && node.scroll?.wasRoot;
}
const DocumentProjectionNode = createProjectionNode({
  attachResizeListener: (ref2, notify) => addDomEvent(ref2, "resize", notify),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => true
});
const rootProjectionNode = {
  current: void 0
};
const HTMLProjectionNode = createProjectionNode({
  measureScroll: (instance) => ({
    x: instance.scrollLeft,
    y: instance.scrollTop
  }),
  defaultParent: () => {
    if (!rootProjectionNode.current) {
      const documentNode = new DocumentProjectionNode({});
      documentNode.mount(window);
      documentNode.setOptions({ layoutScroll: true });
      rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: (instance, value) => {
    instance.style.transform = value !== void 0 ? value : "none";
  },
  checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed")
});
const drag = {
  pan: {
    Feature: PanGesture
  },
  drag: {
    Feature: DragGesture,
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};
function handleHoverEvent(node, event, lifecycle) {
  const { props } = node;
  if (node.animationState && props.whileHover) {
    node.animationState.setActive("whileHover", lifecycle === "Start");
  }
  const eventName = "onHover" + lifecycle;
  const callback = props[eventName];
  if (callback) {
    frame.postRender(() => callback(event, extractEventInfo(event)));
  }
}
class HoverGesture extends Feature {
  mount() {
    const { current } = this.node;
    if (!current)
      return;
    this.unmount = hover(current, (_element, startEvent) => {
      handleHoverEvent(this.node, startEvent, "Start");
      return (endEvent) => handleHoverEvent(this.node, endEvent, "End");
    });
  }
  unmount() {
  }
}
class FocusGesture extends Feature {
  constructor() {
    super(...arguments);
    this.isActive = false;
  }
  onFocus() {
    let isFocusVisible = false;
    try {
      isFocusVisible = this.node.current.matches(":focus-visible");
    } catch (e2) {
      isFocusVisible = true;
    }
    if (!isFocusVisible || !this.node.animationState)
      return;
    this.node.animationState.setActive("whileFocus", true);
    this.isActive = true;
  }
  onBlur() {
    if (!this.isActive || !this.node.animationState)
      return;
    this.node.animationState.setActive("whileFocus", false);
    this.isActive = false;
  }
  mount() {
    this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
function handlePressEvent(node, event, lifecycle) {
  const { props } = node;
  if (node.current instanceof HTMLButtonElement && node.current.disabled) {
    return;
  }
  if (node.animationState && props.whileTap) {
    node.animationState.setActive("whileTap", lifecycle === "Start");
  }
  const eventName = "onTap" + (lifecycle === "End" ? "" : lifecycle);
  const callback = props[eventName];
  if (callback) {
    frame.postRender(() => callback(event, extractEventInfo(event)));
  }
}
class PressGesture extends Feature {
  mount() {
    const { current } = this.node;
    if (!current)
      return;
    this.unmount = press(current, (_element, startEvent) => {
      handlePressEvent(this.node, startEvent, "Start");
      return (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? "End" : "Cancel");
    }, { useGlobalTarget: this.node.props.globalTapTarget });
  }
  unmount() {
  }
}
const observerCallbacks = /* @__PURE__ */ new WeakMap();
const observers = /* @__PURE__ */ new WeakMap();
const fireObserverCallback = (entry2) => {
  const callback = observerCallbacks.get(entry2.target);
  callback && callback(entry2);
};
const fireAllObserverCallbacks = (entries) => {
  entries.forEach(fireObserverCallback);
};
function initIntersectionObserver({ root: root2, ...options }) {
  const lookupRoot = root2 || document;
  if (!observers.has(lookupRoot)) {
    observers.set(lookupRoot, {});
  }
  const rootObservers = observers.get(lookupRoot);
  const key = JSON.stringify(options);
  if (!rootObservers[key]) {
    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root: root2, ...options });
  }
  return rootObservers[key];
}
function observeIntersection(element, options, callback) {
  const rootInteresectionObserver = initIntersectionObserver(options);
  observerCallbacks.set(element, callback);
  rootInteresectionObserver.observe(element);
  return () => {
    observerCallbacks.delete(element);
    rootInteresectionObserver.unobserve(element);
  };
}
const thresholdNames = {
  some: 0,
  all: 1
};
class InViewFeature extends Feature {
  constructor() {
    super(...arguments);
    this.hasEnteredView = false;
    this.isInView = false;
  }
  startObserver() {
    this.unmount();
    const { viewport = {} } = this.node.getProps();
    const { root: root2, margin: rootMargin, amount = "some", once } = viewport;
    const options = {
      root: root2 ? root2.current : void 0,
      rootMargin,
      threshold: typeof amount === "number" ? amount : thresholdNames[amount]
    };
    const onIntersectionUpdate = (entry2) => {
      const { isIntersecting } = entry2;
      if (this.isInView === isIntersecting)
        return;
      this.isInView = isIntersecting;
      if (once && !isIntersecting && this.hasEnteredView) {
        return;
      } else if (isIntersecting) {
        this.hasEnteredView = true;
      }
      if (this.node.animationState) {
        this.node.animationState.setActive("whileInView", isIntersecting);
      }
      const { onViewportEnter, onViewportLeave } = this.node.getProps();
      const callback = isIntersecting ? onViewportEnter : onViewportLeave;
      callback && callback(entry2);
    };
    return observeIntersection(this.node.current, options, onIntersectionUpdate);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver === "undefined")
      return;
    const { props, prevProps } = this.node;
    const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps));
    if (hasOptionsChanged) {
      this.startObserver();
    }
  }
  unmount() {
  }
}
function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
  return (name) => viewport[name] !== prevViewport[name];
}
const gestureAnimations = {
  inView: {
    Feature: InViewFeature
  },
  tap: {
    Feature: PressGesture
  },
  focus: {
    Feature: FocusGesture
  },
  hover: {
    Feature: HoverGesture
  }
};
const layout = {
  layout: {
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};
const prefersReducedMotion = { current: null };
const hasReducedMotionListener = { current: false };
function initPrefersReducedMotion() {
  hasReducedMotionListener.current = true;
  if (!isBrowser)
    return;
  if (window.matchMedia) {
    const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
    const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
    motionMediaQuery.addListener(setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.current = false;
  }
}
const visualElementStore = /* @__PURE__ */ new WeakMap();
function updateMotionValuesFromProps(element, next, prev) {
  for (const key in next) {
    const nextValue = next[key];
    const prevValue = prev[key];
    if (isMotionValue(nextValue)) {
      element.addValue(key, nextValue);
    } else if (isMotionValue(prevValue)) {
      element.addValue(key, motionValue(nextValue, { owner: element }));
    } else if (prevValue !== nextValue) {
      if (element.hasValue(key)) {
        const existingValue = element.getValue(key);
        if (existingValue.liveStyle === true) {
          existingValue.jump(nextValue);
        } else if (!existingValue.hasAnimated) {
          existingValue.set(nextValue);
        }
      } else {
        const latestValue = element.getStaticValue(key);
        element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
      }
    }
  }
  for (const key in prev) {
    if (next[key] === void 0)
      element.removeValue(key);
  }
  return next;
}
const propEventHandlers = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class VisualElement {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
    return {};
  }
  constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState }, options = {}) {
    this.current = null;
    this.children = /* @__PURE__ */ new Set();
    this.isVariantNode = false;
    this.isControllingVariants = false;
    this.shouldReduceMotion = null;
    this.values = /* @__PURE__ */ new Map();
    this.KeyframeResolver = KeyframeResolver;
    this.features = {};
    this.valueSubscriptions = /* @__PURE__ */ new Map();
    this.prevMotionValues = {};
    this.events = {};
    this.propEventSubscriptions = {};
    this.notifyUpdate = () => this.notify("Update", this.latestValues);
    this.render = () => {
      if (!this.current)
        return;
      this.triggerBuild();
      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
    };
    this.renderScheduledAt = 0;
    this.scheduleRender = () => {
      const now2 = time.now();
      if (this.renderScheduledAt < now2) {
        this.renderScheduledAt = now2;
        frame.render(this.render, false, true);
      }
    };
    const { latestValues, renderState } = visualState;
    this.latestValues = latestValues;
    this.baseTarget = { ...latestValues };
    this.initialValues = props.initial ? { ...latestValues } : {};
    this.renderState = renderState;
    this.parent = parent;
    this.props = props;
    this.presenceContext = presenceContext;
    this.depth = parent ? parent.depth + 1 : 0;
    this.reducedMotionConfig = reducedMotionConfig;
    this.options = options;
    this.blockInitialAnimation = Boolean(blockInitialAnimation);
    this.isControllingVariants = isControllingVariants(props);
    this.isVariantNode = isVariantNode(props);
    if (this.isVariantNode) {
      this.variantChildren = /* @__PURE__ */ new Set();
    }
    this.manuallyAnimateOnMount = Boolean(parent && parent.current);
    const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);
    for (const key in initialMotionValues) {
      const value = initialMotionValues[key];
      if (latestValues[key] !== void 0 && isMotionValue(value)) {
        value.set(latestValues[key], false);
      }
    }
  }
  mount(instance) {
    this.current = instance;
    visualElementStore.set(instance, this);
    if (this.projection && !this.projection.instance) {
      this.projection.mount(instance);
    }
    if (this.parent && this.isVariantNode && !this.isControllingVariants) {
      this.removeFromVariantTree = this.parent.addVariantChild(this);
    }
    this.values.forEach((value, key) => this.bindToMotionValue(key, value));
    if (!hasReducedMotionListener.current) {
      initPrefersReducedMotion();
    }
    this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
    if (this.parent)
      this.parent.children.add(this);
    this.update(this.props, this.presenceContext);
  }
  unmount() {
    this.projection && this.projection.unmount();
    cancelFrame(this.notifyUpdate);
    cancelFrame(this.render);
    this.valueSubscriptions.forEach((remove) => remove());
    this.valueSubscriptions.clear();
    this.removeFromVariantTree && this.removeFromVariantTree();
    this.parent && this.parent.children.delete(this);
    for (const key in this.events) {
      this.events[key].clear();
    }
    for (const key in this.features) {
      const feature = this.features[key];
      if (feature) {
        feature.unmount();
        feature.isMounted = false;
      }
    }
    this.current = null;
  }
  bindToMotionValue(key, value) {
    if (this.valueSubscriptions.has(key)) {
      this.valueSubscriptions.get(key)();
    }
    const valueIsTransform = transformProps.has(key);
    if (valueIsTransform && this.onBindTransform) {
      this.onBindTransform();
    }
    const removeOnChange = value.on("change", (latestValue) => {
      this.latestValues[key] = latestValue;
      this.props.onUpdate && frame.preRender(this.notifyUpdate);
      if (valueIsTransform && this.projection) {
        this.projection.isTransformDirty = true;
      }
    });
    const removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
    let removeSyncCheck;
    if (window.MotionCheckAppearSync) {
      removeSyncCheck = window.MotionCheckAppearSync(this, key, value);
    }
    this.valueSubscriptions.set(key, () => {
      removeOnChange();
      removeOnRenderRequest();
      if (removeSyncCheck)
        removeSyncCheck();
      if (value.owner)
        value.stop();
    });
  }
  sortNodePosition(other) {
    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
      return 0;
    }
    return this.sortInstanceNodePosition(this.current, other.current);
  }
  updateFeatures() {
    let key = "animation";
    for (key in featureDefinitions) {
      const featureDefinition = featureDefinitions[key];
      if (!featureDefinition)
        continue;
      const { isEnabled, Feature: FeatureConstructor } = featureDefinition;
      if (!this.features[key] && FeatureConstructor && isEnabled(this.props)) {
        this.features[key] = new FeatureConstructor(this);
      }
      if (this.features[key]) {
        const feature = this.features[key];
        if (feature.isMounted) {
          feature.update();
        } else {
          feature.mount();
          feature.isMounted = true;
        }
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
  }
  getStaticValue(key) {
    return this.latestValues[key];
  }
  setStaticValue(key, value) {
    this.latestValues[key] = value;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(props, presenceContext) {
    if (props.transformTemplate || this.props.transformTemplate) {
      this.scheduleRender();
    }
    this.prevProps = this.props;
    this.props = props;
    this.prevPresenceContext = this.presenceContext;
    this.presenceContext = presenceContext;
    for (let i2 = 0; i2 < propEventHandlers.length; i2++) {
      const key = propEventHandlers[i2];
      if (this.propEventSubscriptions[key]) {
        this.propEventSubscriptions[key]();
        delete this.propEventSubscriptions[key];
      }
      const listenerName = "on" + key;
      const listener = props[listenerName];
      if (listener) {
        this.propEventSubscriptions[key] = this.on(key, listener);
      }
    }
    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);
    if (this.handleChildMotionValue) {
      this.handleChildMotionValue();
    }
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(name) {
    return this.props.variants ? this.props.variants[name] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(child) {
    const closestVariantNode = this.getClosestVariantNode();
    if (closestVariantNode) {
      closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
      return () => closestVariantNode.variantChildren.delete(child);
    }
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(key, value) {
    const existingValue = this.values.get(key);
    if (value !== existingValue) {
      if (existingValue)
        this.removeValue(key);
      this.bindToMotionValue(key, value);
      this.values.set(key, value);
      this.latestValues[key] = value.get();
    }
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(key) {
    this.values.delete(key);
    const unsubscribe = this.valueSubscriptions.get(key);
    if (unsubscribe) {
      unsubscribe();
      this.valueSubscriptions.delete(key);
    }
    delete this.latestValues[key];
    this.removeValueFromRenderState(key, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(key) {
    return this.values.has(key);
  }
  getValue(key, defaultValue2) {
    if (this.props.values && this.props.values[key]) {
      return this.props.values[key];
    }
    let value = this.values.get(key);
    if (value === void 0 && defaultValue2 !== void 0) {
      value = motionValue(defaultValue2 === null ? void 0 : defaultValue2, { owner: this });
      this.addValue(key, value);
    }
    return value;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(key, target) {
    let value = this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : this.getBaseTargetFromProps(this.props, key) ?? this.readValueFromInstance(this.current, key, this.options);
    if (value !== void 0 && value !== null) {
      if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
        value = parseFloat(value);
      } else if (!findValueType(value) && complex.test(target)) {
        value = getAnimatableNone(key, target);
      }
      this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);
    }
    return isMotionValue(value) ? value.get() : value;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(key, value) {
    this.baseTarget[key] = value;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(key) {
    const { initial } = this.props;
    let valueFromInitial;
    if (typeof initial === "string" || typeof initial === "object") {
      const variant = resolveVariantFromProps(this.props, initial, this.presenceContext?.custom);
      if (variant) {
        valueFromInitial = variant[key];
      }
    }
    if (initial && valueFromInitial !== void 0) {
      return valueFromInitial;
    }
    const target = this.getBaseTargetFromProps(this.props, key);
    if (target !== void 0 && !isMotionValue(target))
      return target;
    return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    return this.events[eventName].add(callback);
  }
  notify(eventName, ...args) {
    if (this.events[eventName]) {
      this.events[eventName].notify(...args);
    }
  }
}
class DOMVisualElement extends VisualElement {
  constructor() {
    super(...arguments);
    this.KeyframeResolver = DOMKeyframesResolver;
  }
  sortInstanceNodePosition(a2, b2) {
    return a2.compareDocumentPosition(b2) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(props, key) {
    return props.style ? props.style[key] : void 0;
  }
  removeValueFromRenderState(key, { vars, style }) {
    delete vars[key];
    delete style[key];
  }
  handleChildMotionValue() {
    if (this.childSubscription) {
      this.childSubscription();
      delete this.childSubscription;
    }
    const { children } = this.props;
    if (isMotionValue(children)) {
      this.childSubscription = children.on("change", (latest) => {
        if (this.current) {
          this.current.textContent = `${latest}`;
        }
      });
    }
  }
}
function renderHTML(element, { style, vars }, styleProp, projection) {
  Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
  for (const key in vars) {
    element.style.setProperty(key, vars[key]);
  }
}
function getComputedStyle$1(element) {
  return window.getComputedStyle(element);
}
class HTMLVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.type = "html";
    this.renderInstance = renderHTML;
  }
  readValueFromInstance(instance, key) {
    if (transformProps.has(key)) {
      return this.projection?.isProjecting ? defaultTransformValue(key) : readTransformValue(instance, key);
    } else {
      const computedStyle = getComputedStyle$1(instance);
      const value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
      return typeof value === "string" ? value.trim() : value;
    }
  }
  measureInstanceViewportBox(instance, { transformPagePoint }) {
    return measureViewportBox(instance, transformPagePoint);
  }
  build(renderState, latestValues, props) {
    buildHTMLStyles(renderState, latestValues, props.transformTemplate);
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
  }
}
const camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (const key in renderState.attrs) {
    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
  }
}
class SVGVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.type = "svg";
    this.isSVGTag = false;
    this.measureInstanceViewportBox = createBox;
  }
  getBaseTargetFromProps(props, key) {
    return props[key];
  }
  readValueFromInstance(instance, key) {
    if (transformProps.has(key)) {
      const defaultType = getDefaultValueType(key);
      return defaultType ? defaultType.default || 0 : 0;
    }
    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
    return instance.getAttribute(key);
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps(props, prevProps, visualElement);
  }
  build(renderState, latestValues, props) {
    buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate, props.style);
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderSVG(instance, renderState, styleProp, projection);
  }
  mount(instance) {
    this.isSVGTag = isSVGTag(instance.tagName);
    super.mount(instance);
  }
}
const createDomVisualElement = (Component, options) => {
  return isSVGComponent(Component) ? new SVGVisualElement(options) : new HTMLVisualElement(options, {
    allowProjection: Component !== reactExports.Fragment
  });
};
const createMotionComponent = /* @__PURE__ */ createMotionComponentFactory({
  ...animations,
  ...gestureAnimations,
  ...drag,
  ...layout
}, createDomVisualElement);
const motion = /* @__PURE__ */ createDOMMotionComponentProxy(createMotionComponent);
const PrivacyPolicyPage = () => {
  const {
    language
  } = useLanguage();
  const location2 = useLocation();
  reactExports.useEffect(() => {
    document.title = language === "pt-BR" ? "Política de Privacidade | MylineArts" : "Privacy Policy | MylineArts";
    window.scrollTo(0, 0);
  }, [language]);
  const getLanguagePrefix = () => {
    return location2.pathname.startsWith("/en") ? "/en" : "";
  };
  const privacyData = {
    "pt-BR": {
      title: "Política de privacidade",
      lastUpdated: "Última atualização: 12 de janeiro de 2025",
      backToHome: "Voltar para início",
      sections: [{
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Shield, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "1. Informações que coletamos",
        content: ["Coletamos informações que você nos fornece diretamente, como:", "• Endereço de e-mail quando você se cadastra ou entra em contato conosco", "• Imagens que você carrega para transformar em páginas para colorir", "• Informações de pagamento processadas por nossos parceiros seguros", "• Dados de uso da plataforma para melhorar nossos serviços"]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Eye, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "2. Como usamos suas informações",
        content: ["Utilizamos suas informações para:", "• Processar suas imagens usando nossa tecnologia de IA", "• Fornecer suporte ao cliente e responder suas dúvidas", "• Processar pagamentos e entregar seus produtos digitais", "• Melhorar nossos serviços e desenvolver novos recursos", "• Enviar comunicações importantes sobre sua conta (apenas quando necessário)"]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Lock, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "3. Proteção de dados",
        content: ["Levamos a segurança dos seus dados muito a sério:", "• Todas as imagens são processadas de forma segura e criptografada", "• Não armazenamos suas imagens por mais tempo do que necessário", "• Utilizamos protocolos de segurança padrão da indústria", "• Seus dados de pagamento são processados por parceiros certificados PCI DSS", "• Acesso aos dados é restrito apenas a funcionários autorizados"]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Users, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "4. Compartilhamento de informações",
        content: ["Não vendemos, alugamos ou compartilhamos suas informações pessoais com terceiros, exceto:", "• Quando necessário para processar pagamentos (através de parceiros seguros)", "• Para cumprir obrigações legais ou responder a solicitações governamentais", "• Para proteger nossos direitos, propriedade ou segurança", "• Com seu consentimento explícito"]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(FileText, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "5. Seus direitos (LGPD)",
        content: ["De acordo com a Lei Geral de Proteção de Dados (LGPD), você tem direito a:", "• Acessar seus dados pessoais que possuímos", "• Corrigir dados incompletos, inexatos ou desatualizados", "• Solicitar a exclusão de seus dados pessoais", "• Revogar seu consentimento a qualquer momento", "• Solicitar a portabilidade de seus dados", "• Obter informações sobre o uso compartilhado de seus dados"]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Mail, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "6. Contato",
        content: ["Para exercer seus direitos ou esclarecer dúvidas sobre esta política:", "• E-mail: legal@mylinearts.com", "• Responderemos sua solicitação em até 15 dias úteis", "• Para solicitações urgentes, entre em contato através do nosso suporte"]
      }],
      additionalInfo: {
        title: "Informações adicionais",
        content: ["Esta política pode ser atualizada periodicamente. Notificaremos sobre mudanças significativas.", "Ao usar nossos serviços, você concorda com esta política de privacidade.", "Esta política é regida pelas leis brasileiras e está em conformidade com a LGPD."]
      }
    },
    "en": {
      title: "Privacy policy",
      lastUpdated: "Last updated: January 12, 2025",
      backToHome: "Back to home",
      sections: [{
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Shield, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "1. Information we collect",
        content: ["We collect information you provide directly to us, such as:", "• Email address when you sign up or contact us", "• Images you upload to transform into coloring pages", "• Payment information processed by our secure partners", "• Platform usage data to improve our services"]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Eye, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "2. How we use your information",
        content: ["We use your information to:", "• Process your images using our AI technology", "• Provide customer support and answer your questions", "• Process payments and deliver your digital products", "• Improve our services and develop new features", "• Send important communications about your account (only when necessary)"]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Lock, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "3. Data protection",
        content: ["We take the security of your data very seriously:", "• All images are processed securely and encrypted", "• We do not store your images longer than necessary", "• We use industry-standard security protocols", "• Your payment data is processed by PCI DSS certified partners", "• Data access is restricted to authorized employees only"]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Users, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "4. Information sharing",
        content: ["We do not sell, rent, or share your personal information with third parties, except:", "• When necessary to process payments (through secure partners)", "• To comply with legal obligations or respond to government requests", "• To protect our rights, property, or safety", "• With your explicit consent"]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(FileText, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "5. Your rights (GDPR)",
        content: ["In accordance with GDPR, you have the right to:", "• Access your personal data that we hold", "• Correct incomplete, inaccurate, or outdated data", "• Request deletion of your personal data", "• Revoke your consent at any time", "• Request portability of your data", "• Obtain information about shared use of your data"]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Mail, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "6. Contact",
        content: ["To exercise your rights or clarify questions about this policy:", "• Email: legal@mylinearts.com", "• We will respond to your request within 15 business days", "• For urgent requests, contact us through our support"]
      }],
      additionalInfo: {
        title: "Additional information",
        content: ["This policy may be updated periodically. We will notify about significant changes.", "By using our services, you agree to this privacy policy.", "This policy is governed by applicable laws and complies with GDPR."]
      }
    }
  };
  const currentData = privacyData[language] || privacyData["pt-BR"];
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
    className: "min-h-screen bg-gray-50 py-12",
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      className: "container mx-auto px-4 sm:px-6 lg:px-8",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(motion.div, {
        initial: {
          opacity: 0,
          y: 20
        },
        animate: {
          opacity: 1,
          y: 0
        },
        className: "max-w-4xl mx-auto",
        children: [/* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
          className: "mb-8",
          children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(Link, {
            to: getLanguagePrefix() || "/",
            className: "inline-flex items-center text-primary-600 hover:text-primary-700 mb-6 transition-colors",
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ArrowLeft, {
              className: "h-5 w-5 mr-2"
            }), currentData.backToHome]
          }), /* @__PURE__ */ jsxRuntimeExports.jsxs(motion.div, {
            initial: {
              opacity: 0,
              y: -20
            },
            animate: {
              opacity: 1,
              y: 0
            },
            transition: {
              delay: 0.2
            },
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h1", {
              className: "text-4xl md:text-5xl font-bold text-gray-900 mb-4",
              children: currentData.title
            }), /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
              className: "text-gray-600 text-lg",
              children: currentData.lastUpdated
            })]
          })]
        }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
          className: "bg-white rounded-2xl shadow-md overflow-hidden",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
            className: "p-8 md:p-12",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
              className: "space-y-12",
              children: [currentData.sections.map((section, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(motion.div, {
                initial: {
                  opacity: 0,
                  y: 30
                },
                animate: {
                  opacity: 1,
                  y: 0
                },
                transition: {
                  delay: 0.3 + index * 0.1
                },
                className: "border-b border-gray-100 last:border-b-0 pb-8 last:pb-0",
                children: [/* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                  className: "flex items-start mb-6",
                  children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                    className: "shrink-0 p-3 bg-primary-50 rounded-lg mr-4",
                    children: section.icon
                  }), /* @__PURE__ */ jsxRuntimeExports.jsx("h2", {
                    className: "text-2xl font-bold text-gray-900 mt-2",
                    children: section.title
                  })]
                }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                  className: "ml-16 space-y-3",
                  children: section.content.map((paragraph, pIndex) => /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
                    className: "text-gray-700 leading-relaxed",
                    children: paragraph
                  }, pIndex))
                })]
              }, index)), /* @__PURE__ */ jsxRuntimeExports.jsxs(motion.div, {
                initial: {
                  opacity: 0,
                  y: 30
                },
                animate: {
                  opacity: 1,
                  y: 0
                },
                transition: {
                  delay: 0.8
                },
                className: "bg-primary-50 rounded-xl p-8",
                children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h3", {
                  className: "text-xl font-bold text-gray-900 mb-4",
                  children: currentData.additionalInfo.title
                }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                  className: "space-y-3",
                  children: currentData.additionalInfo.content.map((item, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
                    className: "text-gray-700",
                    children: item
                  }, index))
                })]
              })]
            })
          })
        }), /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, {
          initial: {
            opacity: 0,
            y: 20
          },
          animate: {
            opacity: 1,
            y: 0
          },
          transition: {
            delay: 1
          },
          className: "text-center mt-12",
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
            className: "bg-white rounded-xl shadow-md p-8",
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h3", {
              className: "text-xl font-bold text-gray-900 mb-4",
              children: language === "pt-BR" ? "Tem dúvidas sobre nossa política de privacidade?" : "Questions about our privacy policy?"
            }), /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
              className: "text-gray-600 mb-6",
              children: language === "pt-BR" ? "Entre em contato conosco e teremos prazer em esclarecer qualquer dúvida." : "Contact us and we'll be happy to clarify any questions."
            }), /* @__PURE__ */ jsxRuntimeExports.jsxs("a", {
              href: "mailto:legal@mylinearts.com",
              className: "btn btn-primary inline-flex items-center",
              children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Mail, {
                className: "h-5 w-5 mr-2"
              }), language === "pt-BR" ? "Entrar em contato" : "Contact us"]
            })]
          })
        })]
      })
    })
  });
};
const PrivacyPolicyPage$1 = withComponentProps(PrivacyPolicyPage);
const route11 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: PrivacyPolicyPage$1
}, Symbol.toStringTag, { value: "Module" }));
const TermsOfServicePage = () => {
  const {
    language
  } = useLanguage();
  const location2 = useLocation();
  reactExports.useEffect(() => {
    document.title = language === "pt-BR" ? "Termos de Serviço | MylineArts" : "Terms of Service | MylineArts";
    window.scrollTo(0, 0);
  }, [language]);
  const getLanguagePrefix = () => {
    return location2.pathname.startsWith("/en") ? "/en" : "";
  };
  const termsData = {
    "pt-BR": {
      title: "Termos de serviço",
      lastUpdated: "Última atualização: 12 de janeiro de 2025",
      backToHome: "Voltar para início",
      sections: [{
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(FileText, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "1. Aceitação dos termos",
        content: ["Ao acessar e usar o MylineArts, você concorda em cumprir estes Termos de Serviço.", "Se você não concordar com qualquer parte destes termos, não deve usar nossos serviços.", "Reservamo-nos o direito de modificar estes termos a qualquer momento.", "O uso continuado após as modificações constitui aceitação dos novos termos."]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Users, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "2. Descrição do serviço",
        content: ["O MylineArts é uma plataforma que utiliza inteligência artificial para transformar fotos em páginas para colorir.", "Oferecemos diferentes planos de créditos para uso da plataforma.", "Cada crédito permite a transformação de uma imagem.", "Os resultados são fornecidos em formato digital de alta qualidade.", "Não garantimos resultados específicos, pois dependem da qualidade da imagem original."]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CreditCard, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "3. Pagamentos e reembolsos",
        content: ["Os pagamentos são processados através de parceiros seguros e certificados.", "Os créditos são válidos por 12 meses a partir da data de compra.", "Não oferecemos reembolsos, exceto em casos de falha técnica comprovada.", "Em caso de problemas técnicos, oferecemos créditos adicionais como compensação.", "Todos os preços estão sujeitos a alterações sem aviso prévio."]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Shield, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "4. Uso aceitável",
        content: ["Você deve usar o serviço apenas para fins legais e apropriados.", "É proibido carregar imagens que violem direitos autorais de terceiros.", "Não é permitido carregar conteúdo ofensivo, ilegal ou inadequado.", "Você é responsável por garantir que possui os direitos das imagens carregadas.", "Reservamo-nos o direito de remover conteúdo inadequado e suspender contas."]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(AlertTriangle, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "5. Limitações de responsabilidade",
        content: ['O serviço é fornecido "como está" sem garantias de qualquer tipo.', "Não nos responsabilizamos por danos diretos ou indiretos decorrentes do uso.", "Nossa responsabilidade máxima é limitada ao valor pago pelos serviços.", "Não garantimos disponibilidade ininterrupta do serviço.", "Você usa o serviço por sua própria conta e risco."]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Mail, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "6. Contato e suporte",
        content: ["Para dúvidas sobre estes termos, entre em contato:", "• E-mail: legal@mylinearts.com", "• Tempo de resposta: até 48 horas úteis", "• Para questões urgentes, use o chat de suporte na plataforma"]
      }],
      additionalInfo: {
        title: "Disposições gerais",
        content: ["Estes termos são regidos pelas leis brasileiras.", "Qualquer disputa será resolvida no foro da comarca de São Paulo/SP.", "Se alguma cláusula for considerada inválida, as demais permanecem em vigor.", "Estes termos constituem o acordo completo entre você e o MylineArts."]
      }
    },
    "en": {
      title: "Terms of service",
      lastUpdated: "Last updated: January 12, 2025",
      backToHome: "Back to home",
      sections: [{
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(FileText, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "1. Acceptance of terms",
        content: ["By accessing and using MylineArts, you agree to comply with these Terms of Service.", "If you do not agree with any part of these terms, you should not use our services.", "We reserve the right to modify these terms at any time.", "Continued use after modifications constitutes acceptance of the new terms."]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Users, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "2. Service description",
        content: ["MylineArts is a platform that uses artificial intelligence to transform photos into coloring pages.", "We offer different credit plans for platform usage.", "Each credit allows the transformation of one image.", "Results are provided in high-quality digital format.", "We do not guarantee specific results as they depend on the original image quality."]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CreditCard, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "3. Payments and refunds",
        content: ["Payments are processed through secure and certified partners.", "Credits are valid for 12 months from the purchase date.", "We do not offer refunds except in cases of proven technical failure.", "In case of technical problems, we offer additional credits as compensation.", "All prices are subject to change without prior notice."]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Shield, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "4. Acceptable use",
        content: ["You must use the service only for legal and appropriate purposes.", "It is prohibited to upload images that violate third-party copyrights.", "Uploading offensive, illegal, or inappropriate content is not allowed.", "You are responsible for ensuring you have the rights to uploaded images.", "We reserve the right to remove inappropriate content and suspend accounts."]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(AlertTriangle, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "5. Liability limitations",
        content: ['The service is provided "as is" without warranties of any kind.', "We are not responsible for direct or indirect damages arising from use.", "Our maximum liability is limited to the amount paid for services.", "We do not guarantee uninterrupted service availability.", "You use the service at your own risk."]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Mail, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "6. Contact and support",
        content: ["For questions about these terms, contact us:", "• Email: legal@mylinearts.com", "• Response time: up to 48 business hours", "• For urgent matters, use the support chat on the platform"]
      }],
      additionalInfo: {
        title: "General provisions",
        content: ["These terms are governed by applicable laws.", "Any disputes will be resolved in the appropriate jurisdiction.", "If any clause is deemed invalid, the others remain in effect.", "These terms constitute the complete agreement between you and MylineArts."]
      }
    }
  };
  const currentData = termsData[language] || termsData["pt-BR"];
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
    className: "min-h-screen bg-gray-50 py-12",
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      className: "container mx-auto px-4 sm:px-6 lg:px-8",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(motion.div, {
        initial: {
          opacity: 0,
          y: 20
        },
        animate: {
          opacity: 1,
          y: 0
        },
        className: "max-w-4xl mx-auto",
        children: [/* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
          className: "mb-8",
          children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(Link, {
            to: getLanguagePrefix() || "/",
            className: "inline-flex items-center text-primary-600 hover:text-primary-700 mb-6 transition-colors",
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ArrowLeft, {
              className: "h-5 w-5 mr-2"
            }), currentData.backToHome]
          }), /* @__PURE__ */ jsxRuntimeExports.jsxs(motion.div, {
            initial: {
              opacity: 0,
              y: -20
            },
            animate: {
              opacity: 1,
              y: 0
            },
            transition: {
              delay: 0.2
            },
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h1", {
              className: "text-4xl md:text-5xl font-bold text-gray-900 mb-4",
              children: currentData.title
            }), /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
              className: "text-gray-600 text-lg",
              children: currentData.lastUpdated
            })]
          })]
        }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
          className: "bg-white rounded-2xl shadow-md overflow-hidden",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
            className: "p-8 md:p-12",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
              className: "space-y-12",
              children: [currentData.sections.map((section, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(motion.div, {
                initial: {
                  opacity: 0,
                  y: 30
                },
                animate: {
                  opacity: 1,
                  y: 0
                },
                transition: {
                  delay: 0.3 + index * 0.1
                },
                className: "border-b border-gray-100 last:border-b-0 pb-8 last:pb-0",
                children: [/* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                  className: "flex items-start mb-6",
                  children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                    className: "shrink-0 p-3 bg-primary-50 rounded-lg mr-4",
                    children: section.icon
                  }), /* @__PURE__ */ jsxRuntimeExports.jsx("h2", {
                    className: "text-2xl font-bold text-gray-900 mt-2",
                    children: section.title
                  })]
                }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                  className: "ml-16 space-y-3",
                  children: section.content.map((paragraph, pIndex) => /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
                    className: "text-gray-700 leading-relaxed",
                    children: paragraph
                  }, pIndex))
                })]
              }, index)), /* @__PURE__ */ jsxRuntimeExports.jsxs(motion.div, {
                initial: {
                  opacity: 0,
                  y: 30
                },
                animate: {
                  opacity: 1,
                  y: 0
                },
                transition: {
                  delay: 0.8
                },
                className: "bg-primary-50 rounded-xl p-8",
                children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h3", {
                  className: "text-xl font-bold text-gray-900 mb-4",
                  children: currentData.additionalInfo.title
                }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                  className: "space-y-3",
                  children: currentData.additionalInfo.content.map((item, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
                    className: "text-gray-700",
                    children: item
                  }, index))
                })]
              })]
            })
          })
        }), /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, {
          initial: {
            opacity: 0,
            y: 20
          },
          animate: {
            opacity: 1,
            y: 0
          },
          transition: {
            delay: 1
          },
          className: "text-center mt-12",
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
            className: "bg-white rounded-xl shadow-md p-8",
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h3", {
              className: "text-xl font-bold text-gray-900 mb-4",
              children: language === "pt-BR" ? "Tem dúvidas sobre nossos termos de serviço?" : "Questions about our terms of service?"
            }), /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
              className: "text-gray-600 mb-6",
              children: language === "pt-BR" ? "Nossa equipe está pronta para esclarecer qualquer dúvida sobre nossos termos." : "Our team is ready to clarify any questions about our terms."
            }), /* @__PURE__ */ jsxRuntimeExports.jsxs("a", {
              href: "mailto:legal@mylinearts.com",
              className: "btn btn-primary inline-flex items-center",
              children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Mail, {
                className: "h-5 w-5 mr-2"
              }), language === "pt-BR" ? "Entrar em contato" : "Contact us"]
            })]
          })
        })]
      })
    })
  });
};
const TermsOfServicePage$1 = withComponentProps(TermsOfServicePage);
const route12 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: TermsOfServicePage$1
}, Symbol.toStringTag, { value: "Module" }));
const CookiePolicyPage = () => {
  const {
    language
  } = useLanguage();
  const location2 = useLocation();
  reactExports.useEffect(() => {
    document.title = language === "pt-BR" ? "Política de Cookies | MylineArts" : "Cookie Policy | MylineArts";
    window.scrollTo(0, 0);
  }, [language]);
  const getLanguagePrefix = () => {
    return location2.pathname.startsWith("/en") ? "/en" : "";
  };
  const cookieData = {
    "pt-BR": {
      title: "Política de cookies",
      lastUpdated: "Última atualização: 12 de janeiro de 2025",
      backToHome: "Voltar para início",
      sections: [{
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Cookie, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "1. O que são cookies",
        content: ["Cookies são pequenos arquivos de texto armazenados no seu dispositivo quando você visita nosso site.", "Eles nos ajudam a melhorar sua experiência, lembrar suas preferências e analisar como você usa nossos serviços.", "Os cookies não contêm informações pessoais identificáveis por si só.", "Você pode controlar e gerenciar cookies através das configurações do seu navegador."]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Settings$1, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "2. Tipos de cookies que usamos",
        content: ["Cookies essenciais: Necessários para o funcionamento básico do site", "• Autenticação de usuário e segurança", "• Carrinho de compras e processamento de pagamentos", "• Preferências de idioma e configurações", "", "Cookies de funcionalidade: Melhoram sua experiência", "• Lembrar suas preferências de uso", "• Personalizar conteúdo baseado em suas escolhas", "• Facilitar navegação e usabilidade"]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(BarChart3, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "3. Cookies de análise",
        content: ["Utilizamos cookies de análise para entender como nosso site é usado:", "• Google Analytics para estatísticas de uso anônimas", "• Métricas de performance e velocidade do site", "• Análise de comportamento de navegação (dados agregados)", "• Identificação de páginas mais populares e problemas técnicos", "", "Estes dados nos ajudam a melhorar continuamente nossos serviços."]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Shield, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "4. Cookies de terceiros",
        content: ["Alguns cookies são definidos por serviços de terceiros que usamos:", "• Processadores de pagamento (Stripe, PayPal) para transações seguras", "• Serviços de análise (Google Analytics) para métricas do site", "• Redes sociais (quando você compartilha conteúdo)", "", "Estes terceiros têm suas próprias políticas de privacidade e cookies.", "Recomendamos que você revise suas políticas para entender como eles usam cookies."]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Users, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "5. Gerenciamento de cookies",
        content: ["Você tem controle total sobre os cookies:", "", "Configurações do navegador:", "• Bloquear todos os cookies", "• Aceitar apenas cookies de sites específicos", "• Deletar cookies existentes", "• Receber notificações antes de aceitar cookies", "", "Importante: Desabilitar cookies pode afetar a funcionalidade do site.", "Alguns recursos podem não funcionar corretamente sem cookies essenciais."]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Mail, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "6. Contato",
        content: ["Para dúvidas sobre nossa política de cookies:", "• E-mail: legal@mylinearts.com", "• Responderemos em até 48 horas úteis", "• Para ajuda com configurações de cookies, consulte a ajuda do seu navegador"]
      }],
      additionalInfo: {
        title: "Informações importantes",
        content: ["Esta política pode ser atualizada para refletir mudanças em nossos serviços.", "Notificaremos sobre mudanças significativas através do site.", "O uso continuado do site após mudanças constitui aceitação da nova política.", "Para mais informações sobre privacidade, consulte nossa Política de Privacidade."]
      }
    },
    "en": {
      title: "Cookie policy",
      lastUpdated: "Last updated: January 12, 2025",
      backToHome: "Back to home",
      sections: [{
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Cookie, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "1. What are cookies",
        content: ["Cookies are small text files stored on your device when you visit our website.", "They help us improve your experience, remember your preferences, and analyze how you use our services.", "Cookies do not contain personally identifiable information by themselves.", "You can control and manage cookies through your browser settings."]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Settings$1, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "2. Types of cookies we use",
        content: ["Essential cookies: Necessary for basic website functionality", "• User authentication and security", "• Shopping cart and payment processing", "• Language preferences and settings", "", "Functionality cookies: Enhance your experience", "• Remember your usage preferences", "• Personalize content based on your choices", "• Facilitate navigation and usability"]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(BarChart3, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "3. Analytics cookies",
        content: ["We use analytics cookies to understand how our website is used:", "• Google Analytics for anonymous usage statistics", "• Site performance and speed metrics", "• Navigation behavior analysis (aggregated data)", "• Identification of popular pages and technical issues", "", "This data helps us continuously improve our services."]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Shield, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "4. Third-party cookies",
        content: ["Some cookies are set by third-party services we use:", "• Payment processors (Stripe, PayPal) for secure transactions", "• Analytics services (Google Analytics) for site metrics", "• Social networks (when you share content)", "", "These third parties have their own privacy and cookie policies.", "We recommend reviewing their policies to understand how they use cookies."]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Users, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "5. Cookie management",
        content: ["You have full control over cookies:", "", "Browser settings:", "• Block all cookies", "• Accept only cookies from specific sites", "• Delete existing cookies", "• Receive notifications before accepting cookies", "", "Important: Disabling cookies may affect website functionality.", "Some features may not work properly without essential cookies."]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Mail, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "6. Contact",
        content: ["For questions about our cookie policy:", "• Email: legal@mylinearts.com", "• We will respond within 48 business hours", "• For help with cookie settings, consult your browser's help section"]
      }],
      additionalInfo: {
        title: "Important information",
        content: ["This policy may be updated to reflect changes in our services.", "We will notify about significant changes through the website.", "Continued use of the site after changes constitutes acceptance of the new policy.", "For more privacy information, see our Privacy Policy."]
      }
    }
  };
  const currentData = cookieData[language] || cookieData["pt-BR"];
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
    className: "min-h-screen bg-gray-50 py-12",
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      className: "container mx-auto px-4 sm:px-6 lg:px-8",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(motion.div, {
        initial: {
          opacity: 0,
          y: 20
        },
        animate: {
          opacity: 1,
          y: 0
        },
        className: "max-w-4xl mx-auto",
        children: [/* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
          className: "mb-8",
          children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(Link, {
            to: getLanguagePrefix() || "/",
            className: "inline-flex items-center text-primary-600 hover:text-primary-700 mb-6 transition-colors",
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ArrowLeft, {
              className: "h-5 w-5 mr-2"
            }), currentData.backToHome]
          }), /* @__PURE__ */ jsxRuntimeExports.jsxs(motion.div, {
            initial: {
              opacity: 0,
              y: -20
            },
            animate: {
              opacity: 1,
              y: 0
            },
            transition: {
              delay: 0.2
            },
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h1", {
              className: "text-4xl md:text-5xl font-bold text-gray-900 mb-4",
              children: currentData.title
            }), /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
              className: "text-gray-600 text-lg",
              children: currentData.lastUpdated
            })]
          })]
        }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
          className: "bg-white rounded-2xl shadow-md overflow-hidden",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
            className: "p-8 md:p-12",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
              className: "space-y-12",
              children: [currentData.sections.map((section, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(motion.div, {
                initial: {
                  opacity: 0,
                  y: 30
                },
                animate: {
                  opacity: 1,
                  y: 0
                },
                transition: {
                  delay: 0.3 + index * 0.1
                },
                className: "border-b border-gray-100 last:border-b-0 pb-8 last:pb-0",
                children: [/* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                  className: "flex items-start mb-6",
                  children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                    className: "shrink-0 p-3 bg-primary-50 rounded-lg mr-4",
                    children: section.icon
                  }), /* @__PURE__ */ jsxRuntimeExports.jsx("h2", {
                    className: "text-2xl font-bold text-gray-900 mt-2",
                    children: section.title
                  })]
                }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                  className: "ml-16 space-y-3",
                  children: section.content.map((paragraph, pIndex) => /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
                    className: "text-gray-700 leading-relaxed",
                    children: paragraph
                  }, pIndex))
                })]
              }, index)), /* @__PURE__ */ jsxRuntimeExports.jsxs(motion.div, {
                initial: {
                  opacity: 0,
                  y: 30
                },
                animate: {
                  opacity: 1,
                  y: 0
                },
                transition: {
                  delay: 0.8
                },
                className: "bg-primary-50 rounded-xl p-8",
                children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h3", {
                  className: "text-xl font-bold text-gray-900 mb-4",
                  children: currentData.additionalInfo.title
                }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                  className: "space-y-3",
                  children: currentData.additionalInfo.content.map((item, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
                    className: "text-gray-700",
                    children: item
                  }, index))
                })]
              })]
            })
          })
        }), /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, {
          initial: {
            opacity: 0,
            y: 20
          },
          animate: {
            opacity: 1,
            y: 0
          },
          transition: {
            delay: 1
          },
          className: "text-center mt-12",
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
            className: "bg-white rounded-xl shadow-md p-8",
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h3", {
              className: "text-xl font-bold text-gray-900 mb-4",
              children: language === "pt-BR" ? "Precisa de ajuda com configurações de cookies?" : "Need help with cookie settings?"
            }), /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
              className: "text-gray-600 mb-6",
              children: language === "pt-BR" ? "Nossa equipe pode ajudar você a configurar seus cookies da melhor forma." : "Our team can help you configure your cookies in the best way."
            }), /* @__PURE__ */ jsxRuntimeExports.jsxs("a", {
              href: "mailto:legal@mylinearts.com",
              className: "btn btn-primary inline-flex items-center",
              children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Mail, {
                className: "h-5 w-5 mr-2"
              }), language === "pt-BR" ? "Entrar em contato" : "Contact us"]
            })]
          })
        })]
      })
    })
  });
};
const CookiePolicyPage$1 = withComponentProps(CookiePolicyPage);
const route13 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: CookiePolicyPage$1
}, Symbol.toStringTag, { value: "Module" }));
const LGPDPage = () => {
  const {
    language
  } = useLanguage();
  const location2 = useLocation();
  reactExports.useEffect(() => {
    document.title = language === "pt-BR" ? "LGPD - Lei Geral de Proteção de Dados | MylineArts" : "GDPR - General Data Protection Regulation | MylineArts";
    window.scrollTo(0, 0);
  }, [language]);
  const getLanguagePrefix = () => {
    return location2.pathname.startsWith("/en") ? "/en" : "";
  };
  const lgpdData = {
    "pt-BR": {
      title: "LGPD - Lei Geral de Proteção de Dados",
      lastUpdated: "Última atualização: 12 de janeiro de 2025",
      backToHome: "Voltar para início",
      intro: "O MylineArts está comprometido com a proteção dos seus dados pessoais e em total conformidade com a Lei Geral de Proteção de Dados (LGPD - Lei 13.709/2018).",
      sections: [{
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Scale, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "1. Nosso compromisso com a LGPD",
        content: ["Implementamos todas as medidas necessárias para garantir conformidade total com a LGPD.", "Nossos processos de coleta, tratamento e armazenamento de dados seguem os princípios da lei.", "Mantemos registros detalhados de todas as atividades de tratamento de dados.", "Nossa equipe é treinada regularmente sobre proteção de dados e privacidade.", "Realizamos auditorias periódicas para garantir conformidade contínua."]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UserCheck, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "2. Seus direitos como titular de dados",
        content: ["Conforme a LGPD, você tem os seguintes direitos:", "", "• Confirmação da existência de tratamento dos seus dados", "• Acesso aos seus dados pessoais que possuímos", "• Correção de dados incompletos, inexatos ou desatualizados", "• Anonimização, bloqueio ou eliminação de dados desnecessários", "• Portabilidade dos dados para outro fornecedor", "• Eliminação dos dados tratados com seu consentimento", "• Informações sobre compartilhamento de dados", "• Revogação do consentimento a qualquer momento"]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(FileText, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "3. Base legal para tratamento",
        content: ["Tratamos seus dados pessoais com base nas seguintes hipóteses legais:", "", "Consentimento: Para envio de comunicações promocionais (quando aplicável)", "Execução de contrato: Para prestação dos nossos serviços", "Legítimo interesse: Para melhorias do serviço e segurança", "Cumprimento de obrigação legal: Para atender exigências fiscais e regulatórias", "", "Sempre informamos claramente qual base legal utilizamos para cada tratamento."]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Shield, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "4. Medidas de segurança",
        content: ["Implementamos medidas técnicas e organizacionais robustas:", "", "Segurança técnica:", "• Criptografia de dados em trânsito e em repouso", "• Controles de acesso baseados em funções", "• Monitoramento contínuo de segurança", "• Backups seguros e planos de recuperação", "", "Segurança organizacional:", "• Políticas internas de proteção de dados", "• Treinamento regular da equipe", "• Contratos de confidencialidade", "• Procedimentos de resposta a incidentes"]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Eye, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "5. Transparência e accountability",
        content: ["Mantemos total transparência sobre nosso tratamento de dados:", "", "• Documentamos todas as atividades de tratamento", "• Realizamos avaliações de impacto quando necessário", "• Mantemos registros de consentimentos e revogações", "• Publicamos relatórios de transparência periodicamente", "• Cooperamos com autoridades de proteção de dados", "", "Nosso Encarregado de Dados (DPO) supervisiona todas as atividades de proteção de dados."]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Mail, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "6. Como exercer seus direitos",
        content: ["Para exercer qualquer dos seus direitos sob a LGPD:", "", "• E-mail: legal@mylinearts.com", '• Assunto: "Solicitação LGPD - [seu direito]"', "• Prazo de resposta: até 15 dias úteis", "• Documentação: pode ser necessária para verificação de identidade", "", "Não cobramos taxas para atender solicitações relacionadas aos seus direitos.", "Em casos complexos, o prazo pode ser estendido por mais 15 dias."]
      }],
      additionalInfo: {
        title: "Informações adicionais",
        content: ["Em caso de violação de dados, notificaremos a ANPD e os titulares conforme exigido pela lei.", "Mantemos contratos de proteção de dados com todos os nossos fornecedores.", "Realizamos transferências internacionais apenas para países com nível adequado de proteção.", "Esta página é atualizada sempre que há mudanças em nossos processos de proteção de dados."]
      }
    },
    "en": {
      title: "GDPR - General Data Protection Regulation",
      lastUpdated: "Last updated: January 12, 2025",
      backToHome: "Back to home",
      intro: "MylineArts is committed to protecting your personal data and in full compliance with the General Data Protection Regulation (GDPR).",
      sections: [{
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Scale, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "1. Our commitment to GDPR",
        content: ["We have implemented all necessary measures to ensure full GDPR compliance.", "Our data collection, processing, and storage processes follow the principles of the law.", "We maintain detailed records of all data processing activities.", "Our team is regularly trained on data protection and privacy.", "We conduct periodic audits to ensure continuous compliance."]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(UserCheck, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "2. Your rights as a data subject",
        content: ["Under GDPR, you have the following rights:", "", "• Confirmation of the existence of processing of your data", "• Access to your personal data that we hold", "• Correction of incomplete, inaccurate, or outdated data", "• Anonymization, blocking, or deletion of unnecessary data", "• Data portability to another provider", "• Deletion of data processed with your consent", "• Information about data sharing", "• Withdrawal of consent at any time"]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(FileText, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "3. Legal basis for processing",
        content: ["We process your personal data based on the following legal grounds:", "", "Consent: For sending promotional communications (when applicable)", "Contract performance: For providing our services", "Legitimate interest: For service improvements and security", "Legal obligation: To meet tax and regulatory requirements", "", "We always clearly inform which legal basis we use for each processing."]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Shield, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "4. Security measures",
        content: ["We implement robust technical and organizational measures:", "", "Technical security:", "• Data encryption in transit and at rest", "• Role-based access controls", "• Continuous security monitoring", "• Secure backups and recovery plans", "", "Organizational security:", "• Internal data protection policies", "• Regular team training", "• Confidentiality agreements", "• Incident response procedures"]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Eye, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "5. Transparency and accountability",
        content: ["We maintain full transparency about our data processing:", "", "• We document all processing activities", "• We conduct impact assessments when necessary", "• We maintain records of consents and withdrawals", "• We publish transparency reports periodically", "• We cooperate with data protection authorities", "", "Our Data Protection Officer (DPO) oversees all data protection activities."]
      }, {
        icon: /* @__PURE__ */ jsxRuntimeExports.jsx(Mail, {
          className: "w-6 h-6 text-primary-500"
        }),
        title: "6. How to exercise your rights",
        content: ["To exercise any of your rights under GDPR:", "", "• Email: legal@mylinearts.com", '• Subject: "GDPR Request - [your right]"', "• Response time: up to 30 days", "• Documentation: may be required for identity verification", "", "We do not charge fees for handling requests related to your rights.", "In complex cases, the deadline may be extended by another 30 days."]
      }],
      additionalInfo: {
        title: "Additional information",
        content: ["In case of data breach, we will notify authorities and data subjects as required by law.", "We maintain data protection agreements with all our suppliers.", "We conduct international transfers only to countries with adequate level of protection.", "This page is updated whenever there are changes in our data protection processes."]
      }
    }
  };
  const currentData = lgpdData[language] || lgpdData["pt-BR"];
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
    className: "min-h-screen bg-gray-50 py-12",
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      className: "container mx-auto px-4 sm:px-6 lg:px-8",
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(motion.div, {
        initial: {
          opacity: 0,
          y: 20
        },
        animate: {
          opacity: 1,
          y: 0
        },
        className: "max-w-4xl mx-auto",
        children: [/* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
          className: "mb-8",
          children: [/* @__PURE__ */ jsxRuntimeExports.jsxs(Link, {
            to: getLanguagePrefix() || "/",
            className: "inline-flex items-center text-primary-600 hover:text-primary-700 mb-6 transition-colors",
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx(ArrowLeft, {
              className: "h-5 w-5 mr-2"
            }), currentData.backToHome]
          }), /* @__PURE__ */ jsxRuntimeExports.jsxs(motion.div, {
            initial: {
              opacity: 0,
              y: -20
            },
            animate: {
              opacity: 1,
              y: 0
            },
            transition: {
              delay: 0.2
            },
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h1", {
              className: "text-4xl md:text-5xl font-bold text-gray-900 mb-4",
              children: currentData.title
            }), /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
              className: "text-gray-600 text-lg mb-6",
              children: currentData.lastUpdated
            }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
              className: "bg-primary-50 border-l-4 border-primary-500 p-6 rounded-r-lg",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
                className: "text-gray-700 leading-relaxed",
                children: currentData.intro
              })
            })]
          })]
        }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
          className: "bg-white rounded-2xl shadow-md overflow-hidden",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
            className: "p-8 md:p-12",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
              className: "space-y-12",
              children: [currentData.sections.map((section, index) => /* @__PURE__ */ jsxRuntimeExports.jsxs(motion.div, {
                initial: {
                  opacity: 0,
                  y: 30
                },
                animate: {
                  opacity: 1,
                  y: 0
                },
                transition: {
                  delay: 0.3 + index * 0.1
                },
                className: "border-b border-gray-100 last:border-b-0 pb-8 last:pb-0",
                children: [/* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                  className: "flex items-start mb-6",
                  children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                    className: "shrink-0 p-3 bg-primary-50 rounded-lg mr-4",
                    children: section.icon
                  }), /* @__PURE__ */ jsxRuntimeExports.jsx("h2", {
                    className: "text-2xl font-bold text-gray-900 mt-2",
                    children: section.title
                  })]
                }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                  className: "ml-16 space-y-3",
                  children: section.content.map((paragraph, pIndex) => /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
                    className: "text-gray-700 leading-relaxed",
                    children: paragraph
                  }, pIndex))
                })]
              }, index)), /* @__PURE__ */ jsxRuntimeExports.jsxs(motion.div, {
                initial: {
                  opacity: 0,
                  y: 30
                },
                animate: {
                  opacity: 1,
                  y: 0
                },
                transition: {
                  delay: 0.8
                },
                className: "bg-primary-50 rounded-xl p-8",
                children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h3", {
                  className: "text-xl font-bold text-gray-900 mb-4",
                  children: currentData.additionalInfo.title
                }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                  className: "space-y-3",
                  children: currentData.additionalInfo.content.map((item, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
                    className: "text-gray-700",
                    children: item
                  }, index))
                })]
              })]
            })
          })
        }), /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, {
          initial: {
            opacity: 0,
            y: 20
          },
          animate: {
            opacity: 1,
            y: 0
          },
          transition: {
            delay: 1
          },
          className: "text-center mt-12",
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
            className: "bg-white rounded-xl shadow-md p-8",
            children: [/* @__PURE__ */ jsxRuntimeExports.jsx("h3", {
              className: "text-xl font-bold text-gray-900 mb-4",
              children: language === "pt-BR" ? "Precisa exercer seus direitos sob a LGPD?" : "Need to exercise your rights under GDPR?"
            }), /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
              className: "text-gray-600 mb-6",
              children: language === "pt-BR" ? "Nossa equipe está pronta para atender suas solicitações de forma rápida e eficiente." : "Our team is ready to handle your requests quickly and efficiently."
            }), /* @__PURE__ */ jsxRuntimeExports.jsxs("a", {
              href: "mailto:legal@mylinearts.com",
              className: "btn btn-primary inline-flex items-center",
              children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Mail, {
                className: "h-5 w-5 mr-2"
              }), language === "pt-BR" ? "Exercer meus direitos" : "Exercise my rights"]
            })]
          })
        })]
      })
    })
  });
};
const LGPDPage$1 = withComponentProps(LGPDPage);
const route14 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: LGPDPage$1
}, Symbol.toStringTag, { value: "Module" }));
const serverManifest = { "entry": { "module": "/assets/entry.client-CgTTkYRI.js", "imports": ["/assets/chunk-NL6KNZEE-D2jbZBCO.js"], "css": [] }, "routes": { "root": { "id": "root", "parentId": void 0, "path": "", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": true, "module": "/assets/root-CEy1cOOd.js", "imports": ["/assets/chunk-NL6KNZEE-D2jbZBCO.js", "/assets/LanguageContext-CSFa_xIf.js", "/assets/index.esm-ycTFGbnS.js", "/assets/createLucideIcon-DdH4JB2E.js", "/assets/linkedin-BhJol6v6.js"], "css": ["/assets/root-DC79h49X.css"], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "pages/LandingPage": { "id": "pages/LandingPage", "parentId": "root", "path": void 0, "index": true, "caseSensitive": void 0, "hasAction": false, "hasLoader": true, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/LandingPage-C-Bc7pdP.js", "imports": ["/assets/chunk-NL6KNZEE-D2jbZBCO.js", "/assets/LanguageContext-CSFa_xIf.js", "/assets/credit-card-D0ne3sLg.js", "/assets/createLucideIcon-DdH4JB2E.js", "/assets/eye-Duex0WBd.js", "/assets/linkedin-BhJol6v6.js", "/assets/users-Dr1TWXvh.js"], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "pages/BlogListPage": { "id": "pages/BlogListPage", "parentId": "root", "path": "/blog", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/BlogListPage-DOSxGiXN.js", "imports": ["/assets/chunk-NL6KNZEE-D2jbZBCO.js", "/assets/LanguageContext-CSFa_xIf.js", "/assets/SEOHead-BrO_jRkx.js", "/assets/index.esm-ycTFGbnS.js"], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "pages/BlogPostPage": { "id": "pages/BlogPostPage", "parentId": "root", "path": "/blog/:slug", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/BlogPostPage-CIpq1-_q.js", "imports": ["/assets/chunk-NL6KNZEE-D2jbZBCO.js", "/assets/LanguageContext-CSFa_xIf.js", "/assets/SEOHead-BrO_jRkx.js", "/assets/index.esm-ycTFGbnS.js"], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "pages/PrivacyPolicyPage": { "id": "pages/PrivacyPolicyPage", "parentId": "root", "path": "/politica-de-privacidade", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/PrivacyPolicyPage-CG0PDhw7.js", "imports": ["/assets/chunk-NL6KNZEE-D2jbZBCO.js", "/assets/LanguageContext-CSFa_xIf.js", "/assets/proxy-d_Rfewhl.js", "/assets/eye-Duex0WBd.js", "/assets/createLucideIcon-DdH4JB2E.js", "/assets/users-Dr1TWXvh.js", "/assets/file-text-CW9E8Cfy.js"], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "pages/TermsOfServicePage": { "id": "pages/TermsOfServicePage", "parentId": "root", "path": "/termos-de-servico", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/TermsOfServicePage-CxRjZO-K.js", "imports": ["/assets/chunk-NL6KNZEE-D2jbZBCO.js", "/assets/LanguageContext-CSFa_xIf.js", "/assets/proxy-d_Rfewhl.js", "/assets/file-text-CW9E8Cfy.js", "/assets/users-Dr1TWXvh.js", "/assets/credit-card-D0ne3sLg.js", "/assets/createLucideIcon-DdH4JB2E.js"], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "pages/CookiePolicyPage": { "id": "pages/CookiePolicyPage", "parentId": "root", "path": "/politica-de-cookies", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/CookiePolicyPage-Ukt9xVN1.js", "imports": ["/assets/chunk-NL6KNZEE-D2jbZBCO.js", "/assets/LanguageContext-CSFa_xIf.js", "/assets/proxy-d_Rfewhl.js", "/assets/createLucideIcon-DdH4JB2E.js", "/assets/users-Dr1TWXvh.js"], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "pages/LGPDPage": { "id": "pages/LGPDPage", "parentId": "root", "path": "/lgpd", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/LGPDPage-B1Nz_qKM.js", "imports": ["/assets/chunk-NL6KNZEE-D2jbZBCO.js", "/assets/LanguageContext-CSFa_xIf.js", "/assets/proxy-d_Rfewhl.js", "/assets/createLucideIcon-DdH4JB2E.js", "/assets/file-text-CW9E8Cfy.js", "/assets/eye-Duex0WBd.js"], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "landing-en": { "id": "landing-en", "parentId": "root", "path": "/en", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": true, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/LandingPage-C-Bc7pdP.js", "imports": ["/assets/chunk-NL6KNZEE-D2jbZBCO.js", "/assets/LanguageContext-CSFa_xIf.js", "/assets/credit-card-D0ne3sLg.js", "/assets/createLucideIcon-DdH4JB2E.js", "/assets/eye-Duex0WBd.js", "/assets/linkedin-BhJol6v6.js", "/assets/users-Dr1TWXvh.js"], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "blog-list-en": { "id": "blog-list-en", "parentId": "root", "path": "/en/blog", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/BlogListPage-DOSxGiXN.js", "imports": ["/assets/chunk-NL6KNZEE-D2jbZBCO.js", "/assets/LanguageContext-CSFa_xIf.js", "/assets/SEOHead-BrO_jRkx.js", "/assets/index.esm-ycTFGbnS.js"], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "blog-post-en": { "id": "blog-post-en", "parentId": "root", "path": "/en/blog/:slug", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/BlogPostPage-CIpq1-_q.js", "imports": ["/assets/chunk-NL6KNZEE-D2jbZBCO.js", "/assets/LanguageContext-CSFa_xIf.js", "/assets/SEOHead-BrO_jRkx.js", "/assets/index.esm-ycTFGbnS.js"], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "privacy-en": { "id": "privacy-en", "parentId": "root", "path": "/en/privacy-policy", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/PrivacyPolicyPage-CG0PDhw7.js", "imports": ["/assets/chunk-NL6KNZEE-D2jbZBCO.js", "/assets/LanguageContext-CSFa_xIf.js", "/assets/proxy-d_Rfewhl.js", "/assets/eye-Duex0WBd.js", "/assets/createLucideIcon-DdH4JB2E.js", "/assets/users-Dr1TWXvh.js", "/assets/file-text-CW9E8Cfy.js"], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "terms-en": { "id": "terms-en", "parentId": "root", "path": "/en/terms-of-service", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/TermsOfServicePage-CxRjZO-K.js", "imports": ["/assets/chunk-NL6KNZEE-D2jbZBCO.js", "/assets/LanguageContext-CSFa_xIf.js", "/assets/proxy-d_Rfewhl.js", "/assets/file-text-CW9E8Cfy.js", "/assets/users-Dr1TWXvh.js", "/assets/credit-card-D0ne3sLg.js", "/assets/createLucideIcon-DdH4JB2E.js"], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "cookies-en": { "id": "cookies-en", "parentId": "root", "path": "/en/cookie-policy", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/CookiePolicyPage-Ukt9xVN1.js", "imports": ["/assets/chunk-NL6KNZEE-D2jbZBCO.js", "/assets/LanguageContext-CSFa_xIf.js", "/assets/proxy-d_Rfewhl.js", "/assets/createLucideIcon-DdH4JB2E.js", "/assets/users-Dr1TWXvh.js"], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 }, "lgpd-en": { "id": "lgpd-en", "parentId": "root", "path": "/en/lgpd", "index": void 0, "caseSensitive": void 0, "hasAction": false, "hasLoader": false, "hasClientAction": false, "hasClientLoader": false, "hasClientMiddleware": false, "hasErrorBoundary": false, "module": "/assets/LGPDPage-B1Nz_qKM.js", "imports": ["/assets/chunk-NL6KNZEE-D2jbZBCO.js", "/assets/LanguageContext-CSFa_xIf.js", "/assets/proxy-d_Rfewhl.js", "/assets/createLucideIcon-DdH4JB2E.js", "/assets/file-text-CW9E8Cfy.js", "/assets/eye-Duex0WBd.js"], "css": [], "clientActionModule": void 0, "clientLoaderModule": void 0, "clientMiddlewareModule": void 0, "hydrateFallbackModule": void 0 } }, "url": "/assets/manifest-9435ef5d.js", "version": "9435ef5d", "sri": void 0 };
const assetsBuildDirectory = "build/client";
const basename = "/";
const future = { "unstable_middleware": false, "unstable_optimizeDeps": false, "unstable_splitRouteModules": false, "unstable_subResourceIntegrity": false, "unstable_viteEnvironmentApi": true };
const ssr = true;
const isSpaMode = false;
const prerender = [];
const routeDiscovery = { "mode": "lazy", "manifestPath": "/__manifest" };
const publicPath = "/";
const entry = { module: entryServer };
const routes = {
  "root": {
    id: "root",
    parentId: void 0,
    path: "",
    index: void 0,
    caseSensitive: void 0,
    module: route0
  },
  "pages/LandingPage": {
    id: "pages/LandingPage",
    parentId: "root",
    path: void 0,
    index: true,
    caseSensitive: void 0,
    module: route8
  },
  "pages/BlogListPage": {
    id: "pages/BlogListPage",
    parentId: "root",
    path: "/blog",
    index: void 0,
    caseSensitive: void 0,
    module: route9
  },
  "pages/BlogPostPage": {
    id: "pages/BlogPostPage",
    parentId: "root",
    path: "/blog/:slug",
    index: void 0,
    caseSensitive: void 0,
    module: route10
  },
  "pages/PrivacyPolicyPage": {
    id: "pages/PrivacyPolicyPage",
    parentId: "root",
    path: "/politica-de-privacidade",
    index: void 0,
    caseSensitive: void 0,
    module: route11
  },
  "pages/TermsOfServicePage": {
    id: "pages/TermsOfServicePage",
    parentId: "root",
    path: "/termos-de-servico",
    index: void 0,
    caseSensitive: void 0,
    module: route12
  },
  "pages/CookiePolicyPage": {
    id: "pages/CookiePolicyPage",
    parentId: "root",
    path: "/politica-de-cookies",
    index: void 0,
    caseSensitive: void 0,
    module: route13
  },
  "pages/LGPDPage": {
    id: "pages/LGPDPage",
    parentId: "root",
    path: "/lgpd",
    index: void 0,
    caseSensitive: void 0,
    module: route14
  },
  "landing-en": {
    id: "landing-en",
    parentId: "root",
    path: "/en",
    index: void 0,
    caseSensitive: void 0,
    module: route8
  },
  "blog-list-en": {
    id: "blog-list-en",
    parentId: "root",
    path: "/en/blog",
    index: void 0,
    caseSensitive: void 0,
    module: route9
  },
  "blog-post-en": {
    id: "blog-post-en",
    parentId: "root",
    path: "/en/blog/:slug",
    index: void 0,
    caseSensitive: void 0,
    module: route10
  },
  "privacy-en": {
    id: "privacy-en",
    parentId: "root",
    path: "/en/privacy-policy",
    index: void 0,
    caseSensitive: void 0,
    module: route11
  },
  "terms-en": {
    id: "terms-en",
    parentId: "root",
    path: "/en/terms-of-service",
    index: void 0,
    caseSensitive: void 0,
    module: route12
  },
  "cookies-en": {
    id: "cookies-en",
    parentId: "root",
    path: "/en/cookie-policy",
    index: void 0,
    caseSensitive: void 0,
    module: route13
  },
  "lgpd-en": {
    id: "lgpd-en",
    parentId: "root",
    path: "/en/lgpd",
    index: void 0,
    caseSensitive: void 0,
    module: route14
  }
};
export {
  serverManifest as assets,
  assetsBuildDirectory,
  basename,
  entry,
  future,
  isSpaMode,
  prerender,
  publicPath,
  routeDiscovery,
  routes,
  ssr
};
